#pragma once

#include <krpc/decoder.h>
#include <krpc/encoder.h>
#include <krpc/error.h>
#include <krpc/memory.h>
#include <krpc/types.h>
#include <pb_decode.h>
#include <pb_encode.h>

#include <krpc.h>

#ifdef __cplusplus
extern "C" {
#endif

/**
 * An antenna. Obtained by calling SpaceCenter::Part::antenna.
 */
typedef krpc_object_t krpc_SpaceCenter_Antenna_t;
/**
 * Provides basic auto-piloting utilities for a vessel.
 * Created by calling SpaceCenter::Vessel::auto_pilot.
 *
 * If a client engages the auto-pilot and then closes its connection to the server,
 * the auto-pilot will be disengaged and its target reference frame, direction and roll
 * reset to default.
 */
typedef krpc_object_t krpc_SpaceCenter_AutoPilot_t;
/**
 * Controls the game's camera.
 * Obtained by calling SpaceCenter::camera.
 */
typedef krpc_object_t krpc_SpaceCenter_Camera_t;
/**
 * A cargo bay. Obtained by calling SpaceCenter::Part::cargo_bay.
 */
typedef krpc_object_t krpc_SpaceCenter_CargoBay_t;
/**
 * Represents a celestial body (such as a planet or moon).
 * See SpaceCenter::bodies.
 */
typedef krpc_object_t krpc_SpaceCenter_CelestialBody_t;
/**
 * Represents a communication node in the network. For example, a vessel or the KSC.
 */
typedef krpc_object_t krpc_SpaceCenter_CommLink_t;
/**
 * Represents a communication node in the network. For example, a vessel or the KSC.
 */
typedef krpc_object_t krpc_SpaceCenter_CommNode_t;
/**
 * Used to interact with CommNet for a given vessel.
 * Obtained by calling SpaceCenter::Vessel::comms.
 */
typedef krpc_object_t krpc_SpaceCenter_Comms_t;
/**
 * A contract. Can be accessed using SpaceCenter::contract_manager.
 */
typedef krpc_object_t krpc_SpaceCenter_Contract_t;
/**
 * Contracts manager.
 * Obtained by calling SpaceCenter::waypoint_manager.
 */
typedef krpc_object_t krpc_SpaceCenter_ContractManager_t;
/**
 * A contract parameter. See SpaceCenter::Contract::parameters.
 */
typedef krpc_object_t krpc_SpaceCenter_ContractParameter_t;
/**
 * Used to manipulate the controls of a vessel. This includes adjusting the
 * throttle, enabling/disabling systems such as SAS and RCS, or altering the
 * direction in which the vessel is pointing.
 * Obtained by calling SpaceCenter::Vessel::control.
 *
 * Control inputs (such as pitch, yaw and roll) are zeroed when all clients
 * that have set one or more of these inputs are no longer connected.
 */
typedef krpc_object_t krpc_SpaceCenter_Control_t;
/**
 * An aerodynamic control surface. Obtained by calling SpaceCenter::Part::control_surface.
 */
typedef krpc_object_t krpc_SpaceCenter_ControlSurface_t;
/**
 * Represents crew in a vessel. Can be obtained using SpaceCenter::Vessel::crew.
 */
typedef krpc_object_t krpc_SpaceCenter_CrewMember_t;
/**
 * A decoupler. Obtained by calling SpaceCenter::Part::decoupler
 */
typedef krpc_object_t krpc_SpaceCenter_Decoupler_t;
/**
 * A docking port. Obtained by calling SpaceCenter::Part::docking_port
 */
typedef krpc_object_t krpc_SpaceCenter_DockingPort_t;
/**
 * An engine, including ones of various types.
 * For example liquid fuelled gimballed engines, solid rocket boosters and jet engines.
 * Obtained by calling SpaceCenter::Part::engine.
 *
 * For RCS thrusters SpaceCenter::Part::rcs.
 */
typedef krpc_object_t krpc_SpaceCenter_Engine_t;
/**
 * Obtained by calling SpaceCenter::Part::experiment.
 */
typedef krpc_object_t krpc_SpaceCenter_Experiment_t;
/**
 * A fairing. Obtained by calling SpaceCenter::Part::fairing.
 */
typedef krpc_object_t krpc_SpaceCenter_Fairing_t;
/**
 * Used to get flight telemetry for a vessel, by calling SpaceCenter::Vessel::flight.
 * All of the information returned by this class is given in the reference frame
 * passed to that method.
 * Obtained by calling SpaceCenter::Vessel::flight.
 *
 * To get orbital information, such as the apoapsis or inclination, see SpaceCenter::Orbit.
 */
typedef krpc_object_t krpc_SpaceCenter_Flight_t;
/**
 * Obtained by calling SpaceCenter::Part::add_force.
 */
typedef krpc_object_t krpc_SpaceCenter_Force_t;
/**
 * An air intake. Obtained by calling SpaceCenter::Part::intake.
 */
typedef krpc_object_t krpc_SpaceCenter_Intake_t;
/**
 * A launch clamp. Obtained by calling SpaceCenter::Part::launch_clamp.
 */
typedef krpc_object_t krpc_SpaceCenter_LaunchClamp_t;
/**
 * A landing leg. Obtained by calling SpaceCenter::Part::leg.
 */
typedef krpc_object_t krpc_SpaceCenter_Leg_t;
/**
 * A light. Obtained by calling SpaceCenter::Part::light.
 */
typedef krpc_object_t krpc_SpaceCenter_Light_t;
/**
 * This can be used to interact with a specific part module. This includes part modules in
 * stock KSP, and those added by mods.
 *
 * In KSP, each part has zero or more
 * <a href="https://wiki.kerbalspaceprogram.com/wiki/CFG_File_Documentation#MODULES">PartModules</a>
 * associated with it. Each one contains some of the functionality of the part.
 * For example, an engine has a "ModuleEngines" part module that contains all the
 * functionality of an engine.
 */
typedef krpc_object_t krpc_SpaceCenter_Module_t;
/**
 * Represents a maneuver node. Can be created using SpaceCenter::Control::add_node.
 */
typedef krpc_object_t krpc_SpaceCenter_Node_t;
/**
 * Describes an orbit. For example, the orbit of a vessel, obtained by calling
 * SpaceCenter::Vessel::orbit, or a celestial body, obtained by calling
 * SpaceCenter::CelestialBody::orbit.
 */
typedef krpc_object_t krpc_SpaceCenter_Orbit_t;
/**
 * A parachute. Obtained by calling SpaceCenter::Part::parachute.
 */
typedef krpc_object_t krpc_SpaceCenter_Parachute_t;
/**
 * Represents an individual part. Vessels are made up of multiple parts.
 * Instances of this class can be obtained by several methods in SpaceCenter::Parts.
 */
typedef krpc_object_t krpc_SpaceCenter_Part_t;
/**
 * Instances of this class are used to interact with the parts of a vessel.
 * An instance can be obtained by calling SpaceCenter::Vessel::parts.
 */
typedef krpc_object_t krpc_SpaceCenter_Parts_t;
/**
 * A propellant for an engine. Obtains by calling SpaceCenter::Engine::propellants.
 */
typedef krpc_object_t krpc_SpaceCenter_Propellant_t;
/**
 * An RCS block or thruster. Obtained by calling SpaceCenter::Part::rcs.
 */
typedef krpc_object_t krpc_SpaceCenter_RCS_t;
/**
 * A radiator. Obtained by calling SpaceCenter::Part::radiator.
 */
typedef krpc_object_t krpc_SpaceCenter_Radiator_t;
/**
 * A reaction wheel. Obtained by calling SpaceCenter::Part::reaction_wheel.
 */
typedef krpc_object_t krpc_SpaceCenter_ReactionWheel_t;
/**
 * Represents a reference frame for positions, rotations and
 * velocities. Contains:
 *
 * - The position of the origin.
 * - The directions of the x, y and z axes.
 * - The linear velocity of the frame.
 * - The angular velocity of the frame.
 *
 * This class does not contain any properties or methods. It is only
 * used as a parameter to other functions.
 */
typedef krpc_object_t krpc_SpaceCenter_ReferenceFrame_t;
/**
 * An individual resource stored within a part.
 * Created using methods in the SpaceCenter::Resources class.
 */
typedef krpc_object_t krpc_SpaceCenter_Resource_t;
/**
 * A resource converter. Obtained by calling SpaceCenter::Part::resource_converter.
 */
typedef krpc_object_t krpc_SpaceCenter_ResourceConverter_t;
/**
 * A resource harvester (drill). Obtained by calling SpaceCenter::Part::resource_harvester.
 */
typedef krpc_object_t krpc_SpaceCenter_ResourceHarvester_t;
/**
 * Transfer resources between parts.
 */
typedef krpc_object_t krpc_SpaceCenter_ResourceTransfer_t;
/**
 * Represents the collection of resources stored in a vessel, stage or part.
 * Created by calling SpaceCenter::Vessel::resources,
 * SpaceCenter::Vessel::resources_in_decouple_stage or
 * SpaceCenter::Part::resources.
 */
typedef krpc_object_t krpc_SpaceCenter_Resources_t;
/**
 * Obtained by calling SpaceCenter::Experiment::data.
 */
typedef krpc_object_t krpc_SpaceCenter_ScienceData_t;
/**
 * Obtained by calling SpaceCenter::Experiment::science_subject.
 */
typedef krpc_object_t krpc_SpaceCenter_ScienceSubject_t;
/**
 * A sensor, such as a thermometer. Obtained by calling SpaceCenter::Part::sensor.
 */
typedef krpc_object_t krpc_SpaceCenter_Sensor_t;
/**
 * A solar panel. Obtained by calling SpaceCenter::Part::solar_panel.
 */
typedef krpc_object_t krpc_SpaceCenter_SolarPanel_t;
/**
 * The component of an SpaceCenter::Engine or SpaceCenter::RCS part that generates thrust.
 * Can obtained by calling SpaceCenter::Engine::thrusters or SpaceCenter::RCS::thrusters.
 *
 * Engines can consist of multiple thrusters.
 * For example, the S3 KS-25x4 "Mammoth" has four rocket nozzels, and so consists of
 * four thrusters.
 */
typedef krpc_object_t krpc_SpaceCenter_Thruster_t;
/**
 * These objects are used to interact with vessels in KSP. This includes getting
 * orbital and flight data, manipulating control inputs and managing resources.
 * Created using SpaceCenter::active_vessel or SpaceCenter::vessels.
 */
typedef krpc_object_t krpc_SpaceCenter_Vessel_t;
/**
 * Represents a waypoint. Can be created using SpaceCenter::WaypointManager::add_waypoint.
 */
typedef krpc_object_t krpc_SpaceCenter_Waypoint_t;
/**
 * Waypoints are the location markers you can see on the map view showing you where contracts are targeted for.
 * With this structure, you can obtain coordinate data for the locations of these waypoints.
 * Obtained by calling SpaceCenter::waypoint_manager.
 */
typedef krpc_object_t krpc_SpaceCenter_WaypointManager_t;
/**
 * A wheel. Includes landing gear and rover wheels.
 * Obtained by calling SpaceCenter::Part::wheel.
 * Can be used to control the motors, steering and deployment of wheels, among other things.
 */
typedef krpc_object_t krpc_SpaceCenter_Wheel_t;

#ifndef KRPC_TYPE_LIST_OBJECT
#define KRPC_TYPE_LIST_OBJECT

typedef struct krpc_list_object_s krpc_list_object_t;
struct krpc_list_object_s {
  size_t size;
  krpc_SpaceCenter_Propellant_t * items;
};

krpc_error_t krpc_encode_list_object(
  pb_ostream_t * stream, const krpc_list_object_t * value);
krpc_error_t krpc_encode_size_list_object(
  size_t * size, const krpc_list_object_t * value);
bool krpc_encode_callback_list_object(
  pb_ostream_t * stream, const pb_field_t * field, void * const * arg);
krpc_error_t krpc_decode_list_object(
  pb_istream_t * stream, krpc_list_object_t * value);

#endif  // KRPC_TYPE_LIST_OBJECT

#ifndef KRPC_TYPE_LIST_OBJECT
#define KRPC_TYPE_LIST_OBJECT

typedef struct krpc_list_object_s krpc_list_object_t;
struct krpc_list_object_s {
  size_t size;
  krpc_SpaceCenter_Leg_t * items;
};

krpc_error_t krpc_encode_list_object(
  pb_ostream_t * stream, const krpc_list_object_t * value);
krpc_error_t krpc_encode_size_list_object(
  size_t * size, const krpc_list_object_t * value);
bool krpc_encode_callback_list_object(
  pb_ostream_t * stream, const pb_field_t * field, void * const * arg);
krpc_error_t krpc_decode_list_object(
  pb_istream_t * stream, krpc_list_object_t * value);

#endif  // KRPC_TYPE_LIST_OBJECT

#ifndef KRPC_TYPE_TUPLE_DOUBLE_DOUBLE_DOUBLE
#define KRPC_TYPE_TUPLE_DOUBLE_DOUBLE_DOUBLE

typedef struct krpc_tuple_double_double_double_s krpc_tuple_double_double_double_t;
struct krpc_tuple_double_double_double_s {
  double e0;
  double e1;
  double e2;
};

krpc_error_t krpc_encode_tuple_double_double_double(
  pb_ostream_t * stream, const krpc_tuple_double_double_double_t * value);
krpc_error_t krpc_encode_size_tuple_double_double_double(
  size_t * size, const krpc_tuple_double_double_double_t * value);
bool krpc_encode_callback_tuple_double_double_double(
  pb_ostream_t * stream, const pb_field_t * field, void * const * arg);
krpc_error_t krpc_decode_tuple_double_double_double(
  pb_istream_t * stream, krpc_tuple_double_double_double_t * value);

#endif  // KRPC_TYPE_TUPLE_DOUBLE_DOUBLE_DOUBLE

#ifndef KRPC_TYPE_TUPLE_TUPLE_DOUBLE_DOUBLE_DOUBLE_TUPLE_DOUBLE_DOUBLE_DOUBLE
#define KRPC_TYPE_TUPLE_TUPLE_DOUBLE_DOUBLE_DOUBLE_TUPLE_DOUBLE_DOUBLE_DOUBLE

typedef struct krpc_tuple_tuple_double_double_double_tuple_double_double_double_s krpc_tuple_tuple_double_double_double_tuple_double_double_double_t;
struct krpc_tuple_tuple_double_double_double_tuple_double_double_double_s {
  krpc_tuple_double_double_double_t e0;
  krpc_tuple_double_double_double_t e1;
};

krpc_error_t krpc_encode_tuple_tuple_double_double_double_tuple_double_double_double(
  pb_ostream_t * stream, const krpc_tuple_tuple_double_double_double_tuple_double_double_double_t * value);
krpc_error_t krpc_encode_size_tuple_tuple_double_double_double_tuple_double_double_double(
  size_t * size, const krpc_tuple_tuple_double_double_double_tuple_double_double_double_t * value);
bool krpc_encode_callback_tuple_tuple_double_double_double_tuple_double_double_double(
  pb_ostream_t * stream, const pb_field_t * field, void * const * arg);
krpc_error_t krpc_decode_tuple_tuple_double_double_double_tuple_double_double_double(
  pb_istream_t * stream, krpc_tuple_tuple_double_double_double_tuple_double_double_double_t * value);

#endif  // KRPC_TYPE_TUPLE_TUPLE_DOUBLE_DOUBLE_DOUBLE_TUPLE_DOUBLE_DOUBLE_DOUBLE

#ifndef KRPC_TYPE_LIST_OBJECT
#define KRPC_TYPE_LIST_OBJECT

typedef struct krpc_list_object_s krpc_list_object_t;
struct krpc_list_object_s {
  size_t size;
  krpc_SpaceCenter_Decoupler_t * items;
};

krpc_error_t krpc_encode_list_object(
  pb_ostream_t * stream, const krpc_list_object_t * value);
krpc_error_t krpc_encode_size_list_object(
  size_t * size, const krpc_list_object_t * value);
bool krpc_encode_callback_list_object(
  pb_ostream_t * stream, const pb_field_t * field, void * const * arg);
krpc_error_t krpc_decode_list_object(
  pb_istream_t * stream, krpc_list_object_t * value);

#endif  // KRPC_TYPE_LIST_OBJECT

#ifndef KRPC_TYPE_DICTIONARY_STRING_FLOAT
#define KRPC_TYPE_DICTIONARY_STRING_FLOAT

typedef struct krpc_dictionary_entry_string_float_s krpc_dictionary_entry_string_float_t;
struct krpc_dictionary_entry_string_float_s {
  char * key;
  float value;
};

typedef struct krpc_dictionary_string_float_s krpc_dictionary_string_float_t;
struct krpc_dictionary_string_float_s {
  size_t size;
  krpc_dictionary_entry_string_float_t * entries;
};

krpc_error_t krpc_encode_dictionary_string_float(
  pb_ostream_t * stream, const krpc_dictionary_string_float_t * value);
krpc_error_t krpc_encode_size_dictionary_string_float(
  size_t * size, const krpc_dictionary_string_float_t * value);
bool krpc_encode_callback_dictionary_string_float(
  pb_ostream_t * stream, const pb_field_t * field, void * const * arg);
krpc_error_t krpc_decode_dictionary_string_float(
  pb_istream_t * stream, krpc_dictionary_string_float_t * value);

#endif  // KRPC_TYPE_DICTIONARY_STRING_FLOAT

#ifndef KRPC_TYPE_LIST_OBJECT
#define KRPC_TYPE_LIST_OBJECT

typedef struct krpc_list_object_s krpc_list_object_t;
struct krpc_list_object_s {
  size_t size;
  krpc_SpaceCenter_CommLink_t * items;
};

krpc_error_t krpc_encode_list_object(
  pb_ostream_t * stream, const krpc_list_object_t * value);
krpc_error_t krpc_encode_size_list_object(
  size_t * size, const krpc_list_object_t * value);
bool krpc_encode_callback_list_object(
  pb_ostream_t * stream, const pb_field_t * field, void * const * arg);
krpc_error_t krpc_decode_list_object(
  pb_istream_t * stream, krpc_list_object_t * value);

#endif  // KRPC_TYPE_LIST_OBJECT

#ifndef KRPC_TYPE_LIST_OBJECT
#define KRPC_TYPE_LIST_OBJECT

typedef struct krpc_list_object_s krpc_list_object_t;
struct krpc_list_object_s {
  size_t size;
  krpc_SpaceCenter_CelestialBody_t * items;
};

krpc_error_t krpc_encode_list_object(
  pb_ostream_t * stream, const krpc_list_object_t * value);
krpc_error_t krpc_encode_size_list_object(
  size_t * size, const krpc_list_object_t * value);
bool krpc_encode_callback_list_object(
  pb_ostream_t * stream, const pb_field_t * field, void * const * arg);
krpc_error_t krpc_decode_list_object(
  pb_istream_t * stream, krpc_list_object_t * value);

#endif  // KRPC_TYPE_LIST_OBJECT

#ifndef KRPC_TYPE_LIST_STRING
#define KRPC_TYPE_LIST_STRING

typedef struct krpc_list_string_s krpc_list_string_t;
struct krpc_list_string_s {
  size_t size;
  char * * items;
};

krpc_error_t krpc_encode_list_string(
  pb_ostream_t * stream, const krpc_list_string_t * value);
krpc_error_t krpc_encode_size_list_string(
  size_t * size, const krpc_list_string_t * value);
bool krpc_encode_callback_list_string(
  pb_ostream_t * stream, const pb_field_t * field, void * const * arg);
krpc_error_t krpc_decode_list_string(
  pb_istream_t * stream, krpc_list_string_t * value);

#endif  // KRPC_TYPE_LIST_STRING

#ifndef KRPC_TYPE_LIST_OBJECT
#define KRPC_TYPE_LIST_OBJECT

typedef struct krpc_list_object_s krpc_list_object_t;
struct krpc_list_object_s {
  size_t size;
  krpc_SpaceCenter_Intake_t * items;
};

krpc_error_t krpc_encode_list_object(
  pb_ostream_t * stream, const krpc_list_object_t * value);
krpc_error_t krpc_encode_size_list_object(
  size_t * size, const krpc_list_object_t * value);
bool krpc_encode_callback_list_object(
  pb_ostream_t * stream, const pb_field_t * field, void * const * arg);
krpc_error_t krpc_decode_list_object(
  pb_istream_t * stream, krpc_list_object_t * value);

#endif  // KRPC_TYPE_LIST_OBJECT

#ifndef KRPC_TYPE_LIST_OBJECT
#define KRPC_TYPE_LIST_OBJECT

typedef struct krpc_list_object_s krpc_list_object_t;
struct krpc_list_object_s {
  size_t size;
  krpc_SpaceCenter_ContractParameter_t * items;
};

krpc_error_t krpc_encode_list_object(
  pb_ostream_t * stream, const krpc_list_object_t * value);
krpc_error_t krpc_encode_size_list_object(
  size_t * size, const krpc_list_object_t * value);
bool krpc_encode_callback_list_object(
  pb_ostream_t * stream, const pb_field_t * field, void * const * arg);
krpc_error_t krpc_decode_list_object(
  pb_istream_t * stream, krpc_list_object_t * value);

#endif  // KRPC_TYPE_LIST_OBJECT

#ifndef KRPC_TYPE_LIST_OBJECT
#define KRPC_TYPE_LIST_OBJECT

typedef struct krpc_list_object_s krpc_list_object_t;
struct krpc_list_object_s {
  size_t size;
  krpc_SpaceCenter_Module_t * items;
};

krpc_error_t krpc_encode_list_object(
  pb_ostream_t * stream, const krpc_list_object_t * value);
krpc_error_t krpc_encode_size_list_object(
  size_t * size, const krpc_list_object_t * value);
bool krpc_encode_callback_list_object(
  pb_ostream_t * stream, const pb_field_t * field, void * const * arg);
krpc_error_t krpc_decode_list_object(
  pb_istream_t * stream, krpc_list_object_t * value);

#endif  // KRPC_TYPE_LIST_OBJECT

#ifndef KRPC_TYPE_LIST_OBJECT
#define KRPC_TYPE_LIST_OBJECT

typedef struct krpc_list_object_s krpc_list_object_t;
struct krpc_list_object_s {
  size_t size;
  krpc_SpaceCenter_ControlSurface_t * items;
};

krpc_error_t krpc_encode_list_object(
  pb_ostream_t * stream, const krpc_list_object_t * value);
krpc_error_t krpc_encode_size_list_object(
  size_t * size, const krpc_list_object_t * value);
bool krpc_encode_callback_list_object(
  pb_ostream_t * stream, const pb_field_t * field, void * const * arg);
krpc_error_t krpc_decode_list_object(
  pb_istream_t * stream, krpc_list_object_t * value);

#endif  // KRPC_TYPE_LIST_OBJECT

#ifndef KRPC_TYPE_LIST_DOUBLE
#define KRPC_TYPE_LIST_DOUBLE

typedef struct krpc_list_double_s krpc_list_double_t;
struct krpc_list_double_s {
  size_t size;
  double * items;
};

krpc_error_t krpc_encode_list_double(
  pb_ostream_t * stream, const krpc_list_double_t * value);
krpc_error_t krpc_encode_size_list_double(
  size_t * size, const krpc_list_double_t * value);
bool krpc_encode_callback_list_double(
  pb_ostream_t * stream, const pb_field_t * field, void * const * arg);
krpc_error_t krpc_decode_list_double(
  pb_istream_t * stream, krpc_list_double_t * value);

#endif  // KRPC_TYPE_LIST_DOUBLE

#ifndef KRPC_TYPE_TUPLE_FLOAT_FLOAT_FLOAT
#define KRPC_TYPE_TUPLE_FLOAT_FLOAT_FLOAT

typedef struct krpc_tuple_float_float_float_s krpc_tuple_float_float_float_t;
struct krpc_tuple_float_float_float_s {
  float e0;
  float e1;
  float e2;
};

krpc_error_t krpc_encode_tuple_float_float_float(
  pb_ostream_t * stream, const krpc_tuple_float_float_float_t * value);
krpc_error_t krpc_encode_size_tuple_float_float_float(
  size_t * size, const krpc_tuple_float_float_float_t * value);
bool krpc_encode_callback_tuple_float_float_float(
  pb_ostream_t * stream, const pb_field_t * field, void * const * arg);
krpc_error_t krpc_decode_tuple_float_float_float(
  pb_istream_t * stream, krpc_tuple_float_float_float_t * value);

#endif  // KRPC_TYPE_TUPLE_FLOAT_FLOAT_FLOAT

#ifndef KRPC_TYPE_LIST_OBJECT
#define KRPC_TYPE_LIST_OBJECT

typedef struct krpc_list_object_s krpc_list_object_t;
struct krpc_list_object_s {
  size_t size;
  krpc_SpaceCenter_Part_t * items;
};

krpc_error_t krpc_encode_list_object(
  pb_ostream_t * stream, const krpc_list_object_t * value);
krpc_error_t krpc_encode_size_list_object(
  size_t * size, const krpc_list_object_t * value);
bool krpc_encode_callback_list_object(
  pb_ostream_t * stream, const pb_field_t * field, void * const * arg);
krpc_error_t krpc_decode_list_object(
  pb_istream_t * stream, krpc_list_object_t * value);

#endif  // KRPC_TYPE_LIST_OBJECT

#ifndef KRPC_TYPE_TUPLE_DOUBLE_DOUBLE_DOUBLE_DOUBLE
#define KRPC_TYPE_TUPLE_DOUBLE_DOUBLE_DOUBLE_DOUBLE

typedef struct krpc_tuple_double_double_double_double_s krpc_tuple_double_double_double_double_t;
struct krpc_tuple_double_double_double_double_s {
  double e0;
  double e1;
  double e2;
  double e3;
};

krpc_error_t krpc_encode_tuple_double_double_double_double(
  pb_ostream_t * stream, const krpc_tuple_double_double_double_double_t * value);
krpc_error_t krpc_encode_size_tuple_double_double_double_double(
  size_t * size, const krpc_tuple_double_double_double_double_t * value);
bool krpc_encode_callback_tuple_double_double_double_double(
  pb_ostream_t * stream, const pb_field_t * field, void * const * arg);
krpc_error_t krpc_decode_tuple_double_double_double_double(
  pb_istream_t * stream, krpc_tuple_double_double_double_double_t * value);

#endif  // KRPC_TYPE_TUPLE_DOUBLE_DOUBLE_DOUBLE_DOUBLE

#ifndef KRPC_TYPE_LIST_OBJECT
#define KRPC_TYPE_LIST_OBJECT

typedef struct krpc_list_object_s krpc_list_object_t;
struct krpc_list_object_s {
  size_t size;
  krpc_SpaceCenter_CargoBay_t * items;
};

krpc_error_t krpc_encode_list_object(
  pb_ostream_t * stream, const krpc_list_object_t * value);
krpc_error_t krpc_encode_size_list_object(
  size_t * size, const krpc_list_object_t * value);
bool krpc_encode_callback_list_object(
  pb_ostream_t * stream, const pb_field_t * field, void * const * arg);
krpc_error_t krpc_decode_list_object(
  pb_istream_t * stream, krpc_list_object_t * value);

#endif  // KRPC_TYPE_LIST_OBJECT

#ifndef KRPC_TYPE_LIST_OBJECT
#define KRPC_TYPE_LIST_OBJECT

typedef struct krpc_list_object_s krpc_list_object_t;
struct krpc_list_object_s {
  size_t size;
  krpc_SpaceCenter_Contract_t * items;
};

krpc_error_t krpc_encode_list_object(
  pb_ostream_t * stream, const krpc_list_object_t * value);
krpc_error_t krpc_encode_size_list_object(
  size_t * size, const krpc_list_object_t * value);
bool krpc_encode_callback_list_object(
  pb_ostream_t * stream, const pb_field_t * field, void * const * arg);
krpc_error_t krpc_decode_list_object(
  pb_istream_t * stream, krpc_list_object_t * value);

#endif  // KRPC_TYPE_LIST_OBJECT

#ifndef KRPC_TYPE_LIST_OBJECT
#define KRPC_TYPE_LIST_OBJECT

typedef struct krpc_list_object_s krpc_list_object_t;
struct krpc_list_object_s {
  size_t size;
  krpc_SpaceCenter_RCS_t * items;
};

krpc_error_t krpc_encode_list_object(
  pb_ostream_t * stream, const krpc_list_object_t * value);
krpc_error_t krpc_encode_size_list_object(
  size_t * size, const krpc_list_object_t * value);
bool krpc_encode_callback_list_object(
  pb_ostream_t * stream, const pb_field_t * field, void * const * arg);
krpc_error_t krpc_decode_list_object(
  pb_istream_t * stream, krpc_list_object_t * value);

#endif  // KRPC_TYPE_LIST_OBJECT

#ifndef KRPC_TYPE_LIST_OBJECT
#define KRPC_TYPE_LIST_OBJECT

typedef struct krpc_list_object_s krpc_list_object_t;
struct krpc_list_object_s {
  size_t size;
  krpc_SpaceCenter_SolarPanel_t * items;
};

krpc_error_t krpc_encode_list_object(
  pb_ostream_t * stream, const krpc_list_object_t * value);
krpc_error_t krpc_encode_size_list_object(
  size_t * size, const krpc_list_object_t * value);
bool krpc_encode_callback_list_object(
  pb_ostream_t * stream, const pb_field_t * field, void * const * arg);
krpc_error_t krpc_decode_list_object(
  pb_istream_t * stream, krpc_list_object_t * value);

#endif  // KRPC_TYPE_LIST_OBJECT

#ifndef KRPC_TYPE_LIST_OBJECT
#define KRPC_TYPE_LIST_OBJECT

typedef struct krpc_list_object_s krpc_list_object_t;
struct krpc_list_object_s {
  size_t size;
  krpc_SpaceCenter_Wheel_t * items;
};

krpc_error_t krpc_encode_list_object(
  pb_ostream_t * stream, const krpc_list_object_t * value);
krpc_error_t krpc_encode_size_list_object(
  size_t * size, const krpc_list_object_t * value);
bool krpc_encode_callback_list_object(
  pb_ostream_t * stream, const pb_field_t * field, void * const * arg);
krpc_error_t krpc_decode_list_object(
  pb_istream_t * stream, krpc_list_object_t * value);

#endif  // KRPC_TYPE_LIST_OBJECT

#ifndef KRPC_TYPE_LIST_OBJECT
#define KRPC_TYPE_LIST_OBJECT

typedef struct krpc_list_object_s krpc_list_object_t;
struct krpc_list_object_s {
  size_t size;
  krpc_SpaceCenter_DockingPort_t * items;
};

krpc_error_t krpc_encode_list_object(
  pb_ostream_t * stream, const krpc_list_object_t * value);
krpc_error_t krpc_encode_size_list_object(
  size_t * size, const krpc_list_object_t * value);
bool krpc_encode_callback_list_object(
  pb_ostream_t * stream, const pb_field_t * field, void * const * arg);
krpc_error_t krpc_decode_list_object(
  pb_istream_t * stream, krpc_list_object_t * value);

#endif  // KRPC_TYPE_LIST_OBJECT

#ifndef KRPC_TYPE_LIST_OBJECT
#define KRPC_TYPE_LIST_OBJECT

typedef struct krpc_list_object_s krpc_list_object_t;
struct krpc_list_object_s {
  size_t size;
  krpc_SpaceCenter_Parachute_t * items;
};

krpc_error_t krpc_encode_list_object(
  pb_ostream_t * stream, const krpc_list_object_t * value);
krpc_error_t krpc_encode_size_list_object(
  size_t * size, const krpc_list_object_t * value);
bool krpc_encode_callback_list_object(
  pb_ostream_t * stream, const pb_field_t * field, void * const * arg);
krpc_error_t krpc_decode_list_object(
  pb_istream_t * stream, krpc_list_object_t * value);

#endif  // KRPC_TYPE_LIST_OBJECT

#ifndef KRPC_TYPE_LIST_OBJECT
#define KRPC_TYPE_LIST_OBJECT

typedef struct krpc_list_object_s krpc_list_object_t;
struct krpc_list_object_s {
  size_t size;
  krpc_SpaceCenter_Resource_t * items;
};

krpc_error_t krpc_encode_list_object(
  pb_ostream_t * stream, const krpc_list_object_t * value);
krpc_error_t krpc_encode_size_list_object(
  size_t * size, const krpc_list_object_t * value);
bool krpc_encode_callback_list_object(
  pb_ostream_t * stream, const pb_field_t * field, void * const * arg);
krpc_error_t krpc_decode_list_object(
  pb_istream_t * stream, krpc_list_object_t * value);

#endif  // KRPC_TYPE_LIST_OBJECT

#ifndef KRPC_TYPE_DICTIONARY_STRING_STRING
#define KRPC_TYPE_DICTIONARY_STRING_STRING

typedef struct krpc_dictionary_entry_string_string_s krpc_dictionary_entry_string_string_t;
struct krpc_dictionary_entry_string_string_s {
  char * key;
  char * value;
};

typedef struct krpc_dictionary_string_string_s krpc_dictionary_string_string_t;
struct krpc_dictionary_string_string_s {
  size_t size;
  krpc_dictionary_entry_string_string_t * entries;
};

krpc_error_t krpc_encode_dictionary_string_string(
  pb_ostream_t * stream, const krpc_dictionary_string_string_t * value);
krpc_error_t krpc_encode_size_dictionary_string_string(
  size_t * size, const krpc_dictionary_string_string_t * value);
bool krpc_encode_callback_dictionary_string_string(
  pb_ostream_t * stream, const pb_field_t * field, void * const * arg);
krpc_error_t krpc_decode_dictionary_string_string(
  pb_istream_t * stream, krpc_dictionary_string_string_t * value);

#endif  // KRPC_TYPE_DICTIONARY_STRING_STRING

#ifndef KRPC_TYPE_LIST_OBJECT
#define KRPC_TYPE_LIST_OBJECT

typedef struct krpc_list_object_s krpc_list_object_t;
struct krpc_list_object_s {
  size_t size;
  krpc_SpaceCenter_Node_t * items;
};

krpc_error_t krpc_encode_list_object(
  pb_ostream_t * stream, const krpc_list_object_t * value);
krpc_error_t krpc_encode_size_list_object(
  size_t * size, const krpc_list_object_t * value);
bool krpc_encode_callback_list_object(
  pb_ostream_t * stream, const pb_field_t * field, void * const * arg);
krpc_error_t krpc_decode_list_object(
  pb_istream_t * stream, krpc_list_object_t * value);

#endif  // KRPC_TYPE_LIST_OBJECT

#ifndef KRPC_TYPE_LIST_OBJECT
#define KRPC_TYPE_LIST_OBJECT

typedef struct krpc_list_object_s krpc_list_object_t;
struct krpc_list_object_s {
  size_t size;
  krpc_SpaceCenter_ReactionWheel_t * items;
};

krpc_error_t krpc_encode_list_object(
  pb_ostream_t * stream, const krpc_list_object_t * value);
krpc_error_t krpc_encode_size_list_object(
  size_t * size, const krpc_list_object_t * value);
bool krpc_encode_callback_list_object(
  pb_ostream_t * stream, const pb_field_t * field, void * const * arg);
krpc_error_t krpc_decode_list_object(
  pb_istream_t * stream, krpc_list_object_t * value);

#endif  // KRPC_TYPE_LIST_OBJECT

#ifndef KRPC_TYPE_LIST_OBJECT
#define KRPC_TYPE_LIST_OBJECT

typedef struct krpc_list_object_s krpc_list_object_t;
struct krpc_list_object_s {
  size_t size;
  krpc_SpaceCenter_Radiator_t * items;
};

krpc_error_t krpc_encode_list_object(
  pb_ostream_t * stream, const krpc_list_object_t * value);
krpc_error_t krpc_encode_size_list_object(
  size_t * size, const krpc_list_object_t * value);
bool krpc_encode_callback_list_object(
  pb_ostream_t * stream, const pb_field_t * field, void * const * arg);
krpc_error_t krpc_decode_list_object(
  pb_istream_t * stream, krpc_list_object_t * value);

#endif  // KRPC_TYPE_LIST_OBJECT

#ifndef KRPC_TYPE_LIST_LIST_DOUBLE
#define KRPC_TYPE_LIST_LIST_DOUBLE

typedef struct krpc_list_list_double_s krpc_list_list_double_t;
struct krpc_list_list_double_s {
  size_t size;
  krpc_list_double_t * items;
};

krpc_error_t krpc_encode_list_list_double(
  pb_ostream_t * stream, const krpc_list_list_double_t * value);
krpc_error_t krpc_encode_size_list_list_double(
  size_t * size, const krpc_list_list_double_t * value);
bool krpc_encode_callback_list_list_double(
  pb_ostream_t * stream, const pb_field_t * field, void * const * arg);
krpc_error_t krpc_decode_list_list_double(
  pb_istream_t * stream, krpc_list_list_double_t * value);

#endif  // KRPC_TYPE_LIST_LIST_DOUBLE

#ifndef KRPC_TYPE_DICTIONARY_STRING_OBJECT
#define KRPC_TYPE_DICTIONARY_STRING_OBJECT

typedef struct krpc_dictionary_entry_string_object_s krpc_dictionary_entry_string_object_t;
struct krpc_dictionary_entry_string_object_s {
  char * key;
  krpc_SpaceCenter_CelestialBody_t value;
};

typedef struct krpc_dictionary_string_object_s krpc_dictionary_string_object_t;
struct krpc_dictionary_string_object_s {
  size_t size;
  krpc_dictionary_entry_string_object_t * entries;
};

krpc_error_t krpc_encode_dictionary_string_object(
  pb_ostream_t * stream, const krpc_dictionary_string_object_t * value);
krpc_error_t krpc_encode_size_dictionary_string_object(
  size_t * size, const krpc_dictionary_string_object_t * value);
bool krpc_encode_callback_dictionary_string_object(
  pb_ostream_t * stream, const pb_field_t * field, void * const * arg);
krpc_error_t krpc_decode_dictionary_string_object(
  pb_istream_t * stream, krpc_dictionary_string_object_t * value);

#endif  // KRPC_TYPE_DICTIONARY_STRING_OBJECT

#ifndef KRPC_TYPE_LIST_OBJECT
#define KRPC_TYPE_LIST_OBJECT

typedef struct krpc_list_object_s krpc_list_object_t;
struct krpc_list_object_s {
  size_t size;
  krpc_SpaceCenter_Thruster_t * items;
};

krpc_error_t krpc_encode_list_object(
  pb_ostream_t * stream, const krpc_list_object_t * value);
krpc_error_t krpc_encode_size_list_object(
  size_t * size, const krpc_list_object_t * value);
bool krpc_encode_callback_list_object(
  pb_ostream_t * stream, const pb_field_t * field, void * const * arg);
krpc_error_t krpc_decode_list_object(
  pb_istream_t * stream, krpc_list_object_t * value);

#endif  // KRPC_TYPE_LIST_OBJECT

#ifndef KRPC_TYPE_LIST_OBJECT
#define KRPC_TYPE_LIST_OBJECT

typedef struct krpc_list_object_s krpc_list_object_t;
struct krpc_list_object_s {
  size_t size;
  krpc_SpaceCenter_Engine_t * items;
};

krpc_error_t krpc_encode_list_object(
  pb_ostream_t * stream, const krpc_list_object_t * value);
krpc_error_t krpc_encode_size_list_object(
  size_t * size, const krpc_list_object_t * value);
bool krpc_encode_callback_list_object(
  pb_ostream_t * stream, const pb_field_t * field, void * const * arg);
krpc_error_t krpc_decode_list_object(
  pb_istream_t * stream, krpc_list_object_t * value);

#endif  // KRPC_TYPE_LIST_OBJECT

#ifndef KRPC_TYPE_DICTIONARY_STRING_OBJECT
#define KRPC_TYPE_DICTIONARY_STRING_OBJECT

typedef struct krpc_dictionary_entry_string_object_s krpc_dictionary_entry_string_object_t;
struct krpc_dictionary_entry_string_object_s {
  char * key;
  krpc_SpaceCenter_Engine_t value;
};

typedef struct krpc_dictionary_string_object_s krpc_dictionary_string_object_t;
struct krpc_dictionary_string_object_s {
  size_t size;
  krpc_dictionary_entry_string_object_t * entries;
};

krpc_error_t krpc_encode_dictionary_string_object(
  pb_ostream_t * stream, const krpc_dictionary_string_object_t * value);
krpc_error_t krpc_encode_size_dictionary_string_object(
  size_t * size, const krpc_dictionary_string_object_t * value);
bool krpc_encode_callback_dictionary_string_object(
  pb_ostream_t * stream, const pb_field_t * field, void * const * arg);
krpc_error_t krpc_decode_dictionary_string_object(
  pb_istream_t * stream, krpc_dictionary_string_object_t * value);

#endif  // KRPC_TYPE_DICTIONARY_STRING_OBJECT

#ifndef KRPC_TYPE_LIST_OBJECT
#define KRPC_TYPE_LIST_OBJECT

typedef struct krpc_list_object_s krpc_list_object_t;
struct krpc_list_object_s {
  size_t size;
  krpc_SpaceCenter_Fairing_t * items;
};

krpc_error_t krpc_encode_list_object(
  pb_ostream_t * stream, const krpc_list_object_t * value);
krpc_error_t krpc_encode_size_list_object(
  size_t * size, const krpc_list_object_t * value);
bool krpc_encode_callback_list_object(
  pb_ostream_t * stream, const pb_field_t * field, void * const * arg);
krpc_error_t krpc_decode_list_object(
  pb_istream_t * stream, krpc_list_object_t * value);

#endif  // KRPC_TYPE_LIST_OBJECT

#ifndef KRPC_TYPE_DICTIONARY_STRING_INT32
#define KRPC_TYPE_DICTIONARY_STRING_INT32

typedef struct krpc_dictionary_entry_string_int32_s krpc_dictionary_entry_string_int32_t;
struct krpc_dictionary_entry_string_int32_s {
  char * key;
  int32_t value;
};

typedef struct krpc_dictionary_string_int32_s krpc_dictionary_string_int32_t;
struct krpc_dictionary_string_int32_s {
  size_t size;
  krpc_dictionary_entry_string_int32_t * entries;
};

krpc_error_t krpc_encode_dictionary_string_int32(
  pb_ostream_t * stream, const krpc_dictionary_string_int32_t * value);
krpc_error_t krpc_encode_size_dictionary_string_int32(
  size_t * size, const krpc_dictionary_string_int32_t * value);
bool krpc_encode_callback_dictionary_string_int32(
  pb_ostream_t * stream, const pb_field_t * field, void * const * arg);
krpc_error_t krpc_decode_dictionary_string_int32(
  pb_istream_t * stream, krpc_dictionary_string_int32_t * value);

#endif  // KRPC_TYPE_DICTIONARY_STRING_INT32

#ifndef KRPC_TYPE_LIST_OBJECT
#define KRPC_TYPE_LIST_OBJECT

typedef struct krpc_list_object_s krpc_list_object_t;
struct krpc_list_object_s {
  size_t size;
  krpc_SpaceCenter_Light_t * items;
};

krpc_error_t krpc_encode_list_object(
  pb_ostream_t * stream, const krpc_list_object_t * value);
krpc_error_t krpc_encode_size_list_object(
  size_t * size, const krpc_list_object_t * value);
bool krpc_encode_callback_list_object(
  pb_ostream_t * stream, const pb_field_t * field, void * const * arg);
krpc_error_t krpc_decode_list_object(
  pb_istream_t * stream, krpc_list_object_t * value);

#endif  // KRPC_TYPE_LIST_OBJECT

#ifndef KRPC_TYPE_LIST_OBJECT
#define KRPC_TYPE_LIST_OBJECT

typedef struct krpc_list_object_s krpc_list_object_t;
struct krpc_list_object_s {
  size_t size;
  krpc_SpaceCenter_CrewMember_t * items;
};

krpc_error_t krpc_encode_list_object(
  pb_ostream_t * stream, const krpc_list_object_t * value);
krpc_error_t krpc_encode_size_list_object(
  size_t * size, const krpc_list_object_t * value);
bool krpc_encode_callback_list_object(
  pb_ostream_t * stream, const pb_field_t * field, void * const * arg);
krpc_error_t krpc_decode_list_object(
  pb_istream_t * stream, krpc_list_object_t * value);

#endif  // KRPC_TYPE_LIST_OBJECT

#ifndef KRPC_TYPE_SET_STRING
#define KRPC_TYPE_SET_STRING

typedef struct krpc_set_string_s krpc_set_string_t;
struct krpc_set_string_s {
  size_t size;
  char * * items;
};

krpc_error_t krpc_encode_set_string(
  pb_ostream_t * stream, const krpc_set_string_t * value);
krpc_error_t krpc_encode_size_set_string(
  size_t * size, const krpc_set_string_t * value);
bool krpc_encode_callback_set_string(
  pb_ostream_t * stream, const pb_field_t * field, void * const * arg);
krpc_error_t krpc_decode_set_string(
  pb_istream_t * stream, krpc_set_string_t * value);

#endif  // KRPC_TYPE_SET_STRING

#ifndef KRPC_TYPE_LIST_OBJECT
#define KRPC_TYPE_LIST_OBJECT

typedef struct krpc_list_object_s krpc_list_object_t;
struct krpc_list_object_s {
  size_t size;
  krpc_SpaceCenter_Sensor_t * items;
};

krpc_error_t krpc_encode_list_object(
  pb_ostream_t * stream, const krpc_list_object_t * value);
krpc_error_t krpc_encode_size_list_object(
  size_t * size, const krpc_list_object_t * value);
bool krpc_encode_callback_list_object(
  pb_ostream_t * stream, const pb_field_t * field, void * const * arg);
krpc_error_t krpc_decode_list_object(
  pb_istream_t * stream, krpc_list_object_t * value);

#endif  // KRPC_TYPE_LIST_OBJECT

#ifndef KRPC_TYPE_LIST_OBJECT
#define KRPC_TYPE_LIST_OBJECT

typedef struct krpc_list_object_s krpc_list_object_t;
struct krpc_list_object_s {
  size_t size;
  krpc_SpaceCenter_Antenna_t * items;
};

krpc_error_t krpc_encode_list_object(
  pb_ostream_t * stream, const krpc_list_object_t * value);
krpc_error_t krpc_encode_size_list_object(
  size_t * size, const krpc_list_object_t * value);
bool krpc_encode_callback_list_object(
  pb_ostream_t * stream, const pb_field_t * field, void * const * arg);
krpc_error_t krpc_decode_list_object(
  pb_istream_t * stream, krpc_list_object_t * value);

#endif  // KRPC_TYPE_LIST_OBJECT

#ifndef KRPC_TYPE_LIST_OBJECT
#define KRPC_TYPE_LIST_OBJECT

typedef struct krpc_list_object_s krpc_list_object_t;
struct krpc_list_object_s {
  size_t size;
  krpc_SpaceCenter_Vessel_t * items;
};

krpc_error_t krpc_encode_list_object(
  pb_ostream_t * stream, const krpc_list_object_t * value);
krpc_error_t krpc_encode_size_list_object(
  size_t * size, const krpc_list_object_t * value);
bool krpc_encode_callback_list_object(
  pb_ostream_t * stream, const pb_field_t * field, void * const * arg);
krpc_error_t krpc_decode_list_object(
  pb_istream_t * stream, krpc_list_object_t * value);

#endif  // KRPC_TYPE_LIST_OBJECT

#ifndef KRPC_TYPE_LIST_OBJECT
#define KRPC_TYPE_LIST_OBJECT

typedef struct krpc_list_object_s krpc_list_object_t;
struct krpc_list_object_s {
  size_t size;
  krpc_SpaceCenter_ResourceConverter_t * items;
};

krpc_error_t krpc_encode_list_object(
  pb_ostream_t * stream, const krpc_list_object_t * value);
krpc_error_t krpc_encode_size_list_object(
  size_t * size, const krpc_list_object_t * value);
bool krpc_encode_callback_list_object(
  pb_ostream_t * stream, const pb_field_t * field, void * const * arg);
krpc_error_t krpc_decode_list_object(
  pb_istream_t * stream, krpc_list_object_t * value);

#endif  // KRPC_TYPE_LIST_OBJECT

#ifndef KRPC_TYPE_LIST_OBJECT
#define KRPC_TYPE_LIST_OBJECT

typedef struct krpc_list_object_s krpc_list_object_t;
struct krpc_list_object_s {
  size_t size;
  krpc_SpaceCenter_LaunchClamp_t * items;
};

krpc_error_t krpc_encode_list_object(
  pb_ostream_t * stream, const krpc_list_object_t * value);
krpc_error_t krpc_encode_size_list_object(
  size_t * size, const krpc_list_object_t * value);
bool krpc_encode_callback_list_object(
  pb_ostream_t * stream, const pb_field_t * field, void * const * arg);
krpc_error_t krpc_decode_list_object(
  pb_istream_t * stream, krpc_list_object_t * value);

#endif  // KRPC_TYPE_LIST_OBJECT

#ifndef KRPC_TYPE_LIST_OBJECT
#define KRPC_TYPE_LIST_OBJECT

typedef struct krpc_list_object_s krpc_list_object_t;
struct krpc_list_object_s {
  size_t size;
  krpc_SpaceCenter_Experiment_t * items;
};

krpc_error_t krpc_encode_list_object(
  pb_ostream_t * stream, const krpc_list_object_t * value);
krpc_error_t krpc_encode_size_list_object(
  size_t * size, const krpc_list_object_t * value);
bool krpc_encode_callback_list_object(
  pb_ostream_t * stream, const pb_field_t * field, void * const * arg);
krpc_error_t krpc_decode_list_object(
  pb_istream_t * stream, krpc_list_object_t * value);

#endif  // KRPC_TYPE_LIST_OBJECT

#ifndef KRPC_TYPE_LIST_OBJECT
#define KRPC_TYPE_LIST_OBJECT

typedef struct krpc_list_object_s krpc_list_object_t;
struct krpc_list_object_s {
  size_t size;
  krpc_SpaceCenter_ResourceHarvester_t * items;
};

krpc_error_t krpc_encode_list_object(
  pb_ostream_t * stream, const krpc_list_object_t * value);
krpc_error_t krpc_encode_size_list_object(
  size_t * size, const krpc_list_object_t * value);
bool krpc_encode_callback_list_object(
  pb_ostream_t * stream, const pb_field_t * field, void * const * arg);
krpc_error_t krpc_decode_list_object(
  pb_istream_t * stream, krpc_list_object_t * value);

#endif  // KRPC_TYPE_LIST_OBJECT

#ifndef KRPC_TYPE_LIST_OBJECT
#define KRPC_TYPE_LIST_OBJECT

typedef struct krpc_list_object_s krpc_list_object_t;
struct krpc_list_object_s {
  size_t size;
  krpc_SpaceCenter_ScienceData_t * items;
};

krpc_error_t krpc_encode_list_object(
  pb_ostream_t * stream, const krpc_list_object_t * value);
krpc_error_t krpc_encode_size_list_object(
  size_t * size, const krpc_list_object_t * value);
bool krpc_encode_callback_list_object(
  pb_ostream_t * stream, const pb_field_t * field, void * const * arg);
krpc_error_t krpc_decode_list_object(
  pb_istream_t * stream, krpc_list_object_t * value);

#endif  // KRPC_TYPE_LIST_OBJECT

#ifndef KRPC_TYPE_LIST_OBJECT
#define KRPC_TYPE_LIST_OBJECT

typedef struct krpc_list_object_s krpc_list_object_t;
struct krpc_list_object_s {
  size_t size;
  krpc_SpaceCenter_Waypoint_t * items;
};

krpc_error_t krpc_encode_list_object(
  pb_ostream_t * stream, const krpc_list_object_t * value);
krpc_error_t krpc_encode_size_list_object(
  size_t * size, const krpc_list_object_t * value);
bool krpc_encode_callback_list_object(
  pb_ostream_t * stream, const pb_field_t * field, void * const * arg);
krpc_error_t krpc_decode_list_object(
  pb_istream_t * stream, krpc_list_object_t * value);

#endif  // KRPC_TYPE_LIST_OBJECT

/**
 * The state of an antenna. See SpaceCenter::Antenna::state.
 */
typedef enum {
  /**
   * Antenna is fully deployed.
   */
  KRPC_SPACECENTER_ANTENNASTATE_DEPLOYED = 0,
  /**
   * Antenna is fully retracted.
   */
  KRPC_SPACECENTER_ANTENNASTATE_RETRACTED = 1,
  /**
   * Antenna is being deployed.
   */
  KRPC_SPACECENTER_ANTENNASTATE_DEPLOYING = 2,
  /**
   * Antenna is being retracted.
   */
  KRPC_SPACECENTER_ANTENNASTATE_RETRACTING = 3,
  /**
   * Antenna is broken.
   */
  KRPC_SPACECENTER_ANTENNASTATE_BROKEN = 4
} krpc_SpaceCenter_AntennaState_t;

/**
 * See SpaceCenter::Camera::mode.
 */
typedef enum {
  /**
   * The camera is showing the active vessel, in "auto" mode.
   */
  KRPC_SPACECENTER_CAMERAMODE_AUTOMATIC = 0,
  /**
   * The camera is showing the active vessel, in "free" mode.
   */
  KRPC_SPACECENTER_CAMERAMODE_FREE = 1,
  /**
   * The camera is showing the active vessel, in "chase" mode.
   */
  KRPC_SPACECENTER_CAMERAMODE_CHASE = 2,
  /**
   * The camera is showing the active vessel, in "locked" mode.
   */
  KRPC_SPACECENTER_CAMERAMODE_LOCKED = 3,
  /**
   * The camera is showing the active vessel, in "orbital" mode.
   */
  KRPC_SPACECENTER_CAMERAMODE_ORBITAL = 4,
  /**
   * The Intra-Vehicular Activity view is being shown.
   */
  KRPC_SPACECENTER_CAMERAMODE_IVA = 5,
  /**
   * The map view is being shown.
   */
  KRPC_SPACECENTER_CAMERAMODE_MAP = 6
} krpc_SpaceCenter_CameraMode_t;

/**
 * The state of a cargo bay. See SpaceCenter::CargoBay::state.
 */
typedef enum {
  /**
   * Cargo bay is fully open.
   */
  KRPC_SPACECENTER_CARGOBAYSTATE_OPEN = 0,
  /**
   * Cargo bay closed and locked.
   */
  KRPC_SPACECENTER_CARGOBAYSTATE_CLOSED = 1,
  /**
   * Cargo bay is opening.
   */
  KRPC_SPACECENTER_CARGOBAYSTATE_OPENING = 2,
  /**
   * Cargo bay is closing.
   */
  KRPC_SPACECENTER_CARGOBAYSTATE_CLOSING = 3
} krpc_SpaceCenter_CargoBayState_t;

/**
 * The type of a communication link.
 * See SpaceCenter::CommLink::type.
 */
typedef enum {
  /**
   * Link is to a base station on Kerbin.
   */
  KRPC_SPACECENTER_COMMLINKTYPE_HOME = 0,
  /**
   * Link is to a control source, for example a manned spacecraft.
   */
  KRPC_SPACECENTER_COMMLINKTYPE_CONTROL = 1,
  /**
   * Link is to a relay satellite.
   */
  KRPC_SPACECENTER_COMMLINKTYPE_RELAY = 2
} krpc_SpaceCenter_CommLinkType_t;

/**
 * The state of a contract. See SpaceCenter::Contract::state.
 */
typedef enum {
  /**
   * The contract is active.
   */
  KRPC_SPACECENTER_CONTRACTSTATE_ACTIVE = 0,
  /**
   * The contract has been canceled.
   */
  KRPC_SPACECENTER_CONTRACTSTATE_CANCELED = 1,
  /**
   * The contract has been completed.
   */
  KRPC_SPACECENTER_CONTRACTSTATE_COMPLETED = 2,
  /**
   * The deadline for the contract has expired.
   */
  KRPC_SPACECENTER_CONTRACTSTATE_DEADLINEEXPIRED = 3,
  /**
   * The contract has been declined.
   */
  KRPC_SPACECENTER_CONTRACTSTATE_DECLINED = 4,
  /**
   * The contract has been failed.
   */
  KRPC_SPACECENTER_CONTRACTSTATE_FAILED = 5,
  /**
   * The contract has been generated.
   */
  KRPC_SPACECENTER_CONTRACTSTATE_GENERATED = 6,
  /**
   * The contract has been offered to the player.
   */
  KRPC_SPACECENTER_CONTRACTSTATE_OFFERED = 7,
  /**
   * The contract was offered to the player, but the offer expired.
   */
  KRPC_SPACECENTER_CONTRACTSTATE_OFFEREXPIRED = 8,
  /**
   * The contract has been withdrawn.
   */
  KRPC_SPACECENTER_CONTRACTSTATE_WITHDRAWN = 9
} krpc_SpaceCenter_ContractState_t;

/**
 * See SpaceCenter::Control::input_mode.
 */
typedef enum {
  /**
   * Control inputs are added to the vessels current control inputs.
   */
  KRPC_SPACECENTER_CONTROLINPUTMODE_ADDITIVE = 0,
  /**
   * Control inputs (when they are non-zero) override the vessels current control inputs.
   */
  KRPC_SPACECENTER_CONTROLINPUTMODE_OVERRIDE = 1
} krpc_SpaceCenter_ControlInputMode_t;

/**
 * The control source of a vessel.
 * See SpaceCenter::Control::source.
 */
typedef enum {
  /**
   * Vessel is controlled by a Kerbal.
   */
  KRPC_SPACECENTER_CONTROLSOURCE_KERBAL = 0,
  /**
   * Vessel is controlled by a probe core.
   */
  KRPC_SPACECENTER_CONTROLSOURCE_PROBE = 1,
  /**
   * Vessel is not controlled.
   */
  KRPC_SPACECENTER_CONTROLSOURCE_NONE = 2
} krpc_SpaceCenter_ControlSource_t;

/**
 * The control state of a vessel.
 * See SpaceCenter::Control::state.
 */
typedef enum {
  /**
   * Full controllable.
   */
  KRPC_SPACECENTER_CONTROLSTATE_FULL = 0,
  /**
   * Partially controllable.
   */
  KRPC_SPACECENTER_CONTROLSTATE_PARTIAL = 1,
  /**
   * Not controllable.
   */
  KRPC_SPACECENTER_CONTROLSTATE_NONE = 2
} krpc_SpaceCenter_ControlState_t;

/**
 * The type of a crew member.
 * See SpaceCenter::CrewMember::type.
 */
typedef enum {
  /**
   * An applicant for crew.
   */
  KRPC_SPACECENTER_CREWMEMBERTYPE_APPLICANT = 0,
  /**
   * Rocket crew.
   */
  KRPC_SPACECENTER_CREWMEMBERTYPE_CREW = 1,
  /**
   * A tourist.
   */
  KRPC_SPACECENTER_CREWMEMBERTYPE_TOURIST = 2,
  /**
   * An unowned crew member.
   */
  KRPC_SPACECENTER_CREWMEMBERTYPE_UNOWNED = 3
} krpc_SpaceCenter_CrewMemberType_t;

/**
 * The state of a docking port. See SpaceCenter::DockingPort::state.
 */
typedef enum {
  /**
   * The docking port is ready to dock to another docking port.
   */
  KRPC_SPACECENTER_DOCKINGPORTSTATE_READY = 0,
  /**
   * The docking port is docked to another docking port, or docked to
   * another part (from the VAB/SPH).
   */
  KRPC_SPACECENTER_DOCKINGPORTSTATE_DOCKED = 1,
  /**
   * The docking port is very close to another docking port,
   * but has not docked. It is using magnetic force to acquire a solid dock.
   */
  KRPC_SPACECENTER_DOCKINGPORTSTATE_DOCKING = 2,
  /**
   * The docking port has just been undocked from another docking port,
   * and is disabled until it moves away by a sufficient distance
   * (SpaceCenter::DockingPort::reengage_distance).
   */
  KRPC_SPACECENTER_DOCKINGPORTSTATE_UNDOCKING = 3,
  /**
   * The docking port has a shield, and the shield is closed.
   */
  KRPC_SPACECENTER_DOCKINGPORTSTATE_SHIELDED = 4,
  /**
   * The docking ports shield is currently opening/closing.
   */
  KRPC_SPACECENTER_DOCKINGPORTSTATE_MOVING = 5
} krpc_SpaceCenter_DockingPortState_t;

/**
 * The state of a landing leg. See SpaceCenter::Leg::state.
 */
typedef enum {
  /**
   * Landing leg is fully deployed.
   */
  KRPC_SPACECENTER_LEGSTATE_DEPLOYED = 0,
  /**
   * Landing leg is fully retracted.
   */
  KRPC_SPACECENTER_LEGSTATE_RETRACTED = 1,
  /**
   * Landing leg is being deployed.
   */
  KRPC_SPACECENTER_LEGSTATE_DEPLOYING = 2,
  /**
   * Landing leg is being retracted.
   */
  KRPC_SPACECENTER_LEGSTATE_RETRACTING = 3,
  /**
   * Landing leg is broken.
   */
  KRPC_SPACECENTER_LEGSTATE_BROKEN = 4
} krpc_SpaceCenter_LegState_t;

/**
 * The state of the motor on a powered wheel. See SpaceCenter::Wheel::motor_state.
 */
typedef enum {
  /**
   * The motor is idle.
   */
  KRPC_SPACECENTER_MOTORSTATE_IDLE = 0,
  /**
   * The motor is running.
   */
  KRPC_SPACECENTER_MOTORSTATE_RUNNING = 1,
  /**
   * The motor is disabled.
   */
  KRPC_SPACECENTER_MOTORSTATE_DISABLED = 2,
  /**
   * The motor is inoperable.
   */
  KRPC_SPACECENTER_MOTORSTATE_INOPERABLE = 3,
  /**
   * The motor does not have enough resources to run.
   */
  KRPC_SPACECENTER_MOTORSTATE_NOTENOUGHRESOURCES = 4
} krpc_SpaceCenter_MotorState_t;

/**
 * The state of a parachute. See SpaceCenter::Parachute::state.
 */
typedef enum {
  /**
   * The parachute is safely tucked away inside its housing.
   */
  KRPC_SPACECENTER_PARACHUTESTATE_STOWED = 0,
  /**
   * The parachute is armed for deployment. (RealChutes only)
   */
  KRPC_SPACECENTER_PARACHUTESTATE_ARMED = 1,
  /**
   * The parachute is still stowed, but ready to semi-deploy.
   * (Stock parachutes only)
   */
  KRPC_SPACECENTER_PARACHUTESTATE_ACTIVE = 2,
  /**
   * The parachute has been deployed and is providing some drag,
   * but is not fully deployed yet. (Stock parachutes only)
   */
  KRPC_SPACECENTER_PARACHUTESTATE_SEMIDEPLOYED = 3,
  /**
   * The parachute is fully deployed.
   */
  KRPC_SPACECENTER_PARACHUTESTATE_DEPLOYED = 4,
  /**
   * The parachute has been cut.
   */
  KRPC_SPACECENTER_PARACHUTESTATE_CUT = 5
} krpc_SpaceCenter_ParachuteState_t;

/**
 * The state of a radiator. SpaceCenter::RadiatorState
 */
typedef enum {
  /**
   * Radiator is fully extended.
   */
  KRPC_SPACECENTER_RADIATORSTATE_EXTENDED = 0,
  /**
   * Radiator is fully retracted.
   */
  KRPC_SPACECENTER_RADIATORSTATE_RETRACTED = 1,
  /**
   * Radiator is being extended.
   */
  KRPC_SPACECENTER_RADIATORSTATE_EXTENDING = 2,
  /**
   * Radiator is being retracted.
   */
  KRPC_SPACECENTER_RADIATORSTATE_RETRACTING = 3,
  /**
   * Radiator is being broken.
   */
  KRPC_SPACECENTER_RADIATORSTATE_BROKEN = 4
} krpc_SpaceCenter_RadiatorState_t;

/**
 * The state of a resource converter. See SpaceCenter::ResourceConverter::state.
 */
typedef enum {
  /**
   * Converter is running.
   */
  KRPC_SPACECENTER_RESOURCECONVERTERSTATE_RUNNING = 0,
  /**
   * Converter is idle.
   */
  KRPC_SPACECENTER_RESOURCECONVERTERSTATE_IDLE = 1,
  /**
   * Converter is missing a required resource.
   */
  KRPC_SPACECENTER_RESOURCECONVERTERSTATE_MISSINGRESOURCE = 2,
  /**
   * No available storage for output resource.
   */
  KRPC_SPACECENTER_RESOURCECONVERTERSTATE_STORAGEFULL = 3,
  /**
   * At preset resource capacity.
   */
  KRPC_SPACECENTER_RESOURCECONVERTERSTATE_CAPACITY = 4,
  /**
   * Unknown state. Possible with modified resource converters.
   * In this case, check SpaceCenter::ResourceConverter::status_info for more information.
   */
  KRPC_SPACECENTER_RESOURCECONVERTERSTATE_UNKNOWN = 5
} krpc_SpaceCenter_ResourceConverterState_t;

/**
 * The way in which a resource flows between parts. See SpaceCenter::Resources::flow_mode.
 */
typedef enum {
  /**
   * The resource flows to any part in the vessel. For example, electric charge.
   */
  KRPC_SPACECENTER_RESOURCEFLOWMODE_VESSEL = 0,
  /**
   * The resource flows from parts in the first stage, followed by the second,
   * and so on. For example, mono-propellant.
   */
  KRPC_SPACECENTER_RESOURCEFLOWMODE_STAGE = 1,
  /**
   * The resource flows between adjacent parts within the vessel. For example,
   * liquid fuel or oxidizer.
   */
  KRPC_SPACECENTER_RESOURCEFLOWMODE_ADJACENT = 2,
  /**
   * The resource does not flow. For example, solid fuel.
   */
  KRPC_SPACECENTER_RESOURCEFLOWMODE_NONE = 3
} krpc_SpaceCenter_ResourceFlowMode_t;

/**
 * The state of a resource harvester. See SpaceCenter::ResourceHarvester::state.
 */
typedef enum {
  /**
   * The drill is deploying.
   */
  KRPC_SPACECENTER_RESOURCEHARVESTERSTATE_DEPLOYING = 0,
  /**
   * The drill is deployed and ready.
   */
  KRPC_SPACECENTER_RESOURCEHARVESTERSTATE_DEPLOYED = 1,
  /**
   * The drill is retracting.
   */
  KRPC_SPACECENTER_RESOURCEHARVESTERSTATE_RETRACTING = 2,
  /**
   * The drill is retracted.
   */
  KRPC_SPACECENTER_RESOURCEHARVESTERSTATE_RETRACTED = 3,
  /**
   * The drill is running.
   */
  KRPC_SPACECENTER_RESOURCEHARVESTERSTATE_ACTIVE = 4
} krpc_SpaceCenter_ResourceHarvesterState_t;

/**
 * The behavior of the SAS auto-pilot. See SpaceCenter::AutoPilot::sas_mode.
 */
typedef enum {
  /**
   * Stability assist mode. Dampen out any rotation.
   */
  KRPC_SPACECENTER_SASMODE_STABILITYASSIST = 0,
  /**
   * Point in the burn direction of the next maneuver node.
   */
  KRPC_SPACECENTER_SASMODE_MANEUVER = 1,
  /**
   * Point in the prograde direction.
   */
  KRPC_SPACECENTER_SASMODE_PROGRADE = 2,
  /**
   * Point in the retrograde direction.
   */
  KRPC_SPACECENTER_SASMODE_RETROGRADE = 3,
  /**
   * Point in the orbit normal direction.
   */
  KRPC_SPACECENTER_SASMODE_NORMAL = 4,
  /**
   * Point in the orbit anti-normal direction.
   */
  KRPC_SPACECENTER_SASMODE_ANTINORMAL = 5,
  /**
   * Point in the orbit radial direction.
   */
  KRPC_SPACECENTER_SASMODE_RADIAL = 6,
  /**
   * Point in the orbit anti-radial direction.
   */
  KRPC_SPACECENTER_SASMODE_ANTIRADIAL = 7,
  /**
   * Point in the direction of the current target.
   */
  KRPC_SPACECENTER_SASMODE_TARGET = 8,
  /**
   * Point away from the current target.
   */
  KRPC_SPACECENTER_SASMODE_ANTITARGET = 9
} krpc_SpaceCenter_SASMode_t;

/**
 * The state of a solar panel. See SpaceCenter::SolarPanel::state.
 */
typedef enum {
  /**
   * Solar panel is fully extended.
   */
  KRPC_SPACECENTER_SOLARPANELSTATE_EXTENDED = 0,
  /**
   * Solar panel is fully retracted.
   */
  KRPC_SPACECENTER_SOLARPANELSTATE_RETRACTED = 1,
  /**
   * Solar panel is being extended.
   */
  KRPC_SPACECENTER_SOLARPANELSTATE_EXTENDING = 2,
  /**
   * Solar panel is being retracted.
   */
  KRPC_SPACECENTER_SOLARPANELSTATE_RETRACTING = 3,
  /**
   * Solar panel is broken.
   */
  KRPC_SPACECENTER_SOLARPANELSTATE_BROKEN = 4
} krpc_SpaceCenter_SolarPanelState_t;

/**
 * The mode of the speed reported in the navball.
 * See SpaceCenter::Control::speed_mode.
 */
typedef enum {
  /**
   * Speed is relative to the vessel's orbit.
   */
  KRPC_SPACECENTER_SPEEDMODE_ORBIT = 0,
  /**
   * Speed is relative to the surface of the body being orbited.
   */
  KRPC_SPACECENTER_SPEEDMODE_SURFACE = 1,
  /**
   * Speed is relative to the current target.
   */
  KRPC_SPACECENTER_SPEEDMODE_TARGET = 2
} krpc_SpaceCenter_SpeedMode_t;

/**
 * The situation a vessel is in.
 * See SpaceCenter::Vessel::situation.
 */
typedef enum {
  /**
   * Vessel is awaiting launch.
   */
  KRPC_SPACECENTER_VESSELSITUATION_PRELAUNCH = 0,
  /**
   * Vessel is orbiting a body.
   */
  KRPC_SPACECENTER_VESSELSITUATION_ORBITING = 1,
  /**
   * Vessel is on a sub-orbital trajectory.
   */
  KRPC_SPACECENTER_VESSELSITUATION_SUBORBITAL = 2,
  /**
   * Escaping.
   */
  KRPC_SPACECENTER_VESSELSITUATION_ESCAPING = 3,
  /**
   * Vessel is flying through an atmosphere.
   */
  KRPC_SPACECENTER_VESSELSITUATION_FLYING = 4,
  /**
   * Vessel is landed on the surface of a body.
   */
  KRPC_SPACECENTER_VESSELSITUATION_LANDED = 5,
  /**
   * Vessel has splashed down in an ocean.
   */
  KRPC_SPACECENTER_VESSELSITUATION_SPLASHED = 6,
  /**
   * Vessel is docked to another.
   */
  KRPC_SPACECENTER_VESSELSITUATION_DOCKED = 7
} krpc_SpaceCenter_VesselSituation_t;

/**
 * The type of a vessel.
 * See SpaceCenter::Vessel::type.
 */
typedef enum {
  /**
   * Base.
   */
  KRPC_SPACECENTER_VESSELTYPE_BASE = 0,
  /**
   * Debris.
   */
  KRPC_SPACECENTER_VESSELTYPE_DEBRIS = 1,
  /**
   * Lander.
   */
  KRPC_SPACECENTER_VESSELTYPE_LANDER = 2,
  /**
   * Plane.
   */
  KRPC_SPACECENTER_VESSELTYPE_PLANE = 3,
  /**
   * Probe.
   */
  KRPC_SPACECENTER_VESSELTYPE_PROBE = 4,
  /**
   * Relay.
   */
  KRPC_SPACECENTER_VESSELTYPE_RELAY = 5,
  /**
   * Rover.
   */
  KRPC_SPACECENTER_VESSELTYPE_ROVER = 6,
  /**
   * Ship.
   */
  KRPC_SPACECENTER_VESSELTYPE_SHIP = 7,
  /**
   * Station.
   */
  KRPC_SPACECENTER_VESSELTYPE_STATION = 8
} krpc_SpaceCenter_VesselType_t;

/**
 * The time warp mode.
 * Returned by SpaceCenter::WarpMode
 */
typedef enum {
  /**
   * Time warp is active, and in regular "on-rails" mode.
   */
  KRPC_SPACECENTER_WARPMODE_RAILS = 0,
  /**
   * Time warp is active, and in physical time warp mode.
   */
  KRPC_SPACECENTER_WARPMODE_PHYSICS = 1,
  /**
   * Time warp is not active.
   */
  KRPC_SPACECENTER_WARPMODE_NONE = 2
} krpc_SpaceCenter_WarpMode_t;

/**
 * The state of a wheel. See SpaceCenter::Wheel::state.
 */
typedef enum {
  /**
   * Wheel is fully deployed.
   */
  KRPC_SPACECENTER_WHEELSTATE_DEPLOYED = 0,
  /**
   * Wheel is fully retracted.
   */
  KRPC_SPACECENTER_WHEELSTATE_RETRACTED = 1,
  /**
   * Wheel is being deployed.
   */
  KRPC_SPACECENTER_WHEELSTATE_DEPLOYING = 2,
  /**
   * Wheel is being retracted.
   */
  KRPC_SPACECENTER_WHEELSTATE_RETRACTING = 3,
  /**
   * Wheel is broken.
   */
  KRPC_SPACECENTER_WHEELSTATE_BROKEN = 4
} krpc_SpaceCenter_WheelState_t;

/**
 * Returns true if regular "on-rails" time warp can be used, at the specified warp
 * factor. The maximum time warp rate is limited by various things,
 * including how close the active vessel is to a planet. See
 * <a href="https://wiki.kerbalspaceprogram.com/wiki/Time_warp">the KSP wiki</a>
 * for details.
 * @param factor The warp factor to check.
 */
krpc_error_t krpc_SpaceCenter_CanRailsWarpAt(krpc_connection_t connection, bool * returnValue, int32_t factor);

/**
 * Clears the current target.
 */
krpc_error_t krpc_SpaceCenter_ClearTarget(krpc_connection_t connection);

/**
 * Launch a vessel.
 * @param craftDirectory Name of the directory in the current saves
 * "Ships" directory, that contains the craft file.
 * For example "VAB" or "SPH".
 * @param name Name of the vessel to launch. This is the name of the ".craft" file
 * in the save directory, without the ".craft" file extension.
 * @param launchSite Name of the launch site. For example "LaunchPad" or
 * "Runway".
 */
krpc_error_t krpc_SpaceCenter_LaunchVessel(krpc_connection_t connection, const char * craftDirectory, const char * name, const char * launchSite);

/**
 * Launch a new vessel from the SPH onto the runway.
 * @param name Name of the vessel to launch.
 *
 * This is equivalent to calling SpaceCenter::launch_vessel with the craft directory
 * set to "SPH" and the launch site set to "Runway".
 */
krpc_error_t krpc_SpaceCenter_LaunchVesselFromSPH(krpc_connection_t connection, const char * name);

/**
 * Launch a new vessel from the VAB onto the launchpad.
 * @param name Name of the vessel to launch.
 *
 * This is equivalent to calling SpaceCenter::launch_vessel with the craft directory
 * set to "VAB" and the launch site set to "LaunchPad".
 */
krpc_error_t krpc_SpaceCenter_LaunchVesselFromVAB(krpc_connection_t connection, const char * name);

/**
 * Returns a list of vessels from the given craftDirectory
 * that can be launched.
 * @param craftDirectory Name of the directory in the current saves
 * "Ships" directory. For example "VAB" or "SPH".
 */
krpc_error_t krpc_SpaceCenter_LaunchableVessels(krpc_connection_t connection, krpc_list_string_t * returnValue, const char * craftDirectory);

/**
 * Load the game with the given name.
 * This will create a load a save file called name.sfs from the folder of the
 * current save game.
 */
krpc_error_t krpc_SpaceCenter_Load(krpc_connection_t connection, const char * name);

/**
 * Load a quicksave.
 *
 * This is the same as calling SpaceCenter::load with the name "quicksave".
 */
krpc_error_t krpc_SpaceCenter_Quickload(krpc_connection_t connection);

/**
 * Save a quicksave.
 *
 * This is the same as calling SpaceCenter::save with the name "quicksave".
 */
krpc_error_t krpc_SpaceCenter_Quicksave(krpc_connection_t connection);

/**
 * Cast a ray from a given position in a given direction, and return the distance to the hit point.
 * If no hit occurs, returns infinity.
 * @param position Position, as a vector, of the origin of the ray.
 * @param direction Direction of the ray, as a unit vector.
 * @param referenceFrame The reference frame that the position and direction are in.
 * @return The distance to the hit, in meters, or infinity if there was no hit.
 */
krpc_error_t krpc_SpaceCenter_RaycastDistance(krpc_connection_t connection, double * returnValue, const krpc_tuple_double_double_double_t * position, const krpc_tuple_double_double_double_t * direction, krpc_SpaceCenter_ReferenceFrame_t referenceFrame);

/**
 * Cast a ray from a given position in a given direction, and return the part that it hits.
 * If no hit occurs, returns null.
 * @param position Position, as a vector, of the origin of the ray.
 * @param direction Direction of the ray, as a unit vector.
 * @param referenceFrame The reference frame that the position and direction are in.
 * @return The part that was hit or null if there was no hit.
 */
krpc_error_t krpc_SpaceCenter_RaycastPart(krpc_connection_t connection, krpc_SpaceCenter_Part_t * returnValue, const krpc_tuple_double_double_double_t * position, const krpc_tuple_double_double_double_t * direction, krpc_SpaceCenter_ReferenceFrame_t referenceFrame);

/**
 * Save the game with a given name.
 * This will create a save file called name.sfs in the folder of the
 * current save game.
 */
krpc_error_t krpc_SpaceCenter_Save(krpc_connection_t connection, const char * name);

/**
 * Converts a direction from one reference frame to another.
 * @param direction Direction, as a vector, in reference frame
 * from.
 * @param from The reference frame that the direction is in.
 * @param to The reference frame to covert the direction to.
 * @return The corresponding direction, as a vector, in reference frame
 * to.
 */
krpc_error_t krpc_SpaceCenter_TransformDirection(krpc_connection_t connection, krpc_tuple_double_double_double_t * returnValue, const krpc_tuple_double_double_double_t * direction, krpc_SpaceCenter_ReferenceFrame_t from, krpc_SpaceCenter_ReferenceFrame_t to);

/**
 * Converts a position from one reference frame to another.
 * @param position Position, as a vector, in reference frame
 * from.
 * @param from The reference frame that the position is in.
 * @param to The reference frame to covert the position to.
 * @return The corresponding position, as a vector, in reference frame
 * to.
 */
krpc_error_t krpc_SpaceCenter_TransformPosition(krpc_connection_t connection, krpc_tuple_double_double_double_t * returnValue, const krpc_tuple_double_double_double_t * position, krpc_SpaceCenter_ReferenceFrame_t from, krpc_SpaceCenter_ReferenceFrame_t to);

/**
 * Converts a rotation from one reference frame to another.
 * @param rotation Rotation, as a quaternion of the form (x, y, z, w),
 * in reference frame from.
 * @param from The reference frame that the rotation is in.
 * @param to The reference frame to covert the rotation to.
 * @return The corresponding rotation, as a quaternion of the form
 * (x, y, z, w), in reference frame to.
 */
krpc_error_t krpc_SpaceCenter_TransformRotation(krpc_connection_t connection, krpc_tuple_double_double_double_double_t * returnValue, const krpc_tuple_double_double_double_double_t * rotation, krpc_SpaceCenter_ReferenceFrame_t from, krpc_SpaceCenter_ReferenceFrame_t to);

/**
 * Converts a velocity (acting at the specified position) from one reference frame
 * to another. The position is required to take the relative angular velocity of the
 * reference frames into account.
 * @param position Position, as a vector, in reference frame
 * from.
 * @param velocity Velocity, as a vector that points in the direction of travel and
 * whose magnitude is the speed in meters per second, in reference frame
 * from.
 * @param from The reference frame that the position and velocity are in.
 * @param to The reference frame to covert the velocity to.
 * @return The corresponding velocity, as a vector, in reference frame
 * to.
 */
krpc_error_t krpc_SpaceCenter_TransformVelocity(krpc_connection_t connection, krpc_tuple_double_double_double_t * returnValue, const krpc_tuple_double_double_double_t * position, const krpc_tuple_double_double_double_t * velocity, krpc_SpaceCenter_ReferenceFrame_t from, krpc_SpaceCenter_ReferenceFrame_t to);

/**
 * Uses time acceleration to warp forward to a time in the future, specified
 * by universal time ut. This call blocks until the desired
 * time is reached. Uses regular "on-rails" or physical time warp as appropriate.
 * For example, physical time warp is used when the active vessel is traveling
 * through an atmosphere. When using regular "on-rails" time warp, the warp
 * rate is limited by maxRailsRate, and when using physical
 * time warp, the warp rate is limited by maxPhysicsRate.
 * @param ut The universal time to warp to, in seconds.
 * @param maxRailsRate The maximum warp rate in regular "on-rails" time warp.
 * @param maxPhysicsRate The maximum warp rate in physical time warp.
 * @return When the time warp is complete.
 */
krpc_error_t krpc_SpaceCenter_WarpTo(krpc_connection_t connection, double ut, float maxRailsRate, float maxPhysicsRate);

/**
 * The current warp factor. This is the index of the rate at which time
 * is passing for either regular "on-rails" or physical time warp. Returns 0
 * if time warp is not active. When in on-rails time warp, this is equal to
 * SpaceCenter::rails_warp_factor, and in physics time warp, this is equal to
 * SpaceCenter::physics_warp_factor.
 */
krpc_error_t krpc_SpaceCenter_WarpFactor(krpc_connection_t connection, float * returnValue);

/**
 * A list of all the vessels in the game.
 */
krpc_error_t krpc_SpaceCenter_Vessels(krpc_connection_t connection, krpc_list_object_t * returnValue);

/**
 * An object that can be used to control the camera.
 */
krpc_error_t krpc_SpaceCenter_Camera(krpc_connection_t connection, krpc_SpaceCenter_Camera_t * returnValue);

/**
 * The current maximum regular "on-rails" warp factor that can be set.
 * A value between 0 and 7 inclusive. See
 * <a href="https://wiki.kerbalspaceprogram.com/wiki/Time_warp">the KSP wiki</a>
 * for details.
 */
krpc_error_t krpc_SpaceCenter_MaximumRailsWarpFactor(krpc_connection_t connection, int32_t * returnValue);

/**
 * The currently targeted vessel.
 */
krpc_error_t krpc_SpaceCenter_set_TargetVessel(krpc_connection_t connection, krpc_SpaceCenter_Vessel_t value);

/**
 * Whether the navball is visible.
 */
krpc_error_t krpc_SpaceCenter_Navball(krpc_connection_t connection, bool * returnValue);

/**
 * Whether the UI is visible.
 */
krpc_error_t krpc_SpaceCenter_set_UIVisible(krpc_connection_t connection, bool value);

/**
 * The value of the <a href="https://en.wikipedia.org/wiki/Gravitational_constant">
 * gravitational constant</a> G in N(m/kg)^2.
 */
krpc_error_t krpc_SpaceCenter_G(krpc_connection_t connection, double * returnValue);

/**
 * The currently targeted vessel.
 */
krpc_error_t krpc_SpaceCenter_TargetVessel(krpc_connection_t connection, krpc_SpaceCenter_Vessel_t * returnValue);

/**
 * The currently targeted celestial body.
 */
krpc_error_t krpc_SpaceCenter_set_TargetBody(krpc_connection_t connection, krpc_SpaceCenter_CelestialBody_t value);

/**
 * The waypoint manager.
 */
krpc_error_t krpc_SpaceCenter_WaypointManager(krpc_connection_t connection, krpc_SpaceCenter_WaypointManager_t * returnValue);

/**
 * The time warp rate, using regular "on-rails" time warp. A value between
 * 0 and 7 inclusive. 0 means no time warp. Returns 0 if physical time warp
 * is active.
 *
 * If requested time warp factor cannot be set, it will be set to the next
 * lowest possible value. For example, if the vessel is too close to a
 * planet. See <a href="https://wiki.kerbalspaceprogram.com/wiki/Time_warp">
 * the KSP wiki</a> for details.
 */
krpc_error_t krpc_SpaceCenter_RailsWarpFactor(krpc_connection_t connection, int32_t * returnValue);

/**
 * The current time warp mode. Returns SpaceCenter::WarpMode::none if time
 * warp is not active, SpaceCenter::WarpMode::rails if regular "on-rails" time warp
 * is active, or SpaceCenter::WarpMode::physics if physical time warp is active.
 */
krpc_error_t krpc_SpaceCenter_WarpMode(krpc_connection_t connection, krpc_SpaceCenter_WarpMode_t * returnValue);

/**
 * The time warp rate, using regular "on-rails" time warp. A value between
 * 0 and 7 inclusive. 0 means no time warp. Returns 0 if physical time warp
 * is active.
 *
 * If requested time warp factor cannot be set, it will be set to the next
 * lowest possible value. For example, if the vessel is too close to a
 * planet. See <a href="https://wiki.kerbalspaceprogram.com/wiki/Time_warp">
 * the KSP wiki</a> for details.
 */
krpc_error_t krpc_SpaceCenter_set_RailsWarpFactor(krpc_connection_t connection, int32_t value);

/**
 * The physical time warp rate. A value between 0 and 3 inclusive. 0 means
 * no time warp. Returns 0 if regular "on-rails" time warp is active.
 */
krpc_error_t krpc_SpaceCenter_set_PhysicsWarpFactor(krpc_connection_t connection, int32_t value);

/**
 * The currently targeted celestial body.
 */
krpc_error_t krpc_SpaceCenter_TargetBody(krpc_connection_t connection, krpc_SpaceCenter_CelestialBody_t * returnValue);

/**
 * A dictionary of all celestial bodies (planets, moons, etc.) in the game,
 * keyed by the name of the body.
 */
krpc_error_t krpc_SpaceCenter_Bodies(krpc_connection_t connection, krpc_dictionary_string_object_t * returnValue);

/**
 * Whether the navball is visible.
 */
krpc_error_t krpc_SpaceCenter_set_Navball(krpc_connection_t connection, bool value);

/**
 * The currently active vessel.
 */
krpc_error_t krpc_SpaceCenter_ActiveVessel(krpc_connection_t connection, krpc_SpaceCenter_Vessel_t * returnValue);

/**
 * Whether the UI is visible.
 */
krpc_error_t krpc_SpaceCenter_UIVisible(krpc_connection_t connection, bool * returnValue);

/**
 * Whether <a href="https://forum.kerbalspaceprogram.com/index.php?/topic/19321-130-ferram-aerospace-research-v0159-liebe-82117/">Ferram Aerospace Research</a> is installed.
 */
krpc_error_t krpc_SpaceCenter_FARAvailable(krpc_connection_t connection, bool * returnValue);

/**
 * The current universal time in seconds.
 */
krpc_error_t krpc_SpaceCenter_UT(krpc_connection_t connection, double * returnValue);

/**
 * The contract manager.
 */
krpc_error_t krpc_SpaceCenter_ContractManager(krpc_connection_t connection, krpc_SpaceCenter_ContractManager_t * returnValue);

/**
 * The currently targeted docking port.
 */
krpc_error_t krpc_SpaceCenter_TargetDockingPort(krpc_connection_t connection, krpc_SpaceCenter_DockingPort_t * returnValue);

/**
 * The currently active vessel.
 */
krpc_error_t krpc_SpaceCenter_set_ActiveVessel(krpc_connection_t connection, krpc_SpaceCenter_Vessel_t value);

/**
 * The physical time warp rate. A value between 0 and 3 inclusive. 0 means
 * no time warp. Returns 0 if regular "on-rails" time warp is active.
 */
krpc_error_t krpc_SpaceCenter_PhysicsWarpFactor(krpc_connection_t connection, int32_t * returnValue);

/**
 * The currently targeted docking port.
 */
krpc_error_t krpc_SpaceCenter_set_TargetDockingPort(krpc_connection_t connection, krpc_SpaceCenter_DockingPort_t value);

/**
 * The current warp rate. This is the rate at which time is passing for
 * either on-rails or physical time warp. For example, a value of 10 means
 * time is passing 10x faster than normal. Returns 1 if time warp is not
 * active.
 */
krpc_error_t krpc_SpaceCenter_WarpRate(krpc_connection_t connection, float * returnValue);

/**
 * Cancel current transmission of data.
 */
krpc_error_t krpc_SpaceCenter_Antenna_Cancel(krpc_connection_t connection, krpc_SpaceCenter_Antenna_t instance);

/**
 * Transmit data.
 */
krpc_error_t krpc_SpaceCenter_Antenna_Transmit(krpc_connection_t connection, krpc_SpaceCenter_Antenna_t instance);

/**
 * Whether data can be transmitted by this antenna.
 */
krpc_error_t krpc_SpaceCenter_Antenna_CanTransmit(krpc_connection_t connection, bool * returnValue, krpc_SpaceCenter_Antenna_t instance);

/**
 * Whether the antenna can be combined with other antennae on the vessel
 * to boost the power.
 */
krpc_error_t krpc_SpaceCenter_Antenna_Combinable(krpc_connection_t connection, bool * returnValue, krpc_SpaceCenter_Antenna_t instance);

/**
 * The power of the antenna.
 */
krpc_error_t krpc_SpaceCenter_Antenna_Power(krpc_connection_t connection, double * returnValue, krpc_SpaceCenter_Antenna_t instance);

/**
 * Whether the antenna is deployed.
 *
 * Fixed antennas are always deployed.
 * Returns an error if you try to deploy a fixed antenna.
 */
krpc_error_t krpc_SpaceCenter_Antenna_set_Deployed(krpc_connection_t connection, krpc_SpaceCenter_Antenna_t instance, bool value);

/**
 * Whether partial data transmission is permitted.
 */
krpc_error_t krpc_SpaceCenter_Antenna_set_AllowPartial(krpc_connection_t connection, krpc_SpaceCenter_Antenna_t instance, bool value);

/**
 * Exponent used to calculate the combined power of multiple antennae on a vessel.
 */
krpc_error_t krpc_SpaceCenter_Antenna_CombinableExponent(krpc_connection_t connection, double * returnValue, krpc_SpaceCenter_Antenna_t instance);

/**
 * Whether partial data transmission is permitted.
 */
krpc_error_t krpc_SpaceCenter_Antenna_AllowPartial(krpc_connection_t connection, bool * returnValue, krpc_SpaceCenter_Antenna_t instance);

/**
 * Whether the antenna is deployable.
 */
krpc_error_t krpc_SpaceCenter_Antenna_Deployable(krpc_connection_t connection, bool * returnValue, krpc_SpaceCenter_Antenna_t instance);

/**
 * The current state of the antenna.
 */
krpc_error_t krpc_SpaceCenter_Antenna_State(krpc_connection_t connection, krpc_SpaceCenter_AntennaState_t * returnValue, krpc_SpaceCenter_Antenna_t instance);

/**
 * The part object for this antenna.
 */
krpc_error_t krpc_SpaceCenter_Antenna_Part(krpc_connection_t connection, krpc_SpaceCenter_Part_t * returnValue, krpc_SpaceCenter_Antenna_t instance);

/**
 * Interval between sending packets in seconds.
 */
krpc_error_t krpc_SpaceCenter_Antenna_PacketInterval(krpc_connection_t connection, float * returnValue, krpc_SpaceCenter_Antenna_t instance);

/**
 * Amount of data sent per packet in Mits.
 */
krpc_error_t krpc_SpaceCenter_Antenna_PacketSize(krpc_connection_t connection, float * returnValue, krpc_SpaceCenter_Antenna_t instance);

/**
 * Units of electric charge consumed per packet sent.
 */
krpc_error_t krpc_SpaceCenter_Antenna_PacketResourceCost(krpc_connection_t connection, double * returnValue, krpc_SpaceCenter_Antenna_t instance);

/**
 * Whether the antenna is deployed.
 *
 * Fixed antennas are always deployed.
 * Returns an error if you try to deploy a fixed antenna.
 */
krpc_error_t krpc_SpaceCenter_Antenna_Deployed(krpc_connection_t connection, bool * returnValue, krpc_SpaceCenter_Antenna_t instance);

/**
 * Disengage the auto-pilot.
 */
krpc_error_t krpc_SpaceCenter_AutoPilot_Disengage(krpc_connection_t connection, krpc_SpaceCenter_AutoPilot_t instance);

/**
 * Engage the auto-pilot.
 */
krpc_error_t krpc_SpaceCenter_AutoPilot_Engage(krpc_connection_t connection, krpc_SpaceCenter_AutoPilot_t instance);

/**
 * Set target pitch and heading angles.
 * @param pitch Target pitch angle, in degrees between -90° and +90°.
 * @param heading Target heading angle, in degrees between 0° and 360°.
 */
krpc_error_t krpc_SpaceCenter_AutoPilot_TargetPitchAndHeading(krpc_connection_t connection, krpc_SpaceCenter_AutoPilot_t instance, float pitch, float heading);

/**
 * Blocks until the vessel is pointing in the target direction and has
 * the target roll (if set). Throws an exception if the auto-pilot has not been engaged.
 */
krpc_error_t krpc_SpaceCenter_AutoPilot_Wait(krpc_connection_t connection, krpc_SpaceCenter_AutoPilot_t instance);

/**
 * Gains for the pitch PID controller.
 *
 * When SpaceCenter::AutoPilot::auto_tune is true, these values are updated automatically,
 * which will overwrite any manual changes.
 */
krpc_error_t krpc_SpaceCenter_AutoPilot_set_PitchPIDGains(krpc_connection_t connection, krpc_SpaceCenter_AutoPilot_t instance, const krpc_tuple_double_double_double_t * value);

/**
 * Whether the rotation rate controllers PID parameters should be automatically tuned
 * using the vessels moment of inertia and available torque. Defaults to true.
 * See SpaceCenter::AutoPilot::time_to_peak and SpaceCenter::AutoPilot::overshoot.
 */
krpc_error_t krpc_SpaceCenter_AutoPilot_set_AutoTune(krpc_connection_t connection, krpc_SpaceCenter_AutoPilot_t instance, bool value);

/**
 * Direction vector corresponding to the target pitch and heading.
 * This is in the reference frame specified by SpaceCenter::ReferenceFrame.
 */
krpc_error_t krpc_SpaceCenter_AutoPilot_TargetDirection(krpc_connection_t connection, krpc_tuple_double_double_double_t * returnValue, krpc_SpaceCenter_AutoPilot_t instance);

/**
 * The angle at which the autopilot considers the vessel to be pointing
 * close to the target.
 * This determines the midpoint of the target velocity attenuation function.
 * A vector of three angles, in degrees, one for each of the pitch, roll and yaw axes.
 * Defaults to 1° for each axis.
 */
krpc_error_t krpc_SpaceCenter_AutoPilot_set_AttenuationAngle(krpc_connection_t connection, krpc_SpaceCenter_AutoPilot_t instance, const krpc_tuple_double_double_double_t * value);

/**
 * The maximum amount of time that the vessel should need to come to a complete stop.
 * This determines the maximum angular velocity of the vessel.
 * A vector of three stopping times, in seconds, one for each of the pitch, roll
 * and yaw axes. Defaults to 0.5 seconds for each axis.
 */
krpc_error_t krpc_SpaceCenter_AutoPilot_set_StoppingTime(krpc_connection_t connection, krpc_SpaceCenter_AutoPilot_t instance, const krpc_tuple_double_double_double_t * value);

/**
 * The maximum amount of time that the vessel should need to come to a complete stop.
 * This determines the maximum angular velocity of the vessel.
 * A vector of three stopping times, in seconds, one for each of the pitch, roll
 * and yaw axes. Defaults to 0.5 seconds for each axis.
 */
krpc_error_t krpc_SpaceCenter_AutoPilot_StoppingTime(krpc_connection_t connection, krpc_tuple_double_double_double_t * returnValue, krpc_SpaceCenter_AutoPilot_t instance);

/**
 * The reference frame for the target direction (SpaceCenter::AutoPilot::target_direction).
 *
 * An error will be thrown if this property is set to a reference frame that rotates with
 * the vessel being controlled, as it is impossible to rotate the vessel in such a
 * reference frame.
 */
krpc_error_t krpc_SpaceCenter_AutoPilot_set_ReferenceFrame(krpc_connection_t connection, krpc_SpaceCenter_AutoPilot_t instance, krpc_SpaceCenter_ReferenceFrame_t value);

/**
 * The error, in degrees, between the vessels current and target heading.
 * Throws an exception if the auto-pilot has not been engaged.
 */
krpc_error_t krpc_SpaceCenter_AutoPilot_HeadingError(krpc_connection_t connection, float * returnValue, krpc_SpaceCenter_AutoPilot_t instance);

/**
 * The target heading, in degrees, between 0° and 360°.
 */
krpc_error_t krpc_SpaceCenter_AutoPilot_TargetHeading(krpc_connection_t connection, float * returnValue, krpc_SpaceCenter_AutoPilot_t instance);

/**
 * The target roll, in degrees. NaN if no target roll is set.
 */
krpc_error_t krpc_SpaceCenter_AutoPilot_set_TargetRoll(krpc_connection_t connection, krpc_SpaceCenter_AutoPilot_t instance, float value);

/**
 * The reference frame for the target direction (SpaceCenter::AutoPilot::target_direction).
 *
 * An error will be thrown if this property is set to a reference frame that rotates with
 * the vessel being controlled, as it is impossible to rotate the vessel in such a
 * reference frame.
 */
krpc_error_t krpc_SpaceCenter_AutoPilot_ReferenceFrame(krpc_connection_t connection, krpc_SpaceCenter_ReferenceFrame_t * returnValue, krpc_SpaceCenter_AutoPilot_t instance);

/**
 * The threshold at which the autopilot will try to match the target roll angle, if any.
 * Defaults to 5 degrees.
 */
krpc_error_t krpc_SpaceCenter_AutoPilot_RollThreshold(krpc_connection_t connection, double * returnValue, krpc_SpaceCenter_AutoPilot_t instance);

/**
 * Gains for the roll PID controller.
 *
 * When SpaceCenter::AutoPilot::auto_tune is true, these values are updated automatically,
 * which will overwrite any manual changes.
 */
krpc_error_t krpc_SpaceCenter_AutoPilot_set_RollPIDGains(krpc_connection_t connection, krpc_SpaceCenter_AutoPilot_t instance, const krpc_tuple_double_double_double_t * value);

/**
 * Whether the rotation rate controllers PID parameters should be automatically tuned
 * using the vessels moment of inertia and available torque. Defaults to true.
 * See SpaceCenter::AutoPilot::time_to_peak and SpaceCenter::AutoPilot::overshoot.
 */
krpc_error_t krpc_SpaceCenter_AutoPilot_AutoTune(krpc_connection_t connection, bool * returnValue, krpc_SpaceCenter_AutoPilot_t instance);

/**
 * The state of SAS.
 *
 * Equivalent to SpaceCenter::Control::sas
 */
krpc_error_t krpc_SpaceCenter_AutoPilot_SAS(krpc_connection_t connection, bool * returnValue, krpc_SpaceCenter_AutoPilot_t instance);

/**
 * The error, in degrees, between the vessels current and target pitch.
 * Throws an exception if the auto-pilot has not been engaged.
 */
krpc_error_t krpc_SpaceCenter_AutoPilot_PitchError(krpc_connection_t connection, float * returnValue, krpc_SpaceCenter_AutoPilot_t instance);

/**
 * The current SpaceCenter::SASMode.
 * These modes are equivalent to the mode buttons to the left of the navball that appear
 * when SAS is enabled.
 *
 * Equivalent to SpaceCenter::Control::sas_mode
 */
krpc_error_t krpc_SpaceCenter_AutoPilot_SASMode(krpc_connection_t connection, krpc_SpaceCenter_SASMode_t * returnValue, krpc_SpaceCenter_AutoPilot_t instance);

/**
 * Gains for the yaw PID controller.
 *
 * When SpaceCenter::AutoPilot::auto_tune is true, these values are updated automatically,
 * which will overwrite any manual changes.
 */
krpc_error_t krpc_SpaceCenter_AutoPilot_YawPIDGains(krpc_connection_t connection, krpc_tuple_double_double_double_t * returnValue, krpc_SpaceCenter_AutoPilot_t instance);

/**
 * The target time to peak used to autotune the PID controllers.
 * A vector of three times, in seconds, for each of the pitch, roll and yaw axes.
 * Defaults to 3 seconds for each axis.
 */
krpc_error_t krpc_SpaceCenter_AutoPilot_TimeToPeak(krpc_connection_t connection, krpc_tuple_double_double_double_t * returnValue, krpc_SpaceCenter_AutoPilot_t instance);

/**
 * The time the vessel should take to come to a stop pointing in the target direction.
 * This determines the angular acceleration used to decelerate the vessel.
 * A vector of three times, in seconds, one for each of the pitch, roll and yaw axes.
 * Defaults to 5 seconds for each axis.
 */
krpc_error_t krpc_SpaceCenter_AutoPilot_DecelerationTime(krpc_connection_t connection, krpc_tuple_double_double_double_t * returnValue, krpc_SpaceCenter_AutoPilot_t instance);

/**
 * Gains for the roll PID controller.
 *
 * When SpaceCenter::AutoPilot::auto_tune is true, these values are updated automatically,
 * which will overwrite any manual changes.
 */
krpc_error_t krpc_SpaceCenter_AutoPilot_RollPIDGains(krpc_connection_t connection, krpc_tuple_double_double_double_t * returnValue, krpc_SpaceCenter_AutoPilot_t instance);

/**
 * The angle at which the autopilot considers the vessel to be pointing
 * close to the target.
 * This determines the midpoint of the target velocity attenuation function.
 * A vector of three angles, in degrees, one for each of the pitch, roll and yaw axes.
 * Defaults to 1° for each axis.
 */
krpc_error_t krpc_SpaceCenter_AutoPilot_AttenuationAngle(krpc_connection_t connection, krpc_tuple_double_double_double_t * returnValue, krpc_SpaceCenter_AutoPilot_t instance);

/**
 * The target heading, in degrees, between 0° and 360°.
 */
krpc_error_t krpc_SpaceCenter_AutoPilot_set_TargetHeading(krpc_connection_t connection, krpc_SpaceCenter_AutoPilot_t instance, float value);

/**
 * Direction vector corresponding to the target pitch and heading.
 * This is in the reference frame specified by SpaceCenter::ReferenceFrame.
 */
krpc_error_t krpc_SpaceCenter_AutoPilot_set_TargetDirection(krpc_connection_t connection, krpc_SpaceCenter_AutoPilot_t instance, const krpc_tuple_double_double_double_t * value);

/**
 * The current SpaceCenter::SASMode.
 * These modes are equivalent to the mode buttons to the left of the navball that appear
 * when SAS is enabled.
 *
 * Equivalent to SpaceCenter::Control::sas_mode
 */
krpc_error_t krpc_SpaceCenter_AutoPilot_set_SASMode(krpc_connection_t connection, krpc_SpaceCenter_AutoPilot_t instance, krpc_SpaceCenter_SASMode_t value);

/**
 * The state of SAS.
 *
 * Equivalent to SpaceCenter::Control::sas
 */
krpc_error_t krpc_SpaceCenter_AutoPilot_set_SAS(krpc_connection_t connection, krpc_SpaceCenter_AutoPilot_t instance, bool value);

/**
 * Gains for the pitch PID controller.
 *
 * When SpaceCenter::AutoPilot::auto_tune is true, these values are updated automatically,
 * which will overwrite any manual changes.
 */
krpc_error_t krpc_SpaceCenter_AutoPilot_PitchPIDGains(krpc_connection_t connection, krpc_tuple_double_double_double_t * returnValue, krpc_SpaceCenter_AutoPilot_t instance);

/**
 * The error, in degrees, between the direction the ship has been asked
 * to point in and the direction it is pointing in. Throws an exception if the auto-pilot
 * has not been engaged and SAS is not enabled or is in stability assist mode.
 */
krpc_error_t krpc_SpaceCenter_AutoPilot_Error(krpc_connection_t connection, float * returnValue, krpc_SpaceCenter_AutoPilot_t instance);

/**
 * The target pitch, in degrees, between -90° and +90°.
 */
krpc_error_t krpc_SpaceCenter_AutoPilot_TargetPitch(krpc_connection_t connection, float * returnValue, krpc_SpaceCenter_AutoPilot_t instance);

/**
 * The target roll, in degrees. NaN if no target roll is set.
 */
krpc_error_t krpc_SpaceCenter_AutoPilot_TargetRoll(krpc_connection_t connection, float * returnValue, krpc_SpaceCenter_AutoPilot_t instance);

/**
 * The target time to peak used to autotune the PID controllers.
 * A vector of three times, in seconds, for each of the pitch, roll and yaw axes.
 * Defaults to 3 seconds for each axis.
 */
krpc_error_t krpc_SpaceCenter_AutoPilot_set_TimeToPeak(krpc_connection_t connection, krpc_SpaceCenter_AutoPilot_t instance, const krpc_tuple_double_double_double_t * value);

/**
 * The target overshoot percentage used to autotune the PID controllers.
 * A vector of three values, between 0 and 1, for each of the pitch, roll and yaw axes.
 * Defaults to 0.01 for each axis.
 */
krpc_error_t krpc_SpaceCenter_AutoPilot_Overshoot(krpc_connection_t connection, krpc_tuple_double_double_double_t * returnValue, krpc_SpaceCenter_AutoPilot_t instance);

/**
 * The target overshoot percentage used to autotune the PID controllers.
 * A vector of three values, between 0 and 1, for each of the pitch, roll and yaw axes.
 * Defaults to 0.01 for each axis.
 */
krpc_error_t krpc_SpaceCenter_AutoPilot_set_Overshoot(krpc_connection_t connection, krpc_SpaceCenter_AutoPilot_t instance, const krpc_tuple_double_double_double_t * value);

/**
 * The target pitch, in degrees, between -90° and +90°.
 */
krpc_error_t krpc_SpaceCenter_AutoPilot_set_TargetPitch(krpc_connection_t connection, krpc_SpaceCenter_AutoPilot_t instance, float value);

/**
 * The error, in degrees, between the vessels current and target roll.
 * Throws an exception if the auto-pilot has not been engaged or no target roll is set.
 */
krpc_error_t krpc_SpaceCenter_AutoPilot_RollError(krpc_connection_t connection, float * returnValue, krpc_SpaceCenter_AutoPilot_t instance);

/**
 * The time the vessel should take to come to a stop pointing in the target direction.
 * This determines the angular acceleration used to decelerate the vessel.
 * A vector of three times, in seconds, one for each of the pitch, roll and yaw axes.
 * Defaults to 5 seconds for each axis.
 */
krpc_error_t krpc_SpaceCenter_AutoPilot_set_DecelerationTime(krpc_connection_t connection, krpc_SpaceCenter_AutoPilot_t instance, const krpc_tuple_double_double_double_t * value);

/**
 * Gains for the yaw PID controller.
 *
 * When SpaceCenter::AutoPilot::auto_tune is true, these values are updated automatically,
 * which will overwrite any manual changes.
 */
krpc_error_t krpc_SpaceCenter_AutoPilot_set_YawPIDGains(krpc_connection_t connection, krpc_SpaceCenter_AutoPilot_t instance, const krpc_tuple_double_double_double_t * value);

/**
 * The threshold at which the autopilot will try to match the target roll angle, if any.
 * Defaults to 5 degrees.
 */
krpc_error_t krpc_SpaceCenter_AutoPilot_set_RollThreshold(krpc_connection_t connection, krpc_SpaceCenter_AutoPilot_t instance, double value);

/**
 * In map mode, the celestial body that the camera is focussed on.
 * Returns null if the camera is not focussed on a celestial body.
 * Returns an error is the camera is not in map mode.
 */
krpc_error_t krpc_SpaceCenter_Camera_FocussedBody(krpc_connection_t connection, krpc_SpaceCenter_CelestialBody_t * returnValue, krpc_SpaceCenter_Camera_t instance);

/**
 * Default distance from the camera to the subject, in meters.
 */
krpc_error_t krpc_SpaceCenter_Camera_DefaultDistance(krpc_connection_t connection, float * returnValue, krpc_SpaceCenter_Camera_t instance);

/**
 * The heading of the camera, in degrees.
 */
krpc_error_t krpc_SpaceCenter_Camera_set_Heading(krpc_connection_t connection, krpc_SpaceCenter_Camera_t instance, float value);

/**
 * The current mode of the camera.
 */
krpc_error_t krpc_SpaceCenter_Camera_set_Mode(krpc_connection_t connection, krpc_SpaceCenter_Camera_t instance, krpc_SpaceCenter_CameraMode_t value);

/**
 * The distance from the camera to the subject, in meters.
 * A value between SpaceCenter::Camera::min_distance and SpaceCenter::Camera::max_distance.
 */
krpc_error_t krpc_SpaceCenter_Camera_Distance(krpc_connection_t connection, float * returnValue, krpc_SpaceCenter_Camera_t instance);

/**
 * The maximum pitch of the camera.
 */
krpc_error_t krpc_SpaceCenter_Camera_MaxPitch(krpc_connection_t connection, float * returnValue, krpc_SpaceCenter_Camera_t instance);

/**
 * In map mode, the maneuver node that the camera is focussed on.
 * Returns null if the camera is not focussed on a maneuver node.
 * Returns an error is the camera is not in map mode.
 */
krpc_error_t krpc_SpaceCenter_Camera_FocussedNode(krpc_connection_t connection, krpc_SpaceCenter_Node_t * returnValue, krpc_SpaceCenter_Camera_t instance);

/**
 * The pitch of the camera, in degrees.
 * A value between SpaceCenter::Camera::min_pitch and SpaceCenter::Camera::max_pitch
 */
krpc_error_t krpc_SpaceCenter_Camera_set_Pitch(krpc_connection_t connection, krpc_SpaceCenter_Camera_t instance, float value);

/**
 * In map mode, the vessel that the camera is focussed on.
 * Returns null if the camera is not focussed on a vessel.
 * Returns an error is the camera is not in map mode.
 */
krpc_error_t krpc_SpaceCenter_Camera_set_FocussedVessel(krpc_connection_t connection, krpc_SpaceCenter_Camera_t instance, krpc_SpaceCenter_Vessel_t value);

/**
 * The distance from the camera to the subject, in meters.
 * A value between SpaceCenter::Camera::min_distance and SpaceCenter::Camera::max_distance.
 */
krpc_error_t krpc_SpaceCenter_Camera_set_Distance(krpc_connection_t connection, krpc_SpaceCenter_Camera_t instance, float value);

/**
 * In map mode, the celestial body that the camera is focussed on.
 * Returns null if the camera is not focussed on a celestial body.
 * Returns an error is the camera is not in map mode.
 */
krpc_error_t krpc_SpaceCenter_Camera_set_FocussedBody(krpc_connection_t connection, krpc_SpaceCenter_Camera_t instance, krpc_SpaceCenter_CelestialBody_t value);

/**
 * The current mode of the camera.
 */
krpc_error_t krpc_SpaceCenter_Camera_Mode(krpc_connection_t connection, krpc_SpaceCenter_CameraMode_t * returnValue, krpc_SpaceCenter_Camera_t instance);

/**
 * Minimum distance from the camera to the subject, in meters.
 */
krpc_error_t krpc_SpaceCenter_Camera_MinDistance(krpc_connection_t connection, float * returnValue, krpc_SpaceCenter_Camera_t instance);

/**
 * The pitch of the camera, in degrees.
 * A value between SpaceCenter::Camera::min_pitch and SpaceCenter::Camera::max_pitch
 */
krpc_error_t krpc_SpaceCenter_Camera_Pitch(krpc_connection_t connection, float * returnValue, krpc_SpaceCenter_Camera_t instance);

/**
 * In map mode, the vessel that the camera is focussed on.
 * Returns null if the camera is not focussed on a vessel.
 * Returns an error is the camera is not in map mode.
 */
krpc_error_t krpc_SpaceCenter_Camera_FocussedVessel(krpc_connection_t connection, krpc_SpaceCenter_Vessel_t * returnValue, krpc_SpaceCenter_Camera_t instance);

/**
 * In map mode, the maneuver node that the camera is focussed on.
 * Returns null if the camera is not focussed on a maneuver node.
 * Returns an error is the camera is not in map mode.
 */
krpc_error_t krpc_SpaceCenter_Camera_set_FocussedNode(krpc_connection_t connection, krpc_SpaceCenter_Camera_t instance, krpc_SpaceCenter_Node_t value);

/**
 * Maximum distance from the camera to the subject, in meters.
 */
krpc_error_t krpc_SpaceCenter_Camera_MaxDistance(krpc_connection_t connection, float * returnValue, krpc_SpaceCenter_Camera_t instance);

/**
 * The heading of the camera, in degrees.
 */
krpc_error_t krpc_SpaceCenter_Camera_Heading(krpc_connection_t connection, float * returnValue, krpc_SpaceCenter_Camera_t instance);

/**
 * The minimum pitch of the camera.
 */
krpc_error_t krpc_SpaceCenter_Camera_MinPitch(krpc_connection_t connection, float * returnValue, krpc_SpaceCenter_Camera_t instance);

/**
 * The state of the cargo bay.
 */
krpc_error_t krpc_SpaceCenter_CargoBay_State(krpc_connection_t connection, krpc_SpaceCenter_CargoBayState_t * returnValue, krpc_SpaceCenter_CargoBay_t instance);

/**
 * Whether the cargo bay is open.
 */
krpc_error_t krpc_SpaceCenter_CargoBay_set_Open(krpc_connection_t connection, krpc_SpaceCenter_CargoBay_t instance, bool value);

/**
 * Whether the cargo bay is open.
 */
krpc_error_t krpc_SpaceCenter_CargoBay_Open(krpc_connection_t connection, bool * returnValue, krpc_SpaceCenter_CargoBay_t instance);

/**
 * The part object for this cargo bay.
 */
krpc_error_t krpc_SpaceCenter_CargoBay_Part(krpc_connection_t connection, krpc_SpaceCenter_Part_t * returnValue, krpc_SpaceCenter_CargoBay_t instance);

/**
 * The altitude, in meters, of the given position in the given reference frame.
 * @param position Position as a vector.
 * @param referenceFrame Reference frame for the position vector.
 */
krpc_error_t krpc_SpaceCenter_CelestialBody_AltitudeAtPosition(krpc_connection_t connection, double * returnValue, krpc_SpaceCenter_CelestialBody_t instance, const krpc_tuple_double_double_double_t * position, krpc_SpaceCenter_ReferenceFrame_t referenceFrame);

/**
 * The angular velocity of the body in the specified reference frame.
 * @return The angular velocity as a vector. The magnitude of the vector is the rotational
 * speed of the body, in radians per second. The direction of the vector indicates the axis
 * of rotation, using the right-hand rule.
 * @param referenceFrame The reference frame the returned
 * angular velocity is in.
 */
krpc_error_t krpc_SpaceCenter_CelestialBody_AngularVelocity(krpc_connection_t connection, krpc_tuple_double_double_double_t * returnValue, krpc_SpaceCenter_CelestialBody_t instance, krpc_SpaceCenter_ReferenceFrame_t referenceFrame);

/**
 * The atmospheric density at the given position, in kg/m^3,
 * in the given reference frame.
 * @param position The position vector at which to measure the density.
 * @param referenceFrame Reference frame that the position vector is in.
 */
krpc_error_t krpc_SpaceCenter_CelestialBody_AtmosphericDensityAtPosition(krpc_connection_t connection, double * returnValue, krpc_SpaceCenter_CelestialBody_t instance, const krpc_tuple_double_double_double_t * position, krpc_SpaceCenter_ReferenceFrame_t referenceFrame);

/**
 * The height of the surface relative to mean sea level, in meters,
 * at the given position. When over water, this is the height
 * of the sea-bed and is therefore  negative value.
 * @param latitude Latitude in degrees.
 * @param longitude Longitude in degrees.
 */
krpc_error_t krpc_SpaceCenter_CelestialBody_BedrockHeight(krpc_connection_t connection, double * returnValue, krpc_SpaceCenter_CelestialBody_t instance, double latitude, double longitude);

/**
 * The position of the surface at the given latitude and longitude, in the given
 * reference frame. When over water, this is the position at the bottom of the sea-bed.
 * @return Position as a vector.
 * @param latitude Latitude in degrees.
 * @param longitude Longitude in degrees.
 * @param referenceFrame Reference frame for the returned position vector.
 */
krpc_error_t krpc_SpaceCenter_CelestialBody_BedrockPosition(krpc_connection_t connection, krpc_tuple_double_double_double_t * returnValue, krpc_SpaceCenter_CelestialBody_t instance, double latitude, double longitude, krpc_SpaceCenter_ReferenceFrame_t referenceFrame);

/**
 * The biome at the given latitude and longitude, in degrees.
 */
krpc_error_t krpc_SpaceCenter_CelestialBody_BiomeAt(krpc_connection_t connection, char * * returnValue, krpc_SpaceCenter_CelestialBody_t instance, double latitude, double longitude);

/**
 * Gets the air density, in kg/m^3, for the specified
 * altitude above sea level, in meters.
 *
 * This is an approximation, because actual calculations, taking sun exposure into account
 * to compute air temperature, require us to know the exact point on the body where the
 * density is to be computed (knowing the altitude is not enough).
 * However, the difference is small for high altitudes, so it makes very little difference
 * for trajectory prediction.
 */
krpc_error_t krpc_SpaceCenter_CelestialBody_DensityAt(krpc_connection_t connection, double * returnValue, krpc_SpaceCenter_CelestialBody_t instance, double altitude);

/**
 * The direction in which the north pole of the celestial body is pointing,
 * in the specified reference frame.
 * @return The direction as a unit vector.
 * @param referenceFrame The reference frame that the returned
 * direction is in.
 */
krpc_error_t krpc_SpaceCenter_CelestialBody_Direction(krpc_connection_t connection, krpc_tuple_double_double_double_t * returnValue, krpc_SpaceCenter_CelestialBody_t instance, krpc_SpaceCenter_ReferenceFrame_t referenceFrame);

/**
 * The latitude of the given position, in the given reference frame.
 * @param position Position as a vector.
 * @param referenceFrame Reference frame for the position vector.
 */
krpc_error_t krpc_SpaceCenter_CelestialBody_LatitudeAtPosition(krpc_connection_t connection, double * returnValue, krpc_SpaceCenter_CelestialBody_t instance, const krpc_tuple_double_double_double_t * position, krpc_SpaceCenter_ReferenceFrame_t referenceFrame);

/**
 * The longitude of the given position, in the given reference frame.
 * @param position Position as a vector.
 * @param referenceFrame Reference frame for the position vector.
 */
krpc_error_t krpc_SpaceCenter_CelestialBody_LongitudeAtPosition(krpc_connection_t connection, double * returnValue, krpc_SpaceCenter_CelestialBody_t instance, const krpc_tuple_double_double_double_t * position, krpc_SpaceCenter_ReferenceFrame_t referenceFrame);

/**
 * The position at mean sea level at the given latitude and longitude,
 * in the given reference frame.
 * @return Position as a vector.
 * @param latitude Latitude in degrees.
 * @param longitude Longitude in degrees.
 * @param referenceFrame Reference frame for the returned position vector.
 */
krpc_error_t krpc_SpaceCenter_CelestialBody_MSLPosition(krpc_connection_t connection, krpc_tuple_double_double_double_t * returnValue, krpc_SpaceCenter_CelestialBody_t instance, double latitude, double longitude, krpc_SpaceCenter_ReferenceFrame_t referenceFrame);

/**
 * The position of the center of the body, in the specified reference frame.
 * @return The position as a vector.
 * @param referenceFrame The reference frame that the returned
 * position vector is in.
 */
krpc_error_t krpc_SpaceCenter_CelestialBody_Position(krpc_connection_t connection, krpc_tuple_double_double_double_t * returnValue, krpc_SpaceCenter_CelestialBody_t instance, krpc_SpaceCenter_ReferenceFrame_t referenceFrame);

/**
 * The position at the given latitude, longitude and altitude, in the given reference frame.
 * @return Position as a vector.
 * @param latitude Latitude in degrees.
 * @param longitude Longitude in degrees.
 * @param altitude Altitude in meters above sea level.
 * @param referenceFrame Reference frame for the returned position vector.
 */
krpc_error_t krpc_SpaceCenter_CelestialBody_PositionAtAltitude(krpc_connection_t connection, krpc_tuple_double_double_double_t * returnValue, krpc_SpaceCenter_CelestialBody_t instance, double latitude, double longitude, double altitude, krpc_SpaceCenter_ReferenceFrame_t referenceFrame);

/**
 * Gets the air pressure, in Pascals, for the specified
 * altitude above sea level, in meters.
 */
krpc_error_t krpc_SpaceCenter_CelestialBody_PressureAt(krpc_connection_t connection, double * returnValue, krpc_SpaceCenter_CelestialBody_t instance, double altitude);

/**
 * The rotation of the body, in the specified reference frame.
 * @return The rotation as a quaternion of the form (x, y, z, w).
 * @param referenceFrame The reference frame that the returned
 * rotation is in.
 */
krpc_error_t krpc_SpaceCenter_CelestialBody_Rotation(krpc_connection_t connection, krpc_tuple_double_double_double_double_t * returnValue, krpc_SpaceCenter_CelestialBody_t instance, krpc_SpaceCenter_ReferenceFrame_t referenceFrame);

/**
 * The height of the surface relative to mean sea level, in meters,
 * at the given position. When over water this is equal to 0.
 * @param latitude Latitude in degrees.
 * @param longitude Longitude in degrees.
 */
krpc_error_t krpc_SpaceCenter_CelestialBody_SurfaceHeight(krpc_connection_t connection, double * returnValue, krpc_SpaceCenter_CelestialBody_t instance, double latitude, double longitude);

/**
 * The position of the surface at the given latitude and longitude, in the given
 * reference frame. When over water, this is the position of the surface of the water.
 * @return Position as a vector.
 * @param latitude Latitude in degrees.
 * @param longitude Longitude in degrees.
 * @param referenceFrame Reference frame for the returned position vector.
 */
krpc_error_t krpc_SpaceCenter_CelestialBody_SurfacePosition(krpc_connection_t connection, krpc_tuple_double_double_double_t * returnValue, krpc_SpaceCenter_CelestialBody_t instance, double latitude, double longitude, krpc_SpaceCenter_ReferenceFrame_t referenceFrame);

/**
 * The temperature on the body at the given position, in the given reference frame.
 * @param position Position as a vector.
 * @param referenceFrame The reference frame that the position is in.
 *
 * This calculation is performed using the bodies current position, which means that
 * the value could be wrong if you want to know the temperature in the far future.
 */
krpc_error_t krpc_SpaceCenter_CelestialBody_TemperatureAt(krpc_connection_t connection, double * returnValue, krpc_SpaceCenter_CelestialBody_t instance, const krpc_tuple_double_double_double_t * position, krpc_SpaceCenter_ReferenceFrame_t referenceFrame);

/**
 * The linear velocity of the body, in the specified reference frame.
 * @return The velocity as a vector. The vector points in the direction of travel,
 * and its magnitude is the speed of the body in meters per second.
 * @param referenceFrame The reference frame that the returned
 * velocity vector is in.
 */
krpc_error_t krpc_SpaceCenter_CelestialBody_Velocity(krpc_connection_t connection, krpc_tuple_double_double_double_t * returnValue, krpc_SpaceCenter_CelestialBody_t instance, krpc_SpaceCenter_ReferenceFrame_t referenceFrame);

/**
 * The reference frame that is fixed relative to the celestial body.
 *
 * - The origin is at the center of the body.
 * - The axes rotate with the body.
 * - The x-axis points from the center of the body
 *   towards the intersection of the prime meridian and equator (the
 *   position at 0° longitude, 0° latitude).
 * - The y-axis points from the center of the body
 *   towards the north pole.
 * - The z-axis points from the center of the body
 *   towards the equator at 90°E longitude.
 */
krpc_error_t krpc_SpaceCenter_CelestialBody_ReferenceFrame(krpc_connection_t connection, krpc_SpaceCenter_ReferenceFrame_t * returnValue, krpc_SpaceCenter_CelestialBody_t instance);

/**
 * The name of the body.
 */
krpc_error_t krpc_SpaceCenter_CelestialBody_Name(krpc_connection_t connection, char * * returnValue, krpc_SpaceCenter_CelestialBody_t instance);

/**
 * The reference frame that is fixed relative to this celestial body, and
 * orientated in a fixed direction (it does not rotate with the body).
 *
 * - The origin is at the center of the body.
 * - The axes do not rotate.
 * - The x-axis points in an arbitrary direction through the
 *   equator.
 * - The y-axis points from the center of the body towards
 *   the north pole.
 * - The z-axis points in an arbitrary direction through the
 *   equator.
 */
krpc_error_t krpc_SpaceCenter_CelestialBody_NonRotatingReferenceFrame(krpc_connection_t connection, krpc_SpaceCenter_ReferenceFrame_t * returnValue, krpc_SpaceCenter_CelestialBody_t instance);

/**
 * The altitude, in meters, above which a vessel is considered to be
 * in "high" space when doing science.
 */
krpc_error_t krpc_SpaceCenter_CelestialBody_SpaceHighAltitudeThreshold(krpc_connection_t connection, float * returnValue, krpc_SpaceCenter_CelestialBody_t instance);

/**
 * The initial rotation angle of the body (at UT 0), in radians.
 * A value between 0 and 2\pi
 */
krpc_error_t krpc_SpaceCenter_CelestialBody_InitialRotation(krpc_connection_t connection, double * returnValue, krpc_SpaceCenter_CelestialBody_t instance);

/**
 * The radius of the sphere of influence of the body, in meters.
 */
krpc_error_t krpc_SpaceCenter_CelestialBody_SphereOfInfluence(krpc_connection_t connection, float * returnValue, krpc_SpaceCenter_CelestialBody_t instance);

/**
 * The orbit of the body.
 */
krpc_error_t krpc_SpaceCenter_CelestialBody_Orbit(krpc_connection_t connection, krpc_SpaceCenter_Orbit_t * returnValue, krpc_SpaceCenter_CelestialBody_t instance);

/**
 * The rotational speed of the body, in radians per second.
 */
krpc_error_t krpc_SpaceCenter_CelestialBody_RotationalSpeed(krpc_connection_t connection, float * returnValue, krpc_SpaceCenter_CelestialBody_t instance);

/**
 * The depth of the atmosphere, in meters.
 */
krpc_error_t krpc_SpaceCenter_CelestialBody_AtmosphereDepth(krpc_connection_t connection, float * returnValue, krpc_SpaceCenter_CelestialBody_t instance);

/**
 * The sidereal rotational period of the body, in seconds.
 */
krpc_error_t krpc_SpaceCenter_CelestialBody_RotationalPeriod(krpc_connection_t connection, float * returnValue, krpc_SpaceCenter_CelestialBody_t instance);

/**
 * The current rotation angle of the body, in radians.
 * A value between 0 and 2\pi
 */
krpc_error_t krpc_SpaceCenter_CelestialBody_RotationAngle(krpc_connection_t connection, double * returnValue, krpc_SpaceCenter_CelestialBody_t instance);

/**
 * The mass of the body, in kilograms.
 */
krpc_error_t krpc_SpaceCenter_CelestialBody_Mass(krpc_connection_t connection, float * returnValue, krpc_SpaceCenter_CelestialBody_t instance);

/**
 * The equatorial radius of the body, in meters.
 */
krpc_error_t krpc_SpaceCenter_CelestialBody_EquatorialRadius(krpc_connection_t connection, float * returnValue, krpc_SpaceCenter_CelestialBody_t instance);

/**
 * The <a href="https://en.wikipedia.org/wiki/Standard_gravitational_parameter">standard
 * gravitational parameter</a> of the body in m^3s^{-2}.
 */
krpc_error_t krpc_SpaceCenter_CelestialBody_GravitationalParameter(krpc_connection_t connection, float * returnValue, krpc_SpaceCenter_CelestialBody_t instance);

/**
 * A list of celestial bodies that are in orbit around this celestial body.
 */
krpc_error_t krpc_SpaceCenter_CelestialBody_Satellites(krpc_connection_t connection, krpc_list_object_t * returnValue, krpc_SpaceCenter_CelestialBody_t instance);

/**
 * The biomes present on this body.
 */
krpc_error_t krpc_SpaceCenter_CelestialBody_Biomes(krpc_connection_t connection, krpc_set_string_t * returnValue, krpc_SpaceCenter_CelestialBody_t instance);

/**
 * The altitude, in meters, above which a vessel is considered to be
 * flying "high" when doing science.
 */
krpc_error_t krpc_SpaceCenter_CelestialBody_FlyingHighAltitudeThreshold(krpc_connection_t connection, float * returnValue, krpc_SpaceCenter_CelestialBody_t instance);

/**
 * The reference frame that is fixed relative to this celestial body, but
 * orientated with the body's orbital prograde/normal/radial directions.
 *
 * - The origin is at the center of the body.
 * - The axes rotate with the orbital prograde/normal/radial
 *   directions.
 * - The x-axis points in the orbital anti-radial direction.
 * - The y-axis points in the orbital prograde direction.
 * - The z-axis points in the orbital normal direction.
 */
krpc_error_t krpc_SpaceCenter_CelestialBody_OrbitalReferenceFrame(krpc_connection_t connection, krpc_SpaceCenter_ReferenceFrame_t * returnValue, krpc_SpaceCenter_CelestialBody_t instance);

/**
 * true if the body has an atmosphere.
 */
krpc_error_t krpc_SpaceCenter_CelestialBody_HasAtmosphere(krpc_connection_t connection, bool * returnValue, krpc_SpaceCenter_CelestialBody_t instance);

/**
 * The acceleration due to gravity at sea level (mean altitude) on the body,
 * in m/s^2.
 */
krpc_error_t krpc_SpaceCenter_CelestialBody_SurfaceGravity(krpc_connection_t connection, float * returnValue, krpc_SpaceCenter_CelestialBody_t instance);

/**
 * true if there is oxygen in the atmosphere, required for air-breathing engines.
 */
krpc_error_t krpc_SpaceCenter_CelestialBody_HasAtmosphericOxygen(krpc_connection_t connection, bool * returnValue, krpc_SpaceCenter_CelestialBody_t instance);

/**
 * Signal strength of the link.
 */
krpc_error_t krpc_SpaceCenter_CommLink_SignalStrength(krpc_connection_t connection, double * returnValue, krpc_SpaceCenter_CommLink_t instance);

/**
 * The type of link.
 */
krpc_error_t krpc_SpaceCenter_CommLink_Type(krpc_connection_t connection, krpc_SpaceCenter_CommLinkType_t * returnValue, krpc_SpaceCenter_CommLink_t instance);

/**
 * Start point of the link.
 */
krpc_error_t krpc_SpaceCenter_CommLink_End(krpc_connection_t connection, krpc_SpaceCenter_CommNode_t * returnValue, krpc_SpaceCenter_CommLink_t instance);

/**
 * Start point of the link.
 */
krpc_error_t krpc_SpaceCenter_CommLink_Start(krpc_connection_t connection, krpc_SpaceCenter_CommNode_t * returnValue, krpc_SpaceCenter_CommLink_t instance);

/**
 * The vessel for this communication node.
 */
krpc_error_t krpc_SpaceCenter_CommNode_Vessel(krpc_connection_t connection, krpc_SpaceCenter_Vessel_t * returnValue, krpc_SpaceCenter_CommNode_t instance);

/**
 * Whether the communication node is on Kerbin.
 */
krpc_error_t krpc_SpaceCenter_CommNode_IsHome(krpc_connection_t connection, bool * returnValue, krpc_SpaceCenter_CommNode_t instance);

/**
 * Whether the communication node is a control point, for example a manned vessel.
 */
krpc_error_t krpc_SpaceCenter_CommNode_IsControlPoint(krpc_connection_t connection, bool * returnValue, krpc_SpaceCenter_CommNode_t instance);

/**
 * Whether the communication node is a vessel.
 */
krpc_error_t krpc_SpaceCenter_CommNode_IsVessel(krpc_connection_t connection, bool * returnValue, krpc_SpaceCenter_CommNode_t instance);

/**
 * Name of the communication node.
 */
krpc_error_t krpc_SpaceCenter_CommNode_Name(krpc_connection_t connection, char * * returnValue, krpc_SpaceCenter_CommNode_t instance);

/**
 * Signal strength to KSC.
 */
krpc_error_t krpc_SpaceCenter_Comms_SignalStrength(krpc_connection_t connection, double * returnValue, krpc_SpaceCenter_Comms_t instance);

/**
 * The combined power of all active antennae on the vessel.
 */
krpc_error_t krpc_SpaceCenter_Comms_Power(krpc_connection_t connection, double * returnValue, krpc_SpaceCenter_Comms_t instance);

/**
 * Whether the vessel can communicate with KSC.
 */
krpc_error_t krpc_SpaceCenter_Comms_CanCommunicate(krpc_connection_t connection, bool * returnValue, krpc_SpaceCenter_Comms_t instance);

/**
 * Signal delay to KSC in seconds.
 */
krpc_error_t krpc_SpaceCenter_Comms_SignalDelay(krpc_connection_t connection, double * returnValue, krpc_SpaceCenter_Comms_t instance);

/**
 * Whether the vessel can transmit science data to KSC.
 */
krpc_error_t krpc_SpaceCenter_Comms_CanTransmitScience(krpc_connection_t connection, bool * returnValue, krpc_SpaceCenter_Comms_t instance);

/**
 * The communication path used to control the vessel.
 */
krpc_error_t krpc_SpaceCenter_Comms_ControlPath(krpc_connection_t connection, krpc_list_object_t * returnValue, krpc_SpaceCenter_Comms_t instance);

/**
 * Accept an offered contract.
 */
krpc_error_t krpc_SpaceCenter_Contract_Accept(krpc_connection_t connection, krpc_SpaceCenter_Contract_t instance);

/**
 * Cancel an active contract.
 */
krpc_error_t krpc_SpaceCenter_Contract_Cancel(krpc_connection_t connection, krpc_SpaceCenter_Contract_t instance);

/**
 * Decline an offered contract.
 */
krpc_error_t krpc_SpaceCenter_Contract_Decline(krpc_connection_t connection, krpc_SpaceCenter_Contract_t instance);

/**
 * Funds received on completion of the contract.
 */
krpc_error_t krpc_SpaceCenter_Contract_FundsCompletion(krpc_connection_t connection, double * returnValue, krpc_SpaceCenter_Contract_t instance);

/**
 * Reputation gained on completion of the contract.
 */
krpc_error_t krpc_SpaceCenter_Contract_ReputationCompletion(krpc_connection_t connection, double * returnValue, krpc_SpaceCenter_Contract_t instance);

/**
 * Description of the contract.
 */
krpc_error_t krpc_SpaceCenter_Contract_Description(krpc_connection_t connection, char * * returnValue, krpc_SpaceCenter_Contract_t instance);

/**
 * Funds received when accepting the contract.
 */
krpc_error_t krpc_SpaceCenter_Contract_FundsAdvance(krpc_connection_t connection, double * returnValue, krpc_SpaceCenter_Contract_t instance);

/**
 * Science gained on completion of the contract.
 */
krpc_error_t krpc_SpaceCenter_Contract_ScienceCompletion(krpc_connection_t connection, double * returnValue, krpc_SpaceCenter_Contract_t instance);

/**
 * Whether the contract has been read.
 */
krpc_error_t krpc_SpaceCenter_Contract_Read(krpc_connection_t connection, bool * returnValue, krpc_SpaceCenter_Contract_t instance);

/**
 * Notes for the contract.
 */
krpc_error_t krpc_SpaceCenter_Contract_Notes(krpc_connection_t connection, char * * returnValue, krpc_SpaceCenter_Contract_t instance);

/**
 * Title of the contract.
 */
krpc_error_t krpc_SpaceCenter_Contract_Title(krpc_connection_t connection, char * * returnValue, krpc_SpaceCenter_Contract_t instance);

/**
 * Synopsis for the contract.
 */
krpc_error_t krpc_SpaceCenter_Contract_Synopsis(krpc_connection_t connection, char * * returnValue, krpc_SpaceCenter_Contract_t instance);

/**
 * Whether the contract can be canceled.
 */
krpc_error_t krpc_SpaceCenter_Contract_CanBeCanceled(krpc_connection_t connection, bool * returnValue, krpc_SpaceCenter_Contract_t instance);

/**
 * Parameters for the contract.
 */
krpc_error_t krpc_SpaceCenter_Contract_Parameters(krpc_connection_t connection, krpc_list_object_t * returnValue, krpc_SpaceCenter_Contract_t instance);

/**
 * Whether the contract has been failed.
 */
krpc_error_t krpc_SpaceCenter_Contract_Failed(krpc_connection_t connection, bool * returnValue, krpc_SpaceCenter_Contract_t instance);

/**
 * Funds lost if the contract is failed.
 */
krpc_error_t krpc_SpaceCenter_Contract_FundsFailure(krpc_connection_t connection, double * returnValue, krpc_SpaceCenter_Contract_t instance);

/**
 * Reputation lost if the contract is failed.
 */
krpc_error_t krpc_SpaceCenter_Contract_ReputationFailure(krpc_connection_t connection, double * returnValue, krpc_SpaceCenter_Contract_t instance);

/**
 * Keywords for the contract.
 */
krpc_error_t krpc_SpaceCenter_Contract_Keywords(krpc_connection_t connection, krpc_list_string_t * returnValue, krpc_SpaceCenter_Contract_t instance);

/**
 * Whether the contract can be declined.
 */
krpc_error_t krpc_SpaceCenter_Contract_CanBeDeclined(krpc_connection_t connection, bool * returnValue, krpc_SpaceCenter_Contract_t instance);

/**
 * Whether the contract is active.
 */
krpc_error_t krpc_SpaceCenter_Contract_Active(krpc_connection_t connection, bool * returnValue, krpc_SpaceCenter_Contract_t instance);

/**
 * Whether the contract has been seen.
 */
krpc_error_t krpc_SpaceCenter_Contract_Seen(krpc_connection_t connection, bool * returnValue, krpc_SpaceCenter_Contract_t instance);

/**
 * Type of the contract.
 */
krpc_error_t krpc_SpaceCenter_Contract_Type(krpc_connection_t connection, char * * returnValue, krpc_SpaceCenter_Contract_t instance);

/**
 * State of the contract.
 */
krpc_error_t krpc_SpaceCenter_Contract_State(krpc_connection_t connection, krpc_SpaceCenter_ContractState_t * returnValue, krpc_SpaceCenter_Contract_t instance);

/**
 * Whether the contract can be failed.
 */
krpc_error_t krpc_SpaceCenter_Contract_CanBeFailed(krpc_connection_t connection, bool * returnValue, krpc_SpaceCenter_Contract_t instance);

/**
 * A list of all offered, but unaccepted, contracts.
 */
krpc_error_t krpc_SpaceCenter_ContractManager_OfferedContracts(krpc_connection_t connection, krpc_list_object_t * returnValue, krpc_SpaceCenter_ContractManager_t instance);

/**
 * A list of all completed contracts.
 */
krpc_error_t krpc_SpaceCenter_ContractManager_CompletedContracts(krpc_connection_t connection, krpc_list_object_t * returnValue, krpc_SpaceCenter_ContractManager_t instance);

/**
 * A list of all contracts.
 */
krpc_error_t krpc_SpaceCenter_ContractManager_AllContracts(krpc_connection_t connection, krpc_list_object_t * returnValue, krpc_SpaceCenter_ContractManager_t instance);

/**
 * A list of all active contracts.
 */
krpc_error_t krpc_SpaceCenter_ContractManager_ActiveContracts(krpc_connection_t connection, krpc_list_object_t * returnValue, krpc_SpaceCenter_ContractManager_t instance);

/**
 * A list of all contract types.
 */
krpc_error_t krpc_SpaceCenter_ContractManager_Types(krpc_connection_t connection, krpc_set_string_t * returnValue, krpc_SpaceCenter_ContractManager_t instance);

/**
 * A list of all failed contracts.
 */
krpc_error_t krpc_SpaceCenter_ContractManager_FailedContracts(krpc_connection_t connection, krpc_list_object_t * returnValue, krpc_SpaceCenter_ContractManager_t instance);

/**
 * Funds received on completion of the contract parameter.
 */
krpc_error_t krpc_SpaceCenter_ContractParameter_FundsCompletion(krpc_connection_t connection, double * returnValue, krpc_SpaceCenter_ContractParameter_t instance);

/**
 * Reputation gained on completion of the contract parameter.
 */
krpc_error_t krpc_SpaceCenter_ContractParameter_ReputationCompletion(krpc_connection_t connection, double * returnValue, krpc_SpaceCenter_ContractParameter_t instance);

/**
 * Funds lost if the contract parameter is failed.
 */
krpc_error_t krpc_SpaceCenter_ContractParameter_FundsFailure(krpc_connection_t connection, double * returnValue, krpc_SpaceCenter_ContractParameter_t instance);

/**
 * Science gained on completion of the contract parameter.
 */
krpc_error_t krpc_SpaceCenter_ContractParameter_ScienceCompletion(krpc_connection_t connection, double * returnValue, krpc_SpaceCenter_ContractParameter_t instance);

/**
 * Reputation lost if the contract parameter is failed.
 */
krpc_error_t krpc_SpaceCenter_ContractParameter_ReputationFailure(krpc_connection_t connection, double * returnValue, krpc_SpaceCenter_ContractParameter_t instance);

/**
 * Whether the parameter has been completed.
 */
krpc_error_t krpc_SpaceCenter_ContractParameter_Completed(krpc_connection_t connection, bool * returnValue, krpc_SpaceCenter_ContractParameter_t instance);

/**
 * Title of the parameter.
 */
krpc_error_t krpc_SpaceCenter_ContractParameter_Title(krpc_connection_t connection, char * * returnValue, krpc_SpaceCenter_ContractParameter_t instance);

/**
 * Child contract parameters.
 */
krpc_error_t krpc_SpaceCenter_ContractParameter_Children(krpc_connection_t connection, krpc_list_object_t * returnValue, krpc_SpaceCenter_ContractParameter_t instance);

/**
 * Whether the parameter has been failed.
 */
krpc_error_t krpc_SpaceCenter_ContractParameter_Failed(krpc_connection_t connection, bool * returnValue, krpc_SpaceCenter_ContractParameter_t instance);

/**
 * Whether the contract parameter is optional.
 */
krpc_error_t krpc_SpaceCenter_ContractParameter_Optional(krpc_connection_t connection, bool * returnValue, krpc_SpaceCenter_ContractParameter_t instance);

/**
 * Notes for the parameter.
 */
krpc_error_t krpc_SpaceCenter_ContractParameter_Notes(krpc_connection_t connection, char * * returnValue, krpc_SpaceCenter_ContractParameter_t instance);

/**
 * Activates the next stage. Equivalent to pressing the space bar in-game.
 * @return A list of vessel objects that are jettisoned from the active vessel.
 *
 * When called, the active vessel may change. It is therefore possible that,
 * after calling this function, the object(s) returned by previous call(s) to
 * SpaceCenter::active_vessel no longer refer to the active vessel.
 */
krpc_error_t krpc_SpaceCenter_Control_ActivateNextStage(krpc_connection_t connection, krpc_list_object_t * returnValue, krpc_SpaceCenter_Control_t instance);

/**
 * Creates a maneuver node at the given universal time, and returns a
 * SpaceCenter::Node object that can be used to modify it.
 * Optionally sets the magnitude of the delta-v for the maneuver node
 * in the prograde, normal and radial directions.
 * @param ut Universal time of the maneuver node.
 * @param prograde Delta-v in the prograde direction.
 * @param normal Delta-v in the normal direction.
 * @param radial Delta-v in the radial direction.
 */
krpc_error_t krpc_SpaceCenter_Control_AddNode(krpc_connection_t connection, krpc_SpaceCenter_Node_t * returnValue, krpc_SpaceCenter_Control_t instance, double ut, float prograde, float normal, float radial);

/**
 * Returns true if the given action group is enabled.
 * @param group A number between 0 and 9 inclusive,
 * or between 0 and 250 inclusive when the <a href="https://forum.kerbalspaceprogram.com/index.php?/topic/67235-122dec1016-action-groups-extended-250-action-groups-in-flight-editing-now-kosremotetech/">Extended Action Groups mod</a> is installed.
 */
krpc_error_t krpc_SpaceCenter_Control_GetActionGroup(krpc_connection_t connection, bool * returnValue, krpc_SpaceCenter_Control_t instance, uint32_t group);

/**
 * Remove all maneuver nodes.
 */
krpc_error_t krpc_SpaceCenter_Control_RemoveNodes(krpc_connection_t connection, krpc_SpaceCenter_Control_t instance);

/**
 * Sets the state of the given action group.
 * @param group A number between 0 and 9 inclusive,
 * or between 0 and 250 inclusive when the <a href="https://forum.kerbalspaceprogram.com/index.php?/topic/67235-122dec1016-action-groups-extended-250-action-groups-in-flight-editing-now-kosremotetech/">Extended Action Groups mod</a> is installed.
 * @param state
 */
krpc_error_t krpc_SpaceCenter_Control_SetActionGroup(krpc_connection_t connection, krpc_SpaceCenter_Control_t instance, uint32_t group, bool state);

/**
 * Toggles the state of the given action group.
 * @param group A number between 0 and 9 inclusive,
 * or between 0 and 250 inclusive when the <a href="https://forum.kerbalspaceprogram.com/index.php?/topic/67235-122dec1016-action-groups-extended-250-action-groups-in-flight-editing-now-kosremotetech/">Extended Action Groups mod</a> is installed.
 */
krpc_error_t krpc_SpaceCenter_Control_ToggleActionGroup(krpc_connection_t connection, krpc_SpaceCenter_Control_t instance, uint32_t group);

/**
 * The state of the wheel brakes.
 */
krpc_error_t krpc_SpaceCenter_Control_set_Brakes(krpc_connection_t connection, krpc_SpaceCenter_Control_t instance, bool value);

/**
 * Returns whether all of the air intakes on the vessel are open,
 * and sets the open state of all air intakes.
 * See SpaceCenter::Intake::open.
 */
krpc_error_t krpc_SpaceCenter_Control_set_Intakes(krpc_connection_t connection, krpc_SpaceCenter_Control_t instance, bool value);

/**
 * The state of the right translational control.
 * A value between -1 and 1.
 * Equivalent to the j and l keys.
 */
krpc_error_t krpc_SpaceCenter_Control_set_Right(krpc_connection_t connection, krpc_SpaceCenter_Control_t instance, float value);

/**
 * The state of the yaw control.
 * A value between -1 and 1.
 * Equivalent to the a and d keys.
 */
krpc_error_t krpc_SpaceCenter_Control_Yaw(krpc_connection_t connection, float * returnValue, krpc_SpaceCenter_Control_t instance);

/**
 * Returns whether all wheels on the vessel are deployed,
 * and sets the deployment state of all wheels.
 * Does not include landing legs.
 * See SpaceCenter::Wheel::deployed.
 */
krpc_error_t krpc_SpaceCenter_Control_set_Wheels(krpc_connection_t connection, krpc_SpaceCenter_Control_t instance, bool value);

/**
 * The state of RCS.
 */
krpc_error_t krpc_SpaceCenter_Control_RCS(krpc_connection_t connection, bool * returnValue, krpc_SpaceCenter_Control_t instance);

/**
 * The state of the lights.
 */
krpc_error_t krpc_SpaceCenter_Control_Lights(krpc_connection_t connection, bool * returnValue, krpc_SpaceCenter_Control_t instance);

/**
 * The control state of the vessel.
 */
krpc_error_t krpc_SpaceCenter_Control_State(krpc_connection_t connection, krpc_SpaceCenter_ControlState_t * returnValue, krpc_SpaceCenter_Control_t instance);

/**
 * The current SpaceCenter::SpeedMode of the navball.
 * This is the mode displayed next to the speed at the top of the navball.
 */
krpc_error_t krpc_SpaceCenter_Control_set_SpeedMode(krpc_connection_t connection, krpc_SpaceCenter_Control_t instance, krpc_SpaceCenter_SpeedMode_t value);

/**
 * The state of the wheel throttle.
 * A value between -1 and 1.
 * A value of 1 rotates the wheels forwards, a value of -1 rotates
 * the wheels backwards.
 */
krpc_error_t krpc_SpaceCenter_Control_WheelThrottle(krpc_connection_t connection, float * returnValue, krpc_SpaceCenter_Control_t instance);

/**
 * Returns whether all of the resource harvesters on the vessel are deployed,
 * and sets the deployment state of all resource harvesters.
 * See SpaceCenter::ResourceHarvester::deployed.
 */
krpc_error_t krpc_SpaceCenter_Control_ResourceHarvesters(krpc_connection_t connection, bool * returnValue, krpc_SpaceCenter_Control_t instance);

/**
 * The state of the forward translational control.
 * A value between -1 and 1.
 * Equivalent to the h and n keys.
 */
krpc_error_t krpc_SpaceCenter_Control_Forward(krpc_connection_t connection, float * returnValue, krpc_SpaceCenter_Control_t instance);

/**
 * The state of the wheel throttle.
 * A value between -1 and 1.
 * A value of 1 rotates the wheels forwards, a value of -1 rotates
 * the wheels backwards.
 */
krpc_error_t krpc_SpaceCenter_Control_set_WheelThrottle(krpc_connection_t connection, krpc_SpaceCenter_Control_t instance, float value);

/**
 * The state of the landing gear/legs.
 */
krpc_error_t krpc_SpaceCenter_Control_set_Gear(krpc_connection_t connection, krpc_SpaceCenter_Control_t instance, bool value);

/**
 * Returns whether all landing legs on the vessel are deployed,
 * and sets the deployment state of all landing legs.
 * Does not include wheels (for example landing gear).
 * See SpaceCenter::Leg::deployed.
 */
krpc_error_t krpc_SpaceCenter_Control_Legs(krpc_connection_t connection, bool * returnValue, krpc_SpaceCenter_Control_t instance);

/**
 * Returns a list of all existing maneuver nodes, ordered by time from first to last.
 */
krpc_error_t krpc_SpaceCenter_Control_Nodes(krpc_connection_t connection, krpc_list_object_t * returnValue, krpc_SpaceCenter_Control_t instance);

/**
 * Returns whether any of the cargo bays on the vessel are open,
 * and sets the open state of all cargo bays.
 * See SpaceCenter::CargoBay::open.
 */
krpc_error_t krpc_SpaceCenter_Control_set_CargoBays(krpc_connection_t connection, krpc_SpaceCenter_Control_t instance, bool value);

/**
 * The state of the landing gear/legs.
 */
krpc_error_t krpc_SpaceCenter_Control_Gear(krpc_connection_t connection, bool * returnValue, krpc_SpaceCenter_Control_t instance);

/**
 * The state of SAS.
 *
 * Equivalent to SpaceCenter::AutoPilot::sas
 */
krpc_error_t krpc_SpaceCenter_Control_SAS(krpc_connection_t connection, bool * returnValue, krpc_SpaceCenter_Control_t instance);

/**
 * Returns whether all of the resource harvesters on the vessel are deployed,
 * and sets the deployment state of all resource harvesters.
 * See SpaceCenter::ResourceHarvester::deployed.
 */
krpc_error_t krpc_SpaceCenter_Control_set_ResourceHarvesters(krpc_connection_t connection, krpc_SpaceCenter_Control_t instance, bool value);

/**
 * The state of the wheel steering.
 * A value between -1 and 1.
 * A value of 1 steers to the left, and a value of -1 steers to the right.
 */
krpc_error_t krpc_SpaceCenter_Control_WheelSteering(krpc_connection_t connection, float * returnValue, krpc_SpaceCenter_Control_t instance);

/**
 * Returns whether all wheels on the vessel are deployed,
 * and sets the deployment state of all wheels.
 * Does not include landing legs.
 * See SpaceCenter::Wheel::deployed.
 */
krpc_error_t krpc_SpaceCenter_Control_Wheels(krpc_connection_t connection, bool * returnValue, krpc_SpaceCenter_Control_t instance);

/**
 * Returns whether all radiators on the vessel are deployed,
 * and sets the deployment state of all radiators.
 * See SpaceCenter::Radiator::deployed.
 */
krpc_error_t krpc_SpaceCenter_Control_set_Radiators(krpc_connection_t connection, krpc_SpaceCenter_Control_t instance, bool value);

/**
 * The state of the roll control.
 * A value between -1 and 1.
 * Equivalent to the q and e keys.
 */
krpc_error_t krpc_SpaceCenter_Control_Roll(krpc_connection_t connection, float * returnValue, krpc_SpaceCenter_Control_t instance);

/**
 * Returns whether any of the resource harvesters on the vessel are active,
 * and sets the active state of all resource harvesters.
 * See SpaceCenter::ResourceHarvester::active.
 */
krpc_error_t krpc_SpaceCenter_Control_set_ResourceHarvestersActive(krpc_connection_t connection, krpc_SpaceCenter_Control_t instance, bool value);

/**
 * Returns whether any of the cargo bays on the vessel are open,
 * and sets the open state of all cargo bays.
 * See SpaceCenter::CargoBay::open.
 */
krpc_error_t krpc_SpaceCenter_Control_CargoBays(krpc_connection_t connection, bool * returnValue, krpc_SpaceCenter_Control_t instance);

/**
 * Returns whether any of the resource harvesters on the vessel are active,
 * and sets the active state of all resource harvesters.
 * See SpaceCenter::ResourceHarvester::active.
 */
krpc_error_t krpc_SpaceCenter_Control_ResourceHarvestersActive(krpc_connection_t connection, bool * returnValue, krpc_SpaceCenter_Control_t instance);

/**
 * Sets the behavior of the pitch, yaw, roll and translation control inputs.
 * When set to additive, these inputs are added to the vessels current inputs.
 * This mode is the default.
 * When set to override, these inputs (if non-zero) override the vessels inputs.
 * This mode prevents keyboard control, or SAS, from interfering with the controls when
 * they are set.
 */
krpc_error_t krpc_SpaceCenter_Control_InputMode(krpc_connection_t connection, krpc_SpaceCenter_ControlInputMode_t * returnValue, krpc_SpaceCenter_Control_t instance);

/**
 * The state of RCS.
 */
krpc_error_t krpc_SpaceCenter_Control_set_RCS(krpc_connection_t connection, krpc_SpaceCenter_Control_t instance, bool value);

/**
 * Returns whether all antennas on the vessel are deployed,
 * and sets the deployment state of all antennas.
 * See SpaceCenter::Antenna::deployed.
 */
krpc_error_t krpc_SpaceCenter_Control_Antennas(krpc_connection_t connection, bool * returnValue, krpc_SpaceCenter_Control_t instance);

/**
 * The state of the throttle. A value between 0 and 1.
 */
krpc_error_t krpc_SpaceCenter_Control_set_Throttle(krpc_connection_t connection, krpc_SpaceCenter_Control_t instance, float value);

/**
 * The current SpaceCenter::SASMode.
 * These modes are equivalent to the mode buttons to
 * the left of the navball that appear when SAS is enabled.
 *
 * Equivalent to SpaceCenter::AutoPilot::sas_mode
 */
krpc_error_t krpc_SpaceCenter_Control_SASMode(krpc_connection_t connection, krpc_SpaceCenter_SASMode_t * returnValue, krpc_SpaceCenter_Control_t instance);

/**
 * The current SpaceCenter::SpeedMode of the navball.
 * This is the mode displayed next to the speed at the top of the navball.
 */
krpc_error_t krpc_SpaceCenter_Control_SpeedMode(krpc_connection_t connection, krpc_SpaceCenter_SpeedMode_t * returnValue, krpc_SpaceCenter_Control_t instance);

/**
 * Returns whether all solar panels on the vessel are deployed,
 * and sets the deployment state of all solar panels.
 * See SpaceCenter::SolarPanel::deployed.
 */
krpc_error_t krpc_SpaceCenter_Control_set_SolarPanels(krpc_connection_t connection, krpc_SpaceCenter_Control_t instance, bool value);

/**
 * The state of the abort action group.
 */
krpc_error_t krpc_SpaceCenter_Control_set_Abort(krpc_connection_t connection, krpc_SpaceCenter_Control_t instance, bool value);

/**
 * The state of the throttle. A value between 0 and 1.
 */
krpc_error_t krpc_SpaceCenter_Control_Throttle(krpc_connection_t connection, float * returnValue, krpc_SpaceCenter_Control_t instance);

/**
 * Returns whether all reactive wheels on the vessel are active,
 * and sets the active state of all reaction wheels.
 * See SpaceCenter::ReactionWheel::active.
 */
krpc_error_t krpc_SpaceCenter_Control_set_ReactionWheels(krpc_connection_t connection, krpc_SpaceCenter_Control_t instance, bool value);

/**
 * Returns whether all parachutes on the vessel are deployed,
 * and sets the deployment state of all parachutes.
 * Cannot be set to false.
 * See SpaceCenter::Parachute::deployed.
 */
krpc_error_t krpc_SpaceCenter_Control_set_Parachutes(krpc_connection_t connection, krpc_SpaceCenter_Control_t instance, bool value);

/**
 * The state of the pitch control.
 * A value between -1 and 1.
 * Equivalent to the w and s keys.
 */
krpc_error_t krpc_SpaceCenter_Control_set_Pitch(krpc_connection_t connection, krpc_SpaceCenter_Control_t instance, float value);

/**
 * The state of the yaw control.
 * A value between -1 and 1.
 * Equivalent to the a and d keys.
 */
krpc_error_t krpc_SpaceCenter_Control_set_Yaw(krpc_connection_t connection, krpc_SpaceCenter_Control_t instance, float value);

/**
 * The state of the forward translational control.
 * A value between -1 and 1.
 * Equivalent to the h and n keys.
 */
krpc_error_t krpc_SpaceCenter_Control_set_Forward(krpc_connection_t connection, krpc_SpaceCenter_Control_t instance, float value);

/**
 * The state of the up translational control.
 * A value between -1 and 1.
 * Equivalent to the i and k keys.
 */
krpc_error_t krpc_SpaceCenter_Control_Up(krpc_connection_t connection, float * returnValue, krpc_SpaceCenter_Control_t instance);

/**
 * Returns whether all of the air intakes on the vessel are open,
 * and sets the open state of all air intakes.
 * See SpaceCenter::Intake::open.
 */
krpc_error_t krpc_SpaceCenter_Control_Intakes(krpc_connection_t connection, bool * returnValue, krpc_SpaceCenter_Control_t instance);

/**
 * Returns whether all parachutes on the vessel are deployed,
 * and sets the deployment state of all parachutes.
 * Cannot be set to false.
 * See SpaceCenter::Parachute::deployed.
 */
krpc_error_t krpc_SpaceCenter_Control_Parachutes(krpc_connection_t connection, bool * returnValue, krpc_SpaceCenter_Control_t instance);

/**
 * The state of the right translational control.
 * A value between -1 and 1.
 * Equivalent to the j and l keys.
 */
krpc_error_t krpc_SpaceCenter_Control_Right(krpc_connection_t connection, float * returnValue, krpc_SpaceCenter_Control_t instance);

/**
 * Returns whether all landing legs on the vessel are deployed,
 * and sets the deployment state of all landing legs.
 * Does not include wheels (for example landing gear).
 * See SpaceCenter::Leg::deployed.
 */
krpc_error_t krpc_SpaceCenter_Control_set_Legs(krpc_connection_t connection, krpc_SpaceCenter_Control_t instance, bool value);

/**
 * The state of SAS.
 *
 * Equivalent to SpaceCenter::AutoPilot::sas
 */
krpc_error_t krpc_SpaceCenter_Control_set_SAS(krpc_connection_t connection, krpc_SpaceCenter_Control_t instance, bool value);

/**
 * The state of the roll control.
 * A value between -1 and 1.
 * Equivalent to the q and e keys.
 */
krpc_error_t krpc_SpaceCenter_Control_set_Roll(krpc_connection_t connection, krpc_SpaceCenter_Control_t instance, float value);

/**
 * The state of the lights.
 */
krpc_error_t krpc_SpaceCenter_Control_set_Lights(krpc_connection_t connection, krpc_SpaceCenter_Control_t instance, bool value);

/**
 * The current stage of the vessel. Corresponds to the stage number in
 * the in-game UI.
 */
krpc_error_t krpc_SpaceCenter_Control_CurrentStage(krpc_connection_t connection, int32_t * returnValue, krpc_SpaceCenter_Control_t instance);

/**
 * The state of the wheel brakes.
 */
krpc_error_t krpc_SpaceCenter_Control_Brakes(krpc_connection_t connection, bool * returnValue, krpc_SpaceCenter_Control_t instance);

/**
 * Returns whether all antennas on the vessel are deployed,
 * and sets the deployment state of all antennas.
 * See SpaceCenter::Antenna::deployed.
 */
krpc_error_t krpc_SpaceCenter_Control_set_Antennas(krpc_connection_t connection, krpc_SpaceCenter_Control_t instance, bool value);

/**
 * The source of the vessels control, for example by a kerbal or a probe core.
 */
krpc_error_t krpc_SpaceCenter_Control_Source(krpc_connection_t connection, krpc_SpaceCenter_ControlSource_t * returnValue, krpc_SpaceCenter_Control_t instance);

/**
 * Sets the behavior of the pitch, yaw, roll and translation control inputs.
 * When set to additive, these inputs are added to the vessels current inputs.
 * This mode is the default.
 * When set to override, these inputs (if non-zero) override the vessels inputs.
 * This mode prevents keyboard control, or SAS, from interfering with the controls when
 * they are set.
 */
krpc_error_t krpc_SpaceCenter_Control_set_InputMode(krpc_connection_t connection, krpc_SpaceCenter_Control_t instance, krpc_SpaceCenter_ControlInputMode_t value);

/**
 * Returns whether all reactive wheels on the vessel are active,
 * and sets the active state of all reaction wheels.
 * See SpaceCenter::ReactionWheel::active.
 */
krpc_error_t krpc_SpaceCenter_Control_ReactionWheels(krpc_connection_t connection, bool * returnValue, krpc_SpaceCenter_Control_t instance);

/**
 * The state of the up translational control.
 * A value between -1 and 1.
 * Equivalent to the i and k keys.
 */
krpc_error_t krpc_SpaceCenter_Control_set_Up(krpc_connection_t connection, krpc_SpaceCenter_Control_t instance, float value);

/**
 * Returns whether all radiators on the vessel are deployed,
 * and sets the deployment state of all radiators.
 * See SpaceCenter::Radiator::deployed.
 */
krpc_error_t krpc_SpaceCenter_Control_Radiators(krpc_connection_t connection, bool * returnValue, krpc_SpaceCenter_Control_t instance);

/**
 * Returns whether all solar panels on the vessel are deployed,
 * and sets the deployment state of all solar panels.
 * See SpaceCenter::SolarPanel::deployed.
 */
krpc_error_t krpc_SpaceCenter_Control_SolarPanels(krpc_connection_t connection, bool * returnValue, krpc_SpaceCenter_Control_t instance);

/**
 * The state of the wheel steering.
 * A value between -1 and 1.
 * A value of 1 steers to the left, and a value of -1 steers to the right.
 */
krpc_error_t krpc_SpaceCenter_Control_set_WheelSteering(krpc_connection_t connection, krpc_SpaceCenter_Control_t instance, float value);

/**
 * The state of the abort action group.
 */
krpc_error_t krpc_SpaceCenter_Control_Abort(krpc_connection_t connection, bool * returnValue, krpc_SpaceCenter_Control_t instance);

/**
 * The state of the pitch control.
 * A value between -1 and 1.
 * Equivalent to the w and s keys.
 */
krpc_error_t krpc_SpaceCenter_Control_Pitch(krpc_connection_t connection, float * returnValue, krpc_SpaceCenter_Control_t instance);

/**
 * The current SpaceCenter::SASMode.
 * These modes are equivalent to the mode buttons to
 * the left of the navball that appear when SAS is enabled.
 *
 * Equivalent to SpaceCenter::AutoPilot::sas_mode
 */
krpc_error_t krpc_SpaceCenter_Control_set_SASMode(krpc_connection_t connection, krpc_SpaceCenter_Control_t instance, krpc_SpaceCenter_SASMode_t value);

/**
 * The authority limiter for the control surface, which controls how far the
 * control surface will move.
 */
krpc_error_t krpc_SpaceCenter_ControlSurface_AuthorityLimiter(krpc_connection_t connection, float * returnValue, krpc_SpaceCenter_ControlSurface_t instance);

/**
 * Whether the control surface has been fully deployed.
 */
krpc_error_t krpc_SpaceCenter_ControlSurface_set_Deployed(krpc_connection_t connection, krpc_SpaceCenter_ControlSurface_t instance, bool value);

/**
 * Whether the control surface has roll control enabled.
 */
krpc_error_t krpc_SpaceCenter_ControlSurface_RollEnabled(krpc_connection_t connection, bool * returnValue, krpc_SpaceCenter_ControlSurface_t instance);

/**
 * Whether the control surface movement is inverted.
 */
krpc_error_t krpc_SpaceCenter_ControlSurface_set_Inverted(krpc_connection_t connection, krpc_SpaceCenter_ControlSurface_t instance, bool value);

/**
 * Whether the control surface has pitch control enabled.
 */
krpc_error_t krpc_SpaceCenter_ControlSurface_PitchEnabled(krpc_connection_t connection, bool * returnValue, krpc_SpaceCenter_ControlSurface_t instance);

/**
 * The authority limiter for the control surface, which controls how far the
 * control surface will move.
 */
krpc_error_t krpc_SpaceCenter_ControlSurface_set_AuthorityLimiter(krpc_connection_t connection, krpc_SpaceCenter_ControlSurface_t instance, float value);

/**
 * Whether the control surface movement is inverted.
 */
krpc_error_t krpc_SpaceCenter_ControlSurface_Inverted(krpc_connection_t connection, bool * returnValue, krpc_SpaceCenter_ControlSurface_t instance);

/**
 * The part object for this control surface.
 */
krpc_error_t krpc_SpaceCenter_ControlSurface_Part(krpc_connection_t connection, krpc_SpaceCenter_Part_t * returnValue, krpc_SpaceCenter_ControlSurface_t instance);

/**
 * Whether the control surface has roll control enabled.
 */
krpc_error_t krpc_SpaceCenter_ControlSurface_set_RollEnabled(krpc_connection_t connection, krpc_SpaceCenter_ControlSurface_t instance, bool value);

/**
 * Whether the control surface has pitch control enabled.
 */
krpc_error_t krpc_SpaceCenter_ControlSurface_set_PitchEnabled(krpc_connection_t connection, krpc_SpaceCenter_ControlSurface_t instance, bool value);

/**
 * Surface area of the control surface in m^2.
 */
krpc_error_t krpc_SpaceCenter_ControlSurface_SurfaceArea(krpc_connection_t connection, float * returnValue, krpc_SpaceCenter_ControlSurface_t instance);

/**
 * Whether the control surface has yaw control enabled.
 */
krpc_error_t krpc_SpaceCenter_ControlSurface_YawEnabled(krpc_connection_t connection, bool * returnValue, krpc_SpaceCenter_ControlSurface_t instance);

/**
 * The available torque, in Newton meters, that can be produced by this control surface,
 * in the positive and negative pitch, roll and yaw axes of the vessel. These axes
 * correspond to the coordinate axes of the SpaceCenter::Vessel::reference_frame.
 */
krpc_error_t krpc_SpaceCenter_ControlSurface_AvailableTorque(krpc_connection_t connection, krpc_tuple_tuple_double_double_double_tuple_double_double_double_t * returnValue, krpc_SpaceCenter_ControlSurface_t instance);

/**
 * Whether the control surface has been fully deployed.
 */
krpc_error_t krpc_SpaceCenter_ControlSurface_Deployed(krpc_connection_t connection, bool * returnValue, krpc_SpaceCenter_ControlSurface_t instance);

/**
 * Whether the control surface has yaw control enabled.
 */
krpc_error_t krpc_SpaceCenter_ControlSurface_set_YawEnabled(krpc_connection_t connection, krpc_SpaceCenter_ControlSurface_t instance, bool value);

/**
 * The crew members stupidity.
 */
krpc_error_t krpc_SpaceCenter_CrewMember_set_Stupidity(krpc_connection_t connection, krpc_SpaceCenter_CrewMember_t instance, float value);

/**
 * The crew members name.
 */
krpc_error_t krpc_SpaceCenter_CrewMember_set_Name(krpc_connection_t connection, krpc_SpaceCenter_CrewMember_t instance, const char * value);

/**
 * The crew members experience.
 */
krpc_error_t krpc_SpaceCenter_CrewMember_set_Experience(krpc_connection_t connection, krpc_SpaceCenter_CrewMember_t instance, float value);

/**
 * Whether the crew member is on a mission.
 */
krpc_error_t krpc_SpaceCenter_CrewMember_OnMission(krpc_connection_t connection, bool * returnValue, krpc_SpaceCenter_CrewMember_t instance);

/**
 * Whether the crew member is a veteran.
 */
krpc_error_t krpc_SpaceCenter_CrewMember_Veteran(krpc_connection_t connection, bool * returnValue, krpc_SpaceCenter_CrewMember_t instance);

/**
 * The crew members experience.
 */
krpc_error_t krpc_SpaceCenter_CrewMember_Experience(krpc_connection_t connection, float * returnValue, krpc_SpaceCenter_CrewMember_t instance);

/**
 * The crew members stupidity.
 */
krpc_error_t krpc_SpaceCenter_CrewMember_Stupidity(krpc_connection_t connection, float * returnValue, krpc_SpaceCenter_CrewMember_t instance);

/**
 * The crew members courage.
 */
krpc_error_t krpc_SpaceCenter_CrewMember_Courage(krpc_connection_t connection, float * returnValue, krpc_SpaceCenter_CrewMember_t instance);

/**
 * The crew members courage.
 */
krpc_error_t krpc_SpaceCenter_CrewMember_set_Courage(krpc_connection_t connection, krpc_SpaceCenter_CrewMember_t instance, float value);

/**
 * Whether the crew member is a badass.
 */
krpc_error_t krpc_SpaceCenter_CrewMember_set_Badass(krpc_connection_t connection, krpc_SpaceCenter_CrewMember_t instance, bool value);

/**
 * Whether the crew member is a badass.
 */
krpc_error_t krpc_SpaceCenter_CrewMember_Badass(krpc_connection_t connection, bool * returnValue, krpc_SpaceCenter_CrewMember_t instance);

/**
 * Whether the crew member is a veteran.
 */
krpc_error_t krpc_SpaceCenter_CrewMember_set_Veteran(krpc_connection_t connection, krpc_SpaceCenter_CrewMember_t instance, bool value);

/**
 * The type of crew member.
 */
krpc_error_t krpc_SpaceCenter_CrewMember_Type(krpc_connection_t connection, krpc_SpaceCenter_CrewMemberType_t * returnValue, krpc_SpaceCenter_CrewMember_t instance);

/**
 * The crew members name.
 */
krpc_error_t krpc_SpaceCenter_CrewMember_Name(krpc_connection_t connection, char * * returnValue, krpc_SpaceCenter_CrewMember_t instance);

/**
 * Fires the decoupler. Returns the new vessel created when the decoupler fires.
 * Throws an exception if the decoupler has already fired.
 *
 * When called, the active vessel may change. It is therefore possible that,
 * after calling this function, the object(s) returned by previous call(s) to
 * SpaceCenter::active_vessel no longer refer to the active vessel.
 */
krpc_error_t krpc_SpaceCenter_Decoupler_Decouple(krpc_connection_t connection, krpc_SpaceCenter_Vessel_t * returnValue, krpc_SpaceCenter_Decoupler_t instance);

/**
 * The part object for this decoupler.
 */
krpc_error_t krpc_SpaceCenter_Decoupler_Part(krpc_connection_t connection, krpc_SpaceCenter_Part_t * returnValue, krpc_SpaceCenter_Decoupler_t instance);

/**
 * Whether the decoupler is enabled in the staging sequence.
 */
krpc_error_t krpc_SpaceCenter_Decoupler_Staged(krpc_connection_t connection, bool * returnValue, krpc_SpaceCenter_Decoupler_t instance);

/**
 * The impulse that the decoupler imparts when it is fired, in Newton seconds.
 */
krpc_error_t krpc_SpaceCenter_Decoupler_Impulse(krpc_connection_t connection, float * returnValue, krpc_SpaceCenter_Decoupler_t instance);

/**
 * Whether the decoupler has fired.
 */
krpc_error_t krpc_SpaceCenter_Decoupler_Decoupled(krpc_connection_t connection, bool * returnValue, krpc_SpaceCenter_Decoupler_t instance);

/**
 * The direction that docking port points in, in the given reference frame.
 * @return The direction as a unit vector.
 * @param referenceFrame The reference frame that the returned
 * direction is in.
 */
krpc_error_t krpc_SpaceCenter_DockingPort_Direction(krpc_connection_t connection, krpc_tuple_double_double_double_t * returnValue, krpc_SpaceCenter_DockingPort_t instance, krpc_SpaceCenter_ReferenceFrame_t referenceFrame);

/**
 * The position of the docking port, in the given reference frame.
 * @return The position as a vector.
 * @param referenceFrame The reference frame that the returned
 * position vector is in.
 */
krpc_error_t krpc_SpaceCenter_DockingPort_Position(krpc_connection_t connection, krpc_tuple_double_double_double_t * returnValue, krpc_SpaceCenter_DockingPort_t instance, krpc_SpaceCenter_ReferenceFrame_t referenceFrame);

/**
 * The rotation of the docking port, in the given reference frame.
 * @return The rotation as a quaternion of the form (x, y, z, w).
 * @param referenceFrame The reference frame that the returned
 * rotation is in.
 */
krpc_error_t krpc_SpaceCenter_DockingPort_Rotation(krpc_connection_t connection, krpc_tuple_double_double_double_double_t * returnValue, krpc_SpaceCenter_DockingPort_t instance, krpc_SpaceCenter_ReferenceFrame_t referenceFrame);

/**
 * Undocks the docking port and returns the new SpaceCenter::Vessel that is created.
 * This method can be called for either docking port in a docked pair.
 * Throws an exception if the docking port is not docked to anything.
 *
 * When called, the active vessel may change. It is therefore possible that,
 * after calling this function, the object(s) returned by previous call(s) to
 * SpaceCenter::active_vessel no longer refer to the active vessel.
 */
krpc_error_t krpc_SpaceCenter_DockingPort_Undock(krpc_connection_t connection, krpc_SpaceCenter_Vessel_t * returnValue, krpc_SpaceCenter_DockingPort_t instance);

/**
 * Whether the docking port has a shield.
 */
krpc_error_t krpc_SpaceCenter_DockingPort_HasShield(krpc_connection_t connection, bool * returnValue, krpc_SpaceCenter_DockingPort_t instance);

/**
 * The reference frame that is fixed relative to this docking port, and
 * oriented with the port.
 *
 * - The origin is at the position of the docking port.
 * - The axes rotate with the docking port.
 * - The x-axis points out to the right side of the docking port.
 * - The y-axis points in the direction the docking port is facing.
 * - The z-axis points out of the bottom off the docking port.
 *
 * This reference frame is not necessarily equivalent to the reference frame
 * for the part, returned by SpaceCenter::Part::reference_frame.
 */
krpc_error_t krpc_SpaceCenter_DockingPort_ReferenceFrame(krpc_connection_t connection, krpc_SpaceCenter_ReferenceFrame_t * returnValue, krpc_SpaceCenter_DockingPort_t instance);

/**
 * The part that this docking port is docked to. Returns null if this
 * docking port is not docked to anything.
 */
krpc_error_t krpc_SpaceCenter_DockingPort_DockedPart(krpc_connection_t connection, krpc_SpaceCenter_Part_t * returnValue, krpc_SpaceCenter_DockingPort_t instance);

/**
 * The state of the docking ports shield, if it has one.
 *
 * Returns true if the docking port has a shield, and the shield is
 * closed. Otherwise returns false. When set to true, the shield is
 * closed, and when set to false the shield is opened. If the docking
 * port does not have a shield, setting this attribute has no effect.
 */
krpc_error_t krpc_SpaceCenter_DockingPort_Shielded(krpc_connection_t connection, bool * returnValue, krpc_SpaceCenter_DockingPort_t instance);

/**
 * The state of the docking ports shield, if it has one.
 *
 * Returns true if the docking port has a shield, and the shield is
 * closed. Otherwise returns false. When set to true, the shield is
 * closed, and when set to false the shield is opened. If the docking
 * port does not have a shield, setting this attribute has no effect.
 */
krpc_error_t krpc_SpaceCenter_DockingPort_set_Shielded(krpc_connection_t connection, krpc_SpaceCenter_DockingPort_t instance, bool value);

/**
 * The current state of the docking port.
 */
krpc_error_t krpc_SpaceCenter_DockingPort_State(krpc_connection_t connection, krpc_SpaceCenter_DockingPortState_t * returnValue, krpc_SpaceCenter_DockingPort_t instance);

/**
 * The part object for this docking port.
 */
krpc_error_t krpc_SpaceCenter_DockingPort_Part(krpc_connection_t connection, krpc_SpaceCenter_Part_t * returnValue, krpc_SpaceCenter_DockingPort_t instance);

/**
 * The distance a docking port must move away when it undocks before it
 * becomes ready to dock with another port, in meters.
 */
krpc_error_t krpc_SpaceCenter_DockingPort_ReengageDistance(krpc_connection_t connection, float * returnValue, krpc_SpaceCenter_DockingPort_t instance);

/**
 * Toggle the current engine mode.
 */
krpc_error_t krpc_SpaceCenter_Engine_ToggleMode(krpc_connection_t connection, krpc_SpaceCenter_Engine_t instance);

/**
 * Whether the engine has multiple modes of operation.
 */
krpc_error_t krpc_SpaceCenter_Engine_HasModes(krpc_connection_t connection, bool * returnValue, krpc_SpaceCenter_Engine_t instance);

/**
 * The maximum amount of thrust that can be produced by the engine in a
 * vacuum, in Newtons. This is the amount of thrust produced by the engine
 * when activated, SpaceCenter::Engine::thrust_limit is set to 100%, the main
 * vessel's throttle is set to 100% and the engine is in a vacuum.
 */
krpc_error_t krpc_SpaceCenter_Engine_MaxVacuumThrust(krpc_connection_t connection, float * returnValue, krpc_SpaceCenter_Engine_t instance);

/**
 * The name of the current engine mode.
 */
krpc_error_t krpc_SpaceCenter_Engine_set_Mode(krpc_connection_t connection, krpc_SpaceCenter_Engine_t instance, const char * value);

/**
 * Whether the engine can be shutdown once activated. For example, this is
 * true for liquid fueled rockets and false for solid rocket boosters.
 */
krpc_error_t krpc_SpaceCenter_Engine_CanShutdown(krpc_connection_t connection, bool * returnValue, krpc_SpaceCenter_Engine_t instance);

/**
 * The thrust limiter of the engine. A value between 0 and 1. Setting this
 * attribute may have no effect, for example the thrust limit for a solid
 * rocket booster cannot be changed in flight.
 */
krpc_error_t krpc_SpaceCenter_Engine_ThrustLimit(krpc_connection_t connection, float * returnValue, krpc_SpaceCenter_Engine_t instance);

/**
 * The current throttle setting for the engine. A value between 0 and 1.
 * This is not necessarily the same as the vessel's main throttle
 * setting, as some engines take time to adjust their throttle
 * (such as jet engines).
 */
krpc_error_t krpc_SpaceCenter_Engine_Throttle(krpc_connection_t connection, float * returnValue, krpc_SpaceCenter_Engine_t instance);

/**
 * Whether the engine will automatically switch modes.
 */
krpc_error_t krpc_SpaceCenter_Engine_AutoModeSwitch(krpc_connection_t connection, bool * returnValue, krpc_SpaceCenter_Engine_t instance);

/**
 * The vacuum specific impulse of the engine, in seconds.
 */
krpc_error_t krpc_SpaceCenter_Engine_VacuumSpecificImpulse(krpc_connection_t connection, float * returnValue, krpc_SpaceCenter_Engine_t instance);

/**
 * The available torque, in Newton meters, that can be produced by this engine,
 * in the positive and negative pitch, roll and yaw axes of the vessel. These axes
 * correspond to the coordinate axes of the SpaceCenter::Vessel::reference_frame.
 * Returns zero if the engine is inactive, or not gimballed.
 */
krpc_error_t krpc_SpaceCenter_Engine_AvailableTorque(krpc_connection_t connection, krpc_tuple_tuple_double_double_double_tuple_double_double_double_t * returnValue, krpc_SpaceCenter_Engine_t instance);

/**
 * The amount of thrust, in Newtons, that would be produced by the engine
 * when activated and fueled, with its throttle and throttle limiter set to 100%.
 */
krpc_error_t krpc_SpaceCenter_Engine_MaxThrust(krpc_connection_t connection, float * returnValue, krpc_SpaceCenter_Engine_t instance);

/**
 * The ratio of resources that the engine consumes. A dictionary mapping resource names
 * to the ratio at which they are consumed by the engine.
 *
 * For example, if the ratios are 0.6 for LiquidFuel and 0.4 for Oxidizer, then for every
 * 0.6 units of LiquidFuel that the engine burns, it will burn 0.4 units of Oxidizer.
 */
krpc_error_t krpc_SpaceCenter_Engine_PropellantRatios(krpc_connection_t connection, krpc_dictionary_string_float_t * returnValue, krpc_SpaceCenter_Engine_t instance);

/**
 * The part object for this engine.
 */
krpc_error_t krpc_SpaceCenter_Engine_Part(krpc_connection_t connection, krpc_SpaceCenter_Part_t * returnValue, krpc_SpaceCenter_Engine_t instance);

/**
 * The components of the engine that generate thrust.
 *
 * For example, this corresponds to the rocket nozzel on a solid rocket booster,
 * or the individual nozzels on a RAPIER engine.
 * The overall thrust produced by the engine, as reported by SpaceCenter::Engine::available_thrust,
 * SpaceCenter::Engine::max_thrust and others, is the sum of the thrust generated by each thruster.
 */
krpc_error_t krpc_SpaceCenter_Engine_Thrusters(krpc_connection_t connection, krpc_list_object_t * returnValue, krpc_SpaceCenter_Engine_t instance);

/**
 * Whether the engine is active. Setting this attribute may have no effect,
 * depending on SpaceCenter::Engine::can_shutdown and SpaceCenter::Engine::can_restart.
 */
krpc_error_t krpc_SpaceCenter_Engine_Active(krpc_connection_t connection, bool * returnValue, krpc_SpaceCenter_Engine_t instance);

/**
 * Whether the engine will automatically switch modes.
 */
krpc_error_t krpc_SpaceCenter_Engine_set_AutoModeSwitch(krpc_connection_t connection, krpc_SpaceCenter_Engine_t instance, bool value);

/**
 * Whether the engine can be restarted once shutdown. If the engine cannot be shutdown,
 * returns false. For example, this is true for liquid fueled rockets
 * and false for solid rocket boosters.
 */
krpc_error_t krpc_SpaceCenter_Engine_CanRestart(krpc_connection_t connection, bool * returnValue, krpc_SpaceCenter_Engine_t instance);

/**
 * Whether the engine has any fuel available.
 *
 * The engine must be activated for this property to update correctly.
 */
krpc_error_t krpc_SpaceCenter_Engine_HasFuel(krpc_connection_t connection, bool * returnValue, krpc_SpaceCenter_Engine_t instance);

/**
 * The amount of thrust, in Newtons, that would be produced by the engine
 * when activated and with its throttle set to 100%.
 * Returns zero if the engine does not have any fuel.
 * Takes the engine's current SpaceCenter::Engine::thrust_limit and atmospheric conditions
 * into account.
 */
krpc_error_t krpc_SpaceCenter_Engine_AvailableThrust(krpc_connection_t connection, float * returnValue, krpc_SpaceCenter_Engine_t instance);

/**
 * The available modes for the engine.
 * A dictionary mapping mode names to SpaceCenter::Engine objects.
 */
krpc_error_t krpc_SpaceCenter_Engine_Modes(krpc_connection_t connection, krpc_dictionary_string_object_t * returnValue, krpc_SpaceCenter_Engine_t instance);

/**
 * Whether the engine is active. Setting this attribute may have no effect,
 * depending on SpaceCenter::Engine::can_shutdown and SpaceCenter::Engine::can_restart.
 */
krpc_error_t krpc_SpaceCenter_Engine_set_Active(krpc_connection_t connection, krpc_SpaceCenter_Engine_t instance, bool value);

/**
 * The gimbal limiter of the engine. A value between 0 and 1.
 * Returns 0 if the gimbal is locked.
 */
krpc_error_t krpc_SpaceCenter_Engine_GimbalLimit(krpc_connection_t connection, float * returnValue, krpc_SpaceCenter_Engine_t instance);

/**
 * The current amount of thrust being produced by the engine, in Newtons.
 */
krpc_error_t krpc_SpaceCenter_Engine_Thrust(krpc_connection_t connection, float * returnValue, krpc_SpaceCenter_Engine_t instance);

/**
 * The gimbal limiter of the engine. A value between 0 and 1.
 * Returns 0 if the gimbal is locked.
 */
krpc_error_t krpc_SpaceCenter_Engine_set_GimbalLimit(krpc_connection_t connection, krpc_SpaceCenter_Engine_t instance, float value);

/**
 * The specific impulse of the engine at sea level on Kerbin, in seconds.
 */
krpc_error_t krpc_SpaceCenter_Engine_KerbinSeaLevelSpecificImpulse(krpc_connection_t connection, float * returnValue, krpc_SpaceCenter_Engine_t instance);

/**
 * The names of the propellants that the engine consumes.
 */
krpc_error_t krpc_SpaceCenter_Engine_PropellantNames(krpc_connection_t connection, krpc_list_string_t * returnValue, krpc_SpaceCenter_Engine_t instance);

/**
 * Whether the engine is gimballed.
 */
krpc_error_t krpc_SpaceCenter_Engine_Gimballed(krpc_connection_t connection, bool * returnValue, krpc_SpaceCenter_Engine_t instance);

/**
 * Whether the engines gimbal is locked in place. Setting this attribute has
 * no effect if the engine is not gimballed.
 */
krpc_error_t krpc_SpaceCenter_Engine_set_GimbalLocked(krpc_connection_t connection, krpc_SpaceCenter_Engine_t instance, bool value);

/**
 * Whether the SpaceCenter::Control::throttle affects the engine. For example,
 * this is true for liquid fueled rockets, and false for solid rocket
 * boosters.
 */
krpc_error_t krpc_SpaceCenter_Engine_ThrottleLocked(krpc_connection_t connection, bool * returnValue, krpc_SpaceCenter_Engine_t instance);

/**
 * The current specific impulse of the engine, in seconds. Returns zero
 * if the engine is not active.
 */
krpc_error_t krpc_SpaceCenter_Engine_SpecificImpulse(krpc_connection_t connection, float * returnValue, krpc_SpaceCenter_Engine_t instance);

/**
 * The range over which the gimbal can move, in degrees.
 * Returns 0 if the engine is not gimballed.
 */
krpc_error_t krpc_SpaceCenter_Engine_GimbalRange(krpc_connection_t connection, float * returnValue, krpc_SpaceCenter_Engine_t instance);

/**
 * The propellants that the engine consumes.
 */
krpc_error_t krpc_SpaceCenter_Engine_Propellants(krpc_connection_t connection, krpc_list_object_t * returnValue, krpc_SpaceCenter_Engine_t instance);

/**
 * Whether the engines gimbal is locked in place. Setting this attribute has
 * no effect if the engine is not gimballed.
 */
krpc_error_t krpc_SpaceCenter_Engine_GimbalLocked(krpc_connection_t connection, bool * returnValue, krpc_SpaceCenter_Engine_t instance);

/**
 * The thrust limiter of the engine. A value between 0 and 1. Setting this
 * attribute may have no effect, for example the thrust limit for a solid
 * rocket booster cannot be changed in flight.
 */
krpc_error_t krpc_SpaceCenter_Engine_set_ThrustLimit(krpc_connection_t connection, krpc_SpaceCenter_Engine_t instance, float value);

/**
 * The name of the current engine mode.
 */
krpc_error_t krpc_SpaceCenter_Engine_Mode(krpc_connection_t connection, char * * returnValue, krpc_SpaceCenter_Engine_t instance);

/**
 * Dump the experimental data contained by the experiment.
 */
krpc_error_t krpc_SpaceCenter_Experiment_Dump(krpc_connection_t connection, krpc_SpaceCenter_Experiment_t instance);

/**
 * Reset the experiment.
 */
krpc_error_t krpc_SpaceCenter_Experiment_Reset(krpc_connection_t connection, krpc_SpaceCenter_Experiment_t instance);

/**
 * Run the experiment.
 */
krpc_error_t krpc_SpaceCenter_Experiment_Run(krpc_connection_t connection, krpc_SpaceCenter_Experiment_t instance);

/**
 * Transmit all experimental data contained by this part.
 */
krpc_error_t krpc_SpaceCenter_Experiment_Transmit(krpc_connection_t connection, krpc_SpaceCenter_Experiment_t instance);

/**
 * Determines if the experiment is available given the current conditions.
 */
krpc_error_t krpc_SpaceCenter_Experiment_Available(krpc_connection_t connection, bool * returnValue, krpc_SpaceCenter_Experiment_t instance);

/**
 * The name of the biome the experiment is currently in.
 */
krpc_error_t krpc_SpaceCenter_Experiment_Biome(krpc_connection_t connection, char * * returnValue, krpc_SpaceCenter_Experiment_t instance);

/**
 * Containing information on the corresponding specific science result for the current
 * conditions. Returns null if the experiment is unavailable.
 */
krpc_error_t krpc_SpaceCenter_Experiment_ScienceSubject(krpc_connection_t connection, krpc_SpaceCenter_ScienceSubject_t * returnValue, krpc_SpaceCenter_Experiment_t instance);

/**
 * Whether the experiment is inoperable.
 */
krpc_error_t krpc_SpaceCenter_Experiment_Inoperable(krpc_connection_t connection, bool * returnValue, krpc_SpaceCenter_Experiment_t instance);

/**
 * The part object for this experiment.
 */
krpc_error_t krpc_SpaceCenter_Experiment_Part(krpc_connection_t connection, krpc_SpaceCenter_Part_t * returnValue, krpc_SpaceCenter_Experiment_t instance);

/**
 * Whether the experiment contains data.
 */
krpc_error_t krpc_SpaceCenter_Experiment_HasData(krpc_connection_t connection, bool * returnValue, krpc_SpaceCenter_Experiment_t instance);

/**
 * Whether the experiment can be re-run.
 */
krpc_error_t krpc_SpaceCenter_Experiment_Rerunnable(krpc_connection_t connection, bool * returnValue, krpc_SpaceCenter_Experiment_t instance);

/**
 * The data contained in this experiment.
 */
krpc_error_t krpc_SpaceCenter_Experiment_Data(krpc_connection_t connection, krpc_list_object_t * returnValue, krpc_SpaceCenter_Experiment_t instance);

/**
 * Whether the experiment has been deployed.
 */
krpc_error_t krpc_SpaceCenter_Experiment_Deployed(krpc_connection_t connection, bool * returnValue, krpc_SpaceCenter_Experiment_t instance);

/**
 * Jettison the fairing. Has no effect if it has already been jettisoned.
 */
krpc_error_t krpc_SpaceCenter_Fairing_Jettison(krpc_connection_t connection, krpc_SpaceCenter_Fairing_t instance);

/**
 * The part object for this fairing.
 */
krpc_error_t krpc_SpaceCenter_Fairing_Part(krpc_connection_t connection, krpc_SpaceCenter_Part_t * returnValue, krpc_SpaceCenter_Fairing_t instance);

/**
 * Whether the fairing has been jettisoned.
 */
krpc_error_t krpc_SpaceCenter_Fairing_Jettisoned(krpc_connection_t connection, bool * returnValue, krpc_SpaceCenter_Fairing_t instance);

/**
 * Simulate and return the total aerodynamic forces acting on the vessel,
 * if it where to be traveling with the given velocity at the given position in the
 * atmosphere of the given celestial body.
 * @return A vector pointing in the direction that the force acts,
 * with its magnitude equal to the strength of the force in Newtons.
 */
krpc_error_t krpc_SpaceCenter_Flight_SimulateAerodynamicForceAt(krpc_connection_t connection, krpc_tuple_double_double_double_t * returnValue, krpc_SpaceCenter_Flight_t instance, krpc_SpaceCenter_CelestialBody_t body, const krpc_tuple_double_double_double_t * position, const krpc_tuple_double_double_double_t * velocity);

/**
 * The rotation of the vessel, in the reference frame SpaceCenter::ReferenceFrame
 * @return The rotation as a quaternion of the form (x, y, z, w).
 */
krpc_error_t krpc_SpaceCenter_Flight_Rotation(krpc_connection_t connection, krpc_tuple_double_double_double_double_t * returnValue, krpc_SpaceCenter_Flight_t instance);

/**
 * The horizontal speed of the vessel in meters per second,
 * in the reference frame SpaceCenter::ReferenceFrame.
 */
krpc_error_t krpc_SpaceCenter_Flight_HorizontalSpeed(krpc_connection_t connection, double * returnValue, krpc_SpaceCenter_Flight_t instance);

/**
 * The coefficient of drag. This is the amount of drag produced by the vessel.
 * It depends on air speed, air density and wing area.
 *
 * Requires <a href="https://forum.kerbalspaceprogram.com/index.php?/topic/19321-130-ferram-aerospace-research-v0159-liebe-82117/">Ferram Aerospace Research</a>.
 */
krpc_error_t krpc_SpaceCenter_Flight_DragCoefficient(krpc_connection_t connection, float * returnValue, krpc_SpaceCenter_Flight_t instance);

/**
 * The pitch angle between the orientation of the vessel and its velocity vector,
 * in degrees.
 */
krpc_error_t krpc_SpaceCenter_Flight_AngleOfAttack(krpc_connection_t connection, float * returnValue, krpc_SpaceCenter_Flight_t instance);

/**
 * The <a href="https://en.wikipedia.org/wiki/Total_air_temperature">total air temperature</a>
 * of the atmosphere around the vessel, in Kelvin.
 * This includes the SpaceCenter::Flight::static_air_temperature and the vessel's kinetic energy.
 */
krpc_error_t krpc_SpaceCenter_Flight_TotalAirTemperature(krpc_connection_t connection, float * returnValue, krpc_SpaceCenter_Flight_t instance);

/**
 * The vessels Reynolds number.
 *
 * Requires <a href="https://forum.kerbalspaceprogram.com/index.php?/topic/19321-130-ferram-aerospace-research-v0159-liebe-82117/">Ferram Aerospace Research</a>.
 */
krpc_error_t krpc_SpaceCenter_Flight_ReynoldsNumber(krpc_connection_t connection, float * returnValue, krpc_SpaceCenter_Flight_t instance);

/**
 * The speed of sound, in the atmosphere around the vessel, in m/s.
 */
krpc_error_t krpc_SpaceCenter_Flight_SpeedOfSound(krpc_connection_t connection, float * returnValue, krpc_SpaceCenter_Flight_t instance);

/**
 * The radial direction of the vessels orbit,
 * in the reference frame SpaceCenter::ReferenceFrame.
 * @return The direction as a unit vector.
 */
krpc_error_t krpc_SpaceCenter_Flight_Radial(krpc_connection_t connection, krpc_tuple_double_double_double_t * returnValue, krpc_SpaceCenter_Flight_t instance);

/**
 * The velocity of the vessel, in the reference frame SpaceCenter::ReferenceFrame.
 * @return The velocity as a vector. The vector points in the direction of travel,
 * and its magnitude is the speed of the vessel in meters per second.
 */
krpc_error_t krpc_SpaceCenter_Flight_Velocity(krpc_connection_t connection, krpc_tuple_double_double_double_t * returnValue, krpc_SpaceCenter_Flight_t instance);

/**
 * The <a href="https://en.wikipedia.org/wiki/Latitude">latitude</a> of the vessel for the body being orbited, in degrees.
 */
krpc_error_t krpc_SpaceCenter_Flight_Latitude(krpc_connection_t connection, double * returnValue, krpc_SpaceCenter_Flight_t instance);

/**
 * An estimate of the current terminal velocity of the vessel, in meters per second.
 * This is the speed at which the drag forces cancel out the force of gravity.
 */
krpc_error_t krpc_SpaceCenter_Flight_TerminalVelocity(krpc_connection_t connection, float * returnValue, krpc_SpaceCenter_Flight_t instance);

/**
 * The roll of the vessel relative to the horizon, in degrees.
 * A value between -180° and +180°.
 */
krpc_error_t krpc_SpaceCenter_Flight_Roll(krpc_connection_t connection, float * returnValue, krpc_SpaceCenter_Flight_t instance);

/**
 * The direction that the vessel is pointing in,
 * in the reference frame SpaceCenter::ReferenceFrame.
 * @return The direction as a unit vector.
 */
krpc_error_t krpc_SpaceCenter_Flight_Direction(krpc_connection_t connection, krpc_tuple_double_double_double_t * returnValue, krpc_SpaceCenter_Flight_t instance);

/**
 * The elevation of the terrain under the vessel, in meters. This is the height of the terrain above sea level,
 * and is negative when the vessel is over the sea.
 */
krpc_error_t krpc_SpaceCenter_Flight_Elevation(krpc_connection_t connection, double * returnValue, krpc_SpaceCenter_Flight_t instance);

/**
 * The current amount of stall, between 0 and 1. A value greater than 0.005 indicates
 * a minor stall and a value greater than 0.5 indicates a large-scale stall.
 *
 * Requires <a href="https://forum.kerbalspaceprogram.com/index.php?/topic/19321-130-ferram-aerospace-research-v0159-liebe-82117/">Ferram Aerospace Research</a>.
 */
krpc_error_t krpc_SpaceCenter_Flight_StallFraction(krpc_connection_t connection, float * returnValue, krpc_SpaceCenter_Flight_t instance);

/**
 * The direction normal to the vessels orbit,
 * in the reference frame SpaceCenter::ReferenceFrame.
 * @return The direction as a unit vector.
 */
krpc_error_t krpc_SpaceCenter_Flight_Normal(krpc_connection_t connection, krpc_tuple_double_double_double_t * returnValue, krpc_SpaceCenter_Flight_t instance);

/**
 * The direction opposite to the radial direction of the vessels orbit,
 * in the reference frame SpaceCenter::ReferenceFrame.
 * @return The direction as a unit vector.
 */
krpc_error_t krpc_SpaceCenter_Flight_AntiRadial(krpc_connection_t connection, krpc_tuple_double_double_double_t * returnValue, krpc_SpaceCenter_Flight_t instance);

/**
 * The static atmospheric pressure acting on the vessel, in Pascals.
 */
krpc_error_t krpc_SpaceCenter_Flight_StaticPressure(krpc_connection_t connection, float * returnValue, krpc_SpaceCenter_Flight_t instance);

/**
 * The position of the center of mass of the vessel,
 * in the reference frame SpaceCenter::ReferenceFrame
 * @return The position as a vector.
 */
krpc_error_t krpc_SpaceCenter_Flight_CenterOfMass(krpc_connection_t connection, krpc_tuple_double_double_double_t * returnValue, krpc_SpaceCenter_Flight_t instance);

/**
 * The <a href="https://en.wikipedia.org/wiki/Aerodynamic_force">aerodynamic drag</a> currently acting on the vessel.
 * @return A vector pointing in the direction of the force, with its magnitude
 * equal to the strength of the force in Newtons.
 */
krpc_error_t krpc_SpaceCenter_Flight_Drag(krpc_connection_t connection, krpc_tuple_double_double_double_t * returnValue, krpc_SpaceCenter_Flight_t instance);

/**
 * The <a href="https://en.wikipedia.org/wiki/Aerodynamic_force">aerodynamic lift</a>
 * currently acting on the vessel.
 * @return A vector pointing in the direction that the force acts,
 * with its magnitude equal to the strength of the force in Newtons.
 */
krpc_error_t krpc_SpaceCenter_Flight_Lift(krpc_connection_t connection, krpc_tuple_double_double_double_t * returnValue, krpc_SpaceCenter_Flight_t instance);

/**
 * The current G force acting on the vessel in m/s^2.
 */
krpc_error_t krpc_SpaceCenter_Flight_GForce(krpc_connection_t connection, float * returnValue, krpc_SpaceCenter_Flight_t instance);

/**
 * The <a href="https://en.wikipedia.org/wiki/Total_air_temperature">static (ambient)
 * temperature</a> of the atmosphere around the vessel, in Kelvin.
 */
krpc_error_t krpc_SpaceCenter_Flight_StaticAirTemperature(krpc_connection_t connection, float * returnValue, krpc_SpaceCenter_Flight_t instance);

/**
 * The dynamic pressure acting on the vessel, in Pascals. This is a measure of the
 * strength of the aerodynamic forces. It is equal to
 * \frac{1}{2} . \mbox{air density} . \mbox{velocity}^2.
 * It is commonly denoted Q.
 */
krpc_error_t krpc_SpaceCenter_Flight_DynamicPressure(krpc_connection_t connection, float * returnValue, krpc_SpaceCenter_Flight_t instance);

/**
 * The speed of the vessel, in multiples of the speed of sound.
 */
krpc_error_t krpc_SpaceCenter_Flight_Mach(krpc_connection_t connection, float * returnValue, krpc_SpaceCenter_Flight_t instance);

/**
 * The <a href="https://en.wikipedia.org/wiki/Ballistic_coefficient">ballistic coefficient</a>.
 *
 * Requires <a href="https://forum.kerbalspaceprogram.com/index.php?/topic/19321-130-ferram-aerospace-research-v0159-liebe-82117/">Ferram Aerospace Research</a>.
 */
krpc_error_t krpc_SpaceCenter_Flight_BallisticCoefficient(krpc_connection_t connection, float * returnValue, krpc_SpaceCenter_Flight_t instance);

/**
 * The static atmospheric pressure at mean sea level, in Pascals.
 */
krpc_error_t krpc_SpaceCenter_Flight_StaticPressureAtMSL(krpc_connection_t connection, float * returnValue, krpc_SpaceCenter_Flight_t instance);

/**
 * The vertical speed of the vessel in meters per second,
 * in the reference frame SpaceCenter::ReferenceFrame.
 */
krpc_error_t krpc_SpaceCenter_Flight_VerticalSpeed(krpc_connection_t connection, double * returnValue, krpc_SpaceCenter_Flight_t instance);

/**
 * The altitude above sea level, in meters.
 * Measured from the center of mass of the vessel.
 */
krpc_error_t krpc_SpaceCenter_Flight_MeanAltitude(krpc_connection_t connection, double * returnValue, krpc_SpaceCenter_Flight_t instance);

/**
 * The <a href="https://en.wikipedia.org/wiki/Longitude">longitude</a> of the vessel for the body being orbited, in degrees.
 */
krpc_error_t krpc_SpaceCenter_Flight_Longitude(krpc_connection_t connection, double * returnValue, krpc_SpaceCenter_Flight_t instance);

/**
 * The yaw angle between the orientation of the vessel and its velocity vector, in degrees.
 */
krpc_error_t krpc_SpaceCenter_Flight_SideslipAngle(krpc_connection_t connection, float * returnValue, krpc_SpaceCenter_Flight_t instance);

/**
 * The altitude above the surface of the body, in meters. When over water, this is the altitude above the sea floor.
 * Measured from the center of mass of the vessel.
 */
krpc_error_t krpc_SpaceCenter_Flight_BedrockAltitude(krpc_connection_t connection, double * returnValue, krpc_SpaceCenter_Flight_t instance);

/**
 * The <a href="https://en.wikipedia.org/wiki/Equivalent_airspeed">equivalent air speed</a>
 * of the vessel, in meters per second.
 */
krpc_error_t krpc_SpaceCenter_Flight_EquivalentAirSpeed(krpc_connection_t connection, float * returnValue, krpc_SpaceCenter_Flight_t instance);

/**
 * The current density of the atmosphere around the vessel, in kg/m^3.
 */
krpc_error_t krpc_SpaceCenter_Flight_AtmosphereDensity(krpc_connection_t connection, float * returnValue, krpc_SpaceCenter_Flight_t instance);

/**
 * The heading of the vessel (its angle relative to north), in degrees.
 * A value between 0° and 360°.
 */
krpc_error_t krpc_SpaceCenter_Flight_Heading(krpc_connection_t connection, float * returnValue, krpc_SpaceCenter_Flight_t instance);

/**
 * The altitude above the surface of the body or sea level, whichever is closer, in meters.
 * Measured from the center of mass of the vessel.
 */
krpc_error_t krpc_SpaceCenter_Flight_SurfaceAltitude(krpc_connection_t connection, double * returnValue, krpc_SpaceCenter_Flight_t instance);

/**
 * The <a href="https://en.wikipedia.org/wiki/True_airspeed">true air speed</a>
 * of the vessel, in meters per second.
 */
krpc_error_t krpc_SpaceCenter_Flight_TrueAirSpeed(krpc_connection_t connection, float * returnValue, krpc_SpaceCenter_Flight_t instance);

/**
 * The retrograde direction of the vessels orbit,
 * in the reference frame SpaceCenter::ReferenceFrame.
 * @return The direction as a unit vector.
 */
krpc_error_t krpc_SpaceCenter_Flight_Retrograde(krpc_connection_t connection, krpc_tuple_double_double_double_t * returnValue, krpc_SpaceCenter_Flight_t instance);

/**
 * The thrust specific fuel consumption for the jet engines on the vessel. This is a
 * measure of the efficiency of the engines, with a lower value indicating a more
 * efficient vessel. This value is the number of Newtons of fuel that are burned,
 * per hour, to produce one newton of thrust.
 *
 * Requires <a href="https://forum.kerbalspaceprogram.com/index.php?/topic/19321-130-ferram-aerospace-research-v0159-liebe-82117/">Ferram Aerospace Research</a>.
 */
krpc_error_t krpc_SpaceCenter_Flight_ThrustSpecificFuelConsumption(krpc_connection_t connection, float * returnValue, krpc_SpaceCenter_Flight_t instance);

/**
 * The total aerodynamic forces acting on the vessel,
 * in reference frame SpaceCenter::ReferenceFrame.
 * @return A vector pointing in the direction that the force acts,
 * with its magnitude equal to the strength of the force in Newtons.
 */
krpc_error_t krpc_SpaceCenter_Flight_AerodynamicForce(krpc_connection_t connection, krpc_tuple_double_double_double_t * returnValue, krpc_SpaceCenter_Flight_t instance);

/**
 * The pitch of the vessel relative to the horizon, in degrees.
 * A value between -90° and +90°.
 */
krpc_error_t krpc_SpaceCenter_Flight_Pitch(krpc_connection_t connection, float * returnValue, krpc_SpaceCenter_Flight_t instance);

/**
 * The coefficient of lift. This is the amount of lift produced by the vessel, and
 * depends on air speed, air density and wing area.
 *
 * Requires <a href="https://forum.kerbalspaceprogram.com/index.php?/topic/19321-130-ferram-aerospace-research-v0159-liebe-82117/">Ferram Aerospace Research</a>.
 */
krpc_error_t krpc_SpaceCenter_Flight_LiftCoefficient(krpc_connection_t connection, float * returnValue, krpc_SpaceCenter_Flight_t instance);

/**
 * The prograde direction of the vessels orbit,
 * in the reference frame SpaceCenter::ReferenceFrame.
 * @return The direction as a unit vector.
 */
krpc_error_t krpc_SpaceCenter_Flight_Prograde(krpc_connection_t connection, krpc_tuple_double_double_double_t * returnValue, krpc_SpaceCenter_Flight_t instance);

/**
 * The direction opposite to the normal of the vessels orbit,
 * in the reference frame SpaceCenter::ReferenceFrame.
 * @return The direction as a unit vector.
 */
krpc_error_t krpc_SpaceCenter_Flight_AntiNormal(krpc_connection_t connection, krpc_tuple_double_double_double_t * returnValue, krpc_SpaceCenter_Flight_t instance);

/**
 * The speed of the vessel in meters per second,
 * in the reference frame SpaceCenter::ReferenceFrame.
 */
krpc_error_t krpc_SpaceCenter_Flight_Speed(krpc_connection_t connection, double * returnValue, krpc_SpaceCenter_Flight_t instance);

/**
 * Remove the force.
 */
krpc_error_t krpc_SpaceCenter_Force_Remove(krpc_connection_t connection, krpc_SpaceCenter_Force_t instance);

/**
 * The reference frame of the force vector and position.
 */
krpc_error_t krpc_SpaceCenter_Force_set_ReferenceFrame(krpc_connection_t connection, krpc_SpaceCenter_Force_t instance, krpc_SpaceCenter_ReferenceFrame_t value);

/**
 * The reference frame of the force vector and position.
 */
krpc_error_t krpc_SpaceCenter_Force_ReferenceFrame(krpc_connection_t connection, krpc_SpaceCenter_ReferenceFrame_t * returnValue, krpc_SpaceCenter_Force_t instance);

/**
 * The force vector, in Newtons.
 * @return A vector pointing in the direction that the force acts,
 * with its magnitude equal to the strength of the force in Newtons.
 */
krpc_error_t krpc_SpaceCenter_Force_set_ForceVector(krpc_connection_t connection, krpc_SpaceCenter_Force_t instance, const krpc_tuple_double_double_double_t * value);

/**
 * The part that this force is applied to.
 */
krpc_error_t krpc_SpaceCenter_Force_Part(krpc_connection_t connection, krpc_SpaceCenter_Part_t * returnValue, krpc_SpaceCenter_Force_t instance);

/**
 * The position at which the force acts, in reference frame SpaceCenter::ReferenceFrame.
 * @return The position as a vector.
 */
krpc_error_t krpc_SpaceCenter_Force_Position(krpc_connection_t connection, krpc_tuple_double_double_double_t * returnValue, krpc_SpaceCenter_Force_t instance);

/**
 * The position at which the force acts, in reference frame SpaceCenter::ReferenceFrame.
 * @return The position as a vector.
 */
krpc_error_t krpc_SpaceCenter_Force_set_Position(krpc_connection_t connection, krpc_SpaceCenter_Force_t instance, const krpc_tuple_double_double_double_t * value);

/**
 * The force vector, in Newtons.
 * @return A vector pointing in the direction that the force acts,
 * with its magnitude equal to the strength of the force in Newtons.
 */
krpc_error_t krpc_SpaceCenter_Force_ForceVector(krpc_connection_t connection, krpc_tuple_double_double_double_t * returnValue, krpc_SpaceCenter_Force_t instance);

/**
 * Whether the intake is open.
 */
krpc_error_t krpc_SpaceCenter_Intake_set_Open(krpc_connection_t connection, krpc_SpaceCenter_Intake_t instance, bool value);

/**
 * The area of the intake's opening, in square meters.
 */
krpc_error_t krpc_SpaceCenter_Intake_Area(krpc_connection_t connection, float * returnValue, krpc_SpaceCenter_Intake_t instance);

/**
 * Speed of the flow into the intake, in m/s.
 */
krpc_error_t krpc_SpaceCenter_Intake_Speed(krpc_connection_t connection, float * returnValue, krpc_SpaceCenter_Intake_t instance);

/**
 * The rate of flow into the intake, in units of resource per second.
 */
krpc_error_t krpc_SpaceCenter_Intake_Flow(krpc_connection_t connection, float * returnValue, krpc_SpaceCenter_Intake_t instance);

/**
 * The part object for this intake.
 */
krpc_error_t krpc_SpaceCenter_Intake_Part(krpc_connection_t connection, krpc_SpaceCenter_Part_t * returnValue, krpc_SpaceCenter_Intake_t instance);

/**
 * Whether the intake is open.
 */
krpc_error_t krpc_SpaceCenter_Intake_Open(krpc_connection_t connection, bool * returnValue, krpc_SpaceCenter_Intake_t instance);

/**
 * Releases the docking clamp. Has no effect if the clamp has already been released.
 */
krpc_error_t krpc_SpaceCenter_LaunchClamp_Release(krpc_connection_t connection, krpc_SpaceCenter_LaunchClamp_t instance);

/**
 * The part object for this launch clamp.
 */
krpc_error_t krpc_SpaceCenter_LaunchClamp_Part(krpc_connection_t connection, krpc_SpaceCenter_Part_t * returnValue, krpc_SpaceCenter_LaunchClamp_t instance);

/**
 * Whether the landing leg is deployed.
 *
 * Fixed landing legs are always deployed.
 * Returns an error if you try to deploy fixed landing gear.
 */
krpc_error_t krpc_SpaceCenter_Leg_set_Deployed(krpc_connection_t connection, krpc_SpaceCenter_Leg_t instance, bool value);

/**
 * Whether the leg is deployable.
 */
krpc_error_t krpc_SpaceCenter_Leg_Deployable(krpc_connection_t connection, bool * returnValue, krpc_SpaceCenter_Leg_t instance);

/**
 * The current state of the landing leg.
 */
krpc_error_t krpc_SpaceCenter_Leg_State(krpc_connection_t connection, krpc_SpaceCenter_LegState_t * returnValue, krpc_SpaceCenter_Leg_t instance);

/**
 * The part object for this landing leg.
 */
krpc_error_t krpc_SpaceCenter_Leg_Part(krpc_connection_t connection, krpc_SpaceCenter_Part_t * returnValue, krpc_SpaceCenter_Leg_t instance);

/**
 * Returns whether the leg is touching the ground.
 */
krpc_error_t krpc_SpaceCenter_Leg_IsGrounded(krpc_connection_t connection, bool * returnValue, krpc_SpaceCenter_Leg_t instance);

/**
 * Whether the landing leg is deployed.
 *
 * Fixed landing legs are always deployed.
 * Returns an error if you try to deploy fixed landing gear.
 */
krpc_error_t krpc_SpaceCenter_Leg_Deployed(krpc_connection_t connection, bool * returnValue, krpc_SpaceCenter_Leg_t instance);

/**
 * Whether the light is switched on.
 */
krpc_error_t krpc_SpaceCenter_Light_set_Active(krpc_connection_t connection, krpc_SpaceCenter_Light_t instance, bool value);

/**
 * The color of the light, as an RGB triple.
 */
krpc_error_t krpc_SpaceCenter_Light_Color(krpc_connection_t connection, krpc_tuple_float_float_float_t * returnValue, krpc_SpaceCenter_Light_t instance);

/**
 * The part object for this light.
 */
krpc_error_t krpc_SpaceCenter_Light_Part(krpc_connection_t connection, krpc_SpaceCenter_Part_t * returnValue, krpc_SpaceCenter_Light_t instance);

/**
 * Whether the light is switched on.
 */
krpc_error_t krpc_SpaceCenter_Light_Active(krpc_connection_t connection, bool * returnValue, krpc_SpaceCenter_Light_t instance);

/**
 * The color of the light, as an RGB triple.
 */
krpc_error_t krpc_SpaceCenter_Light_set_Color(krpc_connection_t connection, krpc_SpaceCenter_Light_t instance, const krpc_tuple_float_float_float_t * value);

/**
 * The current power usage, in units of charge per second.
 */
krpc_error_t krpc_SpaceCenter_Light_PowerUsage(krpc_connection_t connection, float * returnValue, krpc_SpaceCenter_Light_t instance);

/**
 * Returns the value of a field.
 * @param name Name of the field.
 */
krpc_error_t krpc_SpaceCenter_Module_GetField(krpc_connection_t connection, char * * returnValue, krpc_SpaceCenter_Module_t instance, const char * name);

/**
 * true if the part has an action with the given name.
 * @param name
 */
krpc_error_t krpc_SpaceCenter_Module_HasAction(krpc_connection_t connection, bool * returnValue, krpc_SpaceCenter_Module_t instance, const char * name);

/**
 * true if the module has an event with the given name.
 * @param name
 */
krpc_error_t krpc_SpaceCenter_Module_HasEvent(krpc_connection_t connection, bool * returnValue, krpc_SpaceCenter_Module_t instance, const char * name);

/**
 * Returns true if the module has a field with the given name.
 * @param name Name of the field.
 */
krpc_error_t krpc_SpaceCenter_Module_HasField(krpc_connection_t connection, bool * returnValue, krpc_SpaceCenter_Module_t instance, const char * name);

/**
 * Set the value of a field to its original value.
 * @param name Name of the field.
 */
krpc_error_t krpc_SpaceCenter_Module_ResetField(krpc_connection_t connection, krpc_SpaceCenter_Module_t instance, const char * name);

/**
 * Set the value of an action with the given name.
 * @param name
 * @param value
 */
krpc_error_t krpc_SpaceCenter_Module_SetAction(krpc_connection_t connection, krpc_SpaceCenter_Module_t instance, const char * name, bool value);

/**
 * Set the value of a field to the given floating point number.
 * @param name Name of the field.
 * @param value Value to set.
 */
krpc_error_t krpc_SpaceCenter_Module_SetFieldFloat(krpc_connection_t connection, krpc_SpaceCenter_Module_t instance, const char * name, float value);

/**
 * Set the value of a field to the given integer number.
 * @param name Name of the field.
 * @param value Value to set.
 */
krpc_error_t krpc_SpaceCenter_Module_SetFieldInt(krpc_connection_t connection, krpc_SpaceCenter_Module_t instance, const char * name, int32_t value);

/**
 * Set the value of a field to the given string.
 * @param name Name of the field.
 * @param value Value to set.
 */
krpc_error_t krpc_SpaceCenter_Module_SetFieldString(krpc_connection_t connection, krpc_SpaceCenter_Module_t instance, const char * name, const char * value);

/**
 * Trigger the named event. Equivalent to clicking the button in the right-click menu
 * of the part.
 * @param name
 */
krpc_error_t krpc_SpaceCenter_Module_TriggerEvent(krpc_connection_t connection, krpc_SpaceCenter_Module_t instance, const char * name);

/**
 * The modules field names and their associated values, as a dictionary.
 * These are the values visible in the right-click menu of the part.
 */
krpc_error_t krpc_SpaceCenter_Module_Fields(krpc_connection_t connection, krpc_dictionary_string_string_t * returnValue, krpc_SpaceCenter_Module_t instance);

/**
 * The part that contains this module.
 */
krpc_error_t krpc_SpaceCenter_Module_Part(krpc_connection_t connection, krpc_SpaceCenter_Part_t * returnValue, krpc_SpaceCenter_Module_t instance);

/**
 * A list of the names of all of the modules events. Events are the clickable buttons
 * visible in the right-click menu of the part.
 */
krpc_error_t krpc_SpaceCenter_Module_Events(krpc_connection_t connection, krpc_list_string_t * returnValue, krpc_SpaceCenter_Module_t instance);

/**
 * A list of all the names of the modules actions. These are the parts actions that can
 * be assigned to action groups in the in-game editor.
 */
krpc_error_t krpc_SpaceCenter_Module_Actions(krpc_connection_t connection, krpc_list_string_t * returnValue, krpc_SpaceCenter_Module_t instance);

/**
 * Name of the PartModule. For example, "ModuleEngines".
 */
krpc_error_t krpc_SpaceCenter_Module_Name(krpc_connection_t connection, char * * returnValue, krpc_SpaceCenter_Module_t instance);

/**
 * Returns the burn vector for the maneuver node.
 * @param referenceFrame The reference frame that the returned vector is in.
 * Defaults to SpaceCenter::Vessel::orbital_reference_frame.
 * @return A vector whose direction is the direction of the maneuver node burn, and
 * magnitude is the delta-v of the burn in meters per second.
 *
 * Does not change when executing the maneuver node. See SpaceCenter::Node::remaining_burn_vector.
 */
krpc_error_t krpc_SpaceCenter_Node_BurnVector(krpc_connection_t connection, krpc_tuple_double_double_double_t * returnValue, krpc_SpaceCenter_Node_t instance, krpc_SpaceCenter_ReferenceFrame_t referenceFrame);

/**
 * The direction of the maneuver nodes burn.
 * @return The direction as a unit vector.
 * @param referenceFrame The reference frame that the returned
 * direction is in.
 */
krpc_error_t krpc_SpaceCenter_Node_Direction(krpc_connection_t connection, krpc_tuple_double_double_double_t * returnValue, krpc_SpaceCenter_Node_t instance, krpc_SpaceCenter_ReferenceFrame_t referenceFrame);

/**
 * The position vector of the maneuver node in the given reference frame.
 * @return The position as a vector.
 * @param referenceFrame The reference frame that the returned
 * position vector is in.
 */
krpc_error_t krpc_SpaceCenter_Node_Position(krpc_connection_t connection, krpc_tuple_double_double_double_t * returnValue, krpc_SpaceCenter_Node_t instance, krpc_SpaceCenter_ReferenceFrame_t referenceFrame);

/**
 * Returns the remaining burn vector for the maneuver node.
 * @param referenceFrame The reference frame that the returned vector is in.
 * Defaults to SpaceCenter::Vessel::orbital_reference_frame.
 * @return A vector whose direction is the direction of the maneuver node burn, and
 * magnitude is the delta-v of the burn in meters per second.
 *
 * Changes as the maneuver node is executed. See SpaceCenter::Node::burn_vector.
 */
krpc_error_t krpc_SpaceCenter_Node_RemainingBurnVector(krpc_connection_t connection, krpc_tuple_double_double_double_t * returnValue, krpc_SpaceCenter_Node_t instance, krpc_SpaceCenter_ReferenceFrame_t referenceFrame);

/**
 * Removes the maneuver node.
 */
krpc_error_t krpc_SpaceCenter_Node_Remove(krpc_connection_t connection, krpc_SpaceCenter_Node_t instance);

/**
 * Gets the remaining delta-v of the maneuver node, in meters per second. Changes as the
 * node is executed. This is equivalent to the delta-v reported in-game.
 */
krpc_error_t krpc_SpaceCenter_Node_RemainingDeltaV(krpc_connection_t connection, double * returnValue, krpc_SpaceCenter_Node_t instance);

/**
 * The magnitude of the maneuver nodes delta-v in the normal direction,
 * in meters per second.
 */
krpc_error_t krpc_SpaceCenter_Node_set_Normal(krpc_connection_t connection, krpc_SpaceCenter_Node_t instance, double value);

/**
 * The delta-v of the maneuver node, in meters per second.
 *
 * Does not change when executing the maneuver node. See SpaceCenter::Node::remaining_delta_v.
 */
krpc_error_t krpc_SpaceCenter_Node_set_DeltaV(krpc_connection_t connection, krpc_SpaceCenter_Node_t instance, double value);

/**
 * The delta-v of the maneuver node, in meters per second.
 *
 * Does not change when executing the maneuver node. See SpaceCenter::Node::remaining_delta_v.
 */
krpc_error_t krpc_SpaceCenter_Node_DeltaV(krpc_connection_t connection, double * returnValue, krpc_SpaceCenter_Node_t instance);

/**
 * The magnitude of the maneuver nodes delta-v in the normal direction,
 * in meters per second.
 */
krpc_error_t krpc_SpaceCenter_Node_Normal(krpc_connection_t connection, double * returnValue, krpc_SpaceCenter_Node_t instance);

/**
 * The magnitude of the maneuver nodes delta-v in the radial direction,
 * in meters per second.
 */
krpc_error_t krpc_SpaceCenter_Node_set_Radial(krpc_connection_t connection, krpc_SpaceCenter_Node_t instance, double value);

/**
 * The universal time at which the maneuver will occur, in seconds.
 */
krpc_error_t krpc_SpaceCenter_Node_UT(krpc_connection_t connection, double * returnValue, krpc_SpaceCenter_Node_t instance);

/**
 * The universal time at which the maneuver will occur, in seconds.
 */
krpc_error_t krpc_SpaceCenter_Node_set_UT(krpc_connection_t connection, krpc_SpaceCenter_Node_t instance, double value);

/**
 * The orbit that results from executing the maneuver node.
 */
krpc_error_t krpc_SpaceCenter_Node_Orbit(krpc_connection_t connection, krpc_SpaceCenter_Orbit_t * returnValue, krpc_SpaceCenter_Node_t instance);

/**
 * The time until the maneuver node will be encountered, in seconds.
 */
krpc_error_t krpc_SpaceCenter_Node_TimeTo(krpc_connection_t connection, double * returnValue, krpc_SpaceCenter_Node_t instance);

/**
 * The magnitude of the maneuver nodes delta-v in the prograde direction,
 * in meters per second.
 */
krpc_error_t krpc_SpaceCenter_Node_set_Prograde(krpc_connection_t connection, krpc_SpaceCenter_Node_t instance, double value);

/**
 * The magnitude of the maneuver nodes delta-v in the radial direction,
 * in meters per second.
 */
krpc_error_t krpc_SpaceCenter_Node_Radial(krpc_connection_t connection, double * returnValue, krpc_SpaceCenter_Node_t instance);

/**
 * The reference frame that is fixed relative to the maneuver node's burn.
 *
 * - The origin is at the position of the maneuver node.
 * - The y-axis points in the direction of the burn.
 * - The x-axis and z-axis point in arbitrary but fixed directions.
 */
krpc_error_t krpc_SpaceCenter_Node_ReferenceFrame(krpc_connection_t connection, krpc_SpaceCenter_ReferenceFrame_t * returnValue, krpc_SpaceCenter_Node_t instance);

/**
 * The magnitude of the maneuver nodes delta-v in the prograde direction,
 * in meters per second.
 */
krpc_error_t krpc_SpaceCenter_Node_Prograde(krpc_connection_t connection, double * returnValue, krpc_SpaceCenter_Node_t instance);

/**
 * The reference frame that is fixed relative to the maneuver node, and
 * orientated with the orbital prograde/normal/radial directions of the
 * original orbit at the maneuver node's position.
 *
 * - The origin is at the position of the maneuver node.
 * - The x-axis points in the orbital anti-radial direction of the original
 *   orbit, at the position of the maneuver node.
 * - The y-axis points in the orbital prograde direction of the original
 *   orbit, at the position of the maneuver node.
 * - The z-axis points in the orbital normal direction of the original orbit,
 *   at the position of the maneuver node.
 */
krpc_error_t krpc_SpaceCenter_Node_OrbitalReferenceFrame(krpc_connection_t connection, krpc_SpaceCenter_ReferenceFrame_t * returnValue, krpc_SpaceCenter_Node_t instance);

/**
 * Estimates and returns the distance at closest approach to a target vessel, in meters.
 * @param target Target vessel.
 */
krpc_error_t krpc_SpaceCenter_Orbit_DistanceAtClosestApproach(krpc_connection_t connection, double * returnValue, krpc_SpaceCenter_Orbit_t instance, krpc_SpaceCenter_Vessel_t target);

/**
 * The eccentric anomaly at the given universal time.
 * @param ut The universal time, in seconds.
 */
krpc_error_t krpc_SpaceCenter_Orbit_EccentricAnomalyAtUT(krpc_connection_t connection, double * returnValue, krpc_SpaceCenter_Orbit_t instance, double ut);

/**
 * Returns the times at closest approach and corresponding distances, to a target vessel.
 * @return A list of two lists.
 * The first is a list of times at closest approach, as universal times in seconds.
 * The second is a list of corresponding distances at closest approach, in meters.
 * @param target Target vessel.
 * @param orbits The number of future orbits to search.
 */
krpc_error_t krpc_SpaceCenter_Orbit_ListClosestApproaches(krpc_connection_t connection, krpc_list_list_double_t * returnValue, krpc_SpaceCenter_Orbit_t instance, krpc_SpaceCenter_Vessel_t target, int32_t orbits);

/**
 * The mean anomaly at the given time.
 * @param ut The universal time in seconds.
 */
krpc_error_t krpc_SpaceCenter_Orbit_MeanAnomalyAtUT(krpc_connection_t connection, double * returnValue, krpc_SpaceCenter_Orbit_t instance, double ut);

/**
 * The orbital speed at the given time, in meters per second.
 * @param time Time from now, in seconds.
 */
krpc_error_t krpc_SpaceCenter_Orbit_OrbitalSpeedAt(krpc_connection_t connection, double * returnValue, krpc_SpaceCenter_Orbit_t instance, double time);

/**
 * The position at a given time, in the specified reference frame.
 * @return The position as a vector.
 * @param ut The universal time to measure the position at.
 * @param referenceFrame The reference frame that the returned
 * position vector is in.
 */
krpc_error_t krpc_SpaceCenter_Orbit_PositionAt(krpc_connection_t connection, krpc_tuple_double_double_double_t * returnValue, krpc_SpaceCenter_Orbit_t instance, double ut, krpc_SpaceCenter_ReferenceFrame_t referenceFrame);

/**
 * The orbital radius at the given time, in meters.
 * @param ut The universal time to measure the radius at.
 */
krpc_error_t krpc_SpaceCenter_Orbit_RadiusAt(krpc_connection_t connection, double * returnValue, krpc_SpaceCenter_Orbit_t instance, double ut);

/**
 * The orbital radius at the point in the orbit given by the true anomaly.
 * @param trueAnomaly The true anomaly.
 */
krpc_error_t krpc_SpaceCenter_Orbit_RadiusAtTrueAnomaly(krpc_connection_t connection, double * returnValue, krpc_SpaceCenter_Orbit_t instance, double trueAnomaly);

/**
 * Relative inclination of this orbit and the orbit of the given target vessel, in radians.
 * @param target Target vessel.
 */
krpc_error_t krpc_SpaceCenter_Orbit_RelativeInclination(krpc_connection_t connection, double * returnValue, krpc_SpaceCenter_Orbit_t instance, krpc_SpaceCenter_Vessel_t target);

/**
 * Estimates and returns the time at closest approach to a target vessel.
 * @return The universal time at closest approach, in seconds.
 * @param target Target vessel.
 */
krpc_error_t krpc_SpaceCenter_Orbit_TimeOfClosestApproach(krpc_connection_t connection, double * returnValue, krpc_SpaceCenter_Orbit_t instance, krpc_SpaceCenter_Vessel_t target);

/**
 * The true anomaly of the ascending node with the given target vessel.
 * @param target Target vessel.
 */
krpc_error_t krpc_SpaceCenter_Orbit_TrueAnomalyAtAN(krpc_connection_t connection, double * returnValue, krpc_SpaceCenter_Orbit_t instance, krpc_SpaceCenter_Vessel_t target);

/**
 * The true anomaly of the descending node with the given target vessel.
 * @param target Target vessel.
 */
krpc_error_t krpc_SpaceCenter_Orbit_TrueAnomalyAtDN(krpc_connection_t connection, double * returnValue, krpc_SpaceCenter_Orbit_t instance, krpc_SpaceCenter_Vessel_t target);

/**
 * The true anomaly at the given orbital radius.
 * @param radius The orbital radius in meters.
 */
krpc_error_t krpc_SpaceCenter_Orbit_TrueAnomalyAtRadius(krpc_connection_t connection, double * returnValue, krpc_SpaceCenter_Orbit_t instance, double radius);

/**
 * The true anomaly at the given time.
 * @param ut The universal time in seconds.
 */
krpc_error_t krpc_SpaceCenter_Orbit_TrueAnomalyAtUT(krpc_connection_t connection, double * returnValue, krpc_SpaceCenter_Orbit_t instance, double ut);

/**
 * The universal time, in seconds, corresponding to the given true anomaly.
 * @param trueAnomaly True anomaly.
 */
krpc_error_t krpc_SpaceCenter_Orbit_UTAtTrueAnomaly(krpc_connection_t connection, double * returnValue, krpc_SpaceCenter_Orbit_t instance, double trueAnomaly);

/**
 * The direction from which the orbits longitude of ascending node is measured,
 * in the given reference frame.
 * @return The direction as a unit vector.
 * @param referenceFrame The reference frame that the returned
 * direction is in.
 */
krpc_error_t krpc_SpaceCenter_Orbit_ReferencePlaneDirection(krpc_connection_t connection, krpc_tuple_double_double_double_t * returnValue, krpc_SpaceCenter_ReferenceFrame_t referenceFrame);

/**
 * The direction that is normal to the orbits reference plane,
 * in the given reference frame.
 * The reference plane is the plane from which the orbits inclination is measured.
 * @return The direction as a unit vector.
 * @param referenceFrame The reference frame that the returned
 * direction is in.
 */
krpc_error_t krpc_SpaceCenter_Orbit_ReferencePlaneNormal(krpc_connection_t connection, krpc_tuple_double_double_double_t * returnValue, krpc_SpaceCenter_ReferenceFrame_t referenceFrame);

/**
 * Gets the apoapsis of the orbit, in meters, from the center of mass
 * of the body being orbited.
 *
 * For the apoapsis altitude reported on the in-game map view,
 * use SpaceCenter::Orbit::apoapsis_altitude.
 */
krpc_error_t krpc_SpaceCenter_Orbit_Apoapsis(krpc_connection_t connection, double * returnValue, krpc_SpaceCenter_Orbit_t instance);

/**
 * The time since the epoch (the point at which the
 * <a href="https://en.wikipedia.org/wiki/Mean_anomaly">mean anomaly at epoch</a>
 * was measured, in seconds.
 */
krpc_error_t krpc_SpaceCenter_Orbit_Epoch(krpc_connection_t connection, double * returnValue, krpc_SpaceCenter_Orbit_t instance);

/**
 * The <a href="https://en.wikipedia.org/wiki/True_anomaly">true anomaly</a>.
 */
krpc_error_t krpc_SpaceCenter_Orbit_TrueAnomaly(krpc_connection_t connection, double * returnValue, krpc_SpaceCenter_Orbit_t instance);

/**
 * The periapsis of the orbit, in meters, above the sea level of the body being orbited.
 *
 * This is equal to SpaceCenter::Orbit::periapsis minus the equatorial radius of the body.
 */
krpc_error_t krpc_SpaceCenter_Orbit_PeriapsisAltitude(krpc_connection_t connection, double * returnValue, krpc_SpaceCenter_Orbit_t instance);

/**
 * The <a href="https://en.wikipedia.org/wiki/Argument_of_periapsis">argument of
 * periapsis</a>, in radians.
 */
krpc_error_t krpc_SpaceCenter_Orbit_ArgumentOfPeriapsis(krpc_connection_t connection, double * returnValue, krpc_SpaceCenter_Orbit_t instance);

/**
 * The <a href="https://en.wikipedia.org/wiki/Orbital_inclination">inclination</a>
 * of the orbit,
 * in radians.
 */
krpc_error_t krpc_SpaceCenter_Orbit_Inclination(krpc_connection_t connection, double * returnValue, krpc_SpaceCenter_Orbit_t instance);

/**
 * The celestial body (e.g. planet or moon) around which the object is orbiting.
 */
krpc_error_t krpc_SpaceCenter_Orbit_Body(krpc_connection_t connection, krpc_SpaceCenter_CelestialBody_t * returnValue, krpc_SpaceCenter_Orbit_t instance);

/**
 * The apoapsis of the orbit, in meters, above the sea level of the body being orbited.
 *
 * This is equal to SpaceCenter::Orbit::apoapsis minus the equatorial radius of the body.
 */
krpc_error_t krpc_SpaceCenter_Orbit_ApoapsisAltitude(krpc_connection_t connection, double * returnValue, krpc_SpaceCenter_Orbit_t instance);

/**
 * The <a href="https://en.wikipedia.org/wiki/Mean_anomaly">mean anomaly</a>.
 */
krpc_error_t krpc_SpaceCenter_Orbit_MeanAnomaly(krpc_connection_t connection, double * returnValue, krpc_SpaceCenter_Orbit_t instance);

/**
 * The current orbital speed in meters per second.
 */
krpc_error_t krpc_SpaceCenter_Orbit_OrbitalSpeed(krpc_connection_t connection, double * returnValue, krpc_SpaceCenter_Orbit_t instance);

/**
 * The time until the object reaches periapsis, in seconds.
 */
krpc_error_t krpc_SpaceCenter_Orbit_TimeToPeriapsis(krpc_connection_t connection, double * returnValue, krpc_SpaceCenter_Orbit_t instance);

/**
 * The semi-minor axis of the orbit, in meters.
 */
krpc_error_t krpc_SpaceCenter_Orbit_SemiMinorAxis(krpc_connection_t connection, double * returnValue, krpc_SpaceCenter_Orbit_t instance);

/**
 * The <a href="https://en.wikipedia.org/wiki/Orbital_eccentricity">eccentricity</a>
 * of the orbit.
 */
krpc_error_t krpc_SpaceCenter_Orbit_Eccentricity(krpc_connection_t connection, double * returnValue, krpc_SpaceCenter_Orbit_t instance);

/**
 * The periapsis of the orbit, in meters, from the center of mass
 * of the body being orbited.
 *
 * For the periapsis altitude reported on the in-game map view,
 * use SpaceCenter::Orbit::periapsis_altitude.
 */
krpc_error_t krpc_SpaceCenter_Orbit_Periapsis(krpc_connection_t connection, double * returnValue, krpc_SpaceCenter_Orbit_t instance);

/**
 * The semi-major axis of the orbit, in meters.
 */
krpc_error_t krpc_SpaceCenter_Orbit_SemiMajorAxis(krpc_connection_t connection, double * returnValue, krpc_SpaceCenter_Orbit_t instance);

/**
 * The <a href="https://en.wikipedia.org/wiki/Mean_anomaly">mean anomaly at epoch</a>.
 */
krpc_error_t krpc_SpaceCenter_Orbit_MeanAnomalyAtEpoch(krpc_connection_t connection, double * returnValue, krpc_SpaceCenter_Orbit_t instance);

/**
 * If the object is going to change sphere of influence in the future, returns the new
 * orbit after the change. Otherwise returns null.
 */
krpc_error_t krpc_SpaceCenter_Orbit_NextOrbit(krpc_connection_t connection, krpc_SpaceCenter_Orbit_t * returnValue, krpc_SpaceCenter_Orbit_t instance);

/**
 * The <a href="https://en.wikipedia.org/wiki/Longitude_of_the_ascending_node">longitude of
 * the ascending node</a>, in radians.
 */
krpc_error_t krpc_SpaceCenter_Orbit_LongitudeOfAscendingNode(krpc_connection_t connection, double * returnValue, krpc_SpaceCenter_Orbit_t instance);

/**
 * The time until the object changes sphere of influence, in seconds. Returns NaN
 * if the object is not going to change sphere of influence.
 */
krpc_error_t krpc_SpaceCenter_Orbit_TimeToSOIChange(krpc_connection_t connection, double * returnValue, krpc_SpaceCenter_Orbit_t instance);

/**
 * The <a href="https://en.wikipedia.org/wiki/Eccentric_anomaly">eccentric anomaly</a>.
 */
krpc_error_t krpc_SpaceCenter_Orbit_EccentricAnomaly(krpc_connection_t connection, double * returnValue, krpc_SpaceCenter_Orbit_t instance);

/**
 * The orbital period, in seconds.
 */
krpc_error_t krpc_SpaceCenter_Orbit_Period(krpc_connection_t connection, double * returnValue, krpc_SpaceCenter_Orbit_t instance);

/**
 * The current radius of the orbit, in meters. This is the distance between the center
 * of mass of the object in orbit, and the center of mass of the body around which it
 * is orbiting.
 *
 * This value will change over time if the orbit is elliptical.
 */
krpc_error_t krpc_SpaceCenter_Orbit_Radius(krpc_connection_t connection, double * returnValue, krpc_SpaceCenter_Orbit_t instance);

/**
 * The time until the object reaches apoapsis, in seconds.
 */
krpc_error_t krpc_SpaceCenter_Orbit_TimeToApoapsis(krpc_connection_t connection, double * returnValue, krpc_SpaceCenter_Orbit_t instance);

/**
 * The current orbital speed of the object in meters per second.
 *
 * This value will change over time if the orbit is elliptical.
 */
krpc_error_t krpc_SpaceCenter_Orbit_Speed(krpc_connection_t connection, double * returnValue, krpc_SpaceCenter_Orbit_t instance);

/**
 * Deploys the parachute. This has no effect if the parachute has already
 * been armed or deployed. Only applicable to RealChutes parachutes.
 */
krpc_error_t krpc_SpaceCenter_Parachute_Arm(krpc_connection_t connection, krpc_SpaceCenter_Parachute_t instance);

/**
 * Deploys the parachute. This has no effect if the parachute has already
 * been deployed.
 */
krpc_error_t krpc_SpaceCenter_Parachute_Deploy(krpc_connection_t connection, krpc_SpaceCenter_Parachute_t instance);

/**
 * The minimum pressure at which the parachute will semi-deploy, in atmospheres.
 * Only applicable to stock parachutes.
 */
krpc_error_t krpc_SpaceCenter_Parachute_DeployMinPressure(krpc_connection_t connection, float * returnValue, krpc_SpaceCenter_Parachute_t instance);

/**
 * The altitude at which the parachute will full deploy, in meters.
 * Only applicable to stock parachutes.
 */
krpc_error_t krpc_SpaceCenter_Parachute_DeployAltitude(krpc_connection_t connection, float * returnValue, krpc_SpaceCenter_Parachute_t instance);

/**
 * The current state of the parachute.
 */
krpc_error_t krpc_SpaceCenter_Parachute_State(krpc_connection_t connection, krpc_SpaceCenter_ParachuteState_t * returnValue, krpc_SpaceCenter_Parachute_t instance);

/**
 * The part object for this parachute.
 */
krpc_error_t krpc_SpaceCenter_Parachute_Part(krpc_connection_t connection, krpc_SpaceCenter_Part_t * returnValue, krpc_SpaceCenter_Parachute_t instance);

/**
 * The altitude at which the parachute will full deploy, in meters.
 * Only applicable to stock parachutes.
 */
krpc_error_t krpc_SpaceCenter_Parachute_set_DeployAltitude(krpc_connection_t connection, krpc_SpaceCenter_Parachute_t instance, float value);

/**
 * The minimum pressure at which the parachute will semi-deploy, in atmospheres.
 * Only applicable to stock parachutes.
 */
krpc_error_t krpc_SpaceCenter_Parachute_set_DeployMinPressure(krpc_connection_t connection, krpc_SpaceCenter_Parachute_t instance, float value);

/**
 * Whether the parachute has been armed or deployed. Only applicable to
 * RealChutes parachutes.
 */
krpc_error_t krpc_SpaceCenter_Parachute_Armed(krpc_connection_t connection, bool * returnValue, krpc_SpaceCenter_Parachute_t instance);

/**
 * Whether the parachute has been deployed.
 */
krpc_error_t krpc_SpaceCenter_Parachute_Deployed(krpc_connection_t connection, bool * returnValue, krpc_SpaceCenter_Parachute_t instance);

/**
 * Exert a constant force on the part, acting at the given position.
 * @return An object that can be used to remove or modify the force.
 * @param force A vector pointing in the direction that the force acts,
 * with its magnitude equal to the strength of the force in Newtons.
 * @param position The position at which the force acts, as a vector.
 * @param referenceFrame The reference frame that the
 * force and position are in.
 */
krpc_error_t krpc_SpaceCenter_Part_AddForce(krpc_connection_t connection, krpc_SpaceCenter_Force_t * returnValue, krpc_SpaceCenter_Part_t instance, const krpc_tuple_double_double_double_t * force, const krpc_tuple_double_double_double_t * position, krpc_SpaceCenter_ReferenceFrame_t referenceFrame);

/**
 * The axis-aligned bounding box of the part in the given reference frame.
 * @return The positions of the minimum and maximum vertices of the box,
 * as position vectors.
 * @param referenceFrame The reference frame that the returned
 * position vectors are in.
 *
 * This is computed from the collision mesh of the part.
 * If the part is not collidable, the box has zero volume and is centered on
 * the SpaceCenter::Part::position of the part.
 */
krpc_error_t krpc_SpaceCenter_Part_BoundingBox(krpc_connection_t connection, krpc_tuple_tuple_double_double_double_tuple_double_double_double_t * returnValue, krpc_SpaceCenter_Part_t instance, krpc_SpaceCenter_ReferenceFrame_t referenceFrame);

/**
 * The position of the parts center of mass in the given reference frame.
 * If the part is physicsless, this is equivalent to SpaceCenter::Part::position.
 * @return The position as a vector.
 * @param referenceFrame The reference frame that the returned
 * position vector is in.
 */
krpc_error_t krpc_SpaceCenter_Part_CenterOfMass(krpc_connection_t connection, krpc_tuple_double_double_double_t * returnValue, krpc_SpaceCenter_Part_t instance, krpc_SpaceCenter_ReferenceFrame_t referenceFrame);

/**
 * The direction the part points in, in the given reference frame.
 * @return The direction as a unit vector.
 * @param referenceFrame The reference frame that the returned
 * direction is in.
 */
krpc_error_t krpc_SpaceCenter_Part_Direction(krpc_connection_t connection, krpc_tuple_double_double_double_t * returnValue, krpc_SpaceCenter_Part_t instance, krpc_SpaceCenter_ReferenceFrame_t referenceFrame);

/**
 * Exert an instantaneous force on the part, acting at the given position.
 * @param force A vector pointing in the direction that the force acts,
 * with its magnitude equal to the strength of the force in Newtons.
 * @param position The position at which the force acts, as a vector.
 * @param referenceFrame The reference frame that the
 * force and position are in.
 *
 * The force is applied instantaneously in a single physics update.
 */
krpc_error_t krpc_SpaceCenter_Part_InstantaneousForce(krpc_connection_t connection, krpc_SpaceCenter_Part_t instance, const krpc_tuple_double_double_double_t * force, const krpc_tuple_double_double_double_t * position, krpc_SpaceCenter_ReferenceFrame_t referenceFrame);

/**
 * The position of the part in the given reference frame.
 * @return The position as a vector.
 * @param referenceFrame The reference frame that the returned
 * position vector is in.
 *
 * This is a fixed position in the part, defined by the parts model.
 * It s not necessarily the same as the parts center of mass.
 * Use SpaceCenter::Part::center_of_mass to get the parts center of mass.
 */
krpc_error_t krpc_SpaceCenter_Part_Position(krpc_connection_t connection, krpc_tuple_double_double_double_t * returnValue, krpc_SpaceCenter_Part_t instance, krpc_SpaceCenter_ReferenceFrame_t referenceFrame);

/**
 * The rotation of the part, in the given reference frame.
 * @return The rotation as a quaternion of the form (x, y, z, w).
 * @param referenceFrame The reference frame that the returned
 * rotation is in.
 */
krpc_error_t krpc_SpaceCenter_Part_Rotation(krpc_connection_t connection, krpc_tuple_double_double_double_double_t * returnValue, krpc_SpaceCenter_Part_t instance, krpc_SpaceCenter_ReferenceFrame_t referenceFrame);

/**
 * The linear velocity of the part in the given reference frame.
 * @return The velocity as a vector. The vector points in the direction of travel,
 * and its magnitude is the speed of the body in meters per second.
 * @param referenceFrame The reference frame that the returned
 * velocity vector is in.
 */
krpc_error_t krpc_SpaceCenter_Part_Velocity(krpc_connection_t connection, krpc_tuple_double_double_double_t * returnValue, krpc_SpaceCenter_Part_t instance, krpc_SpaceCenter_ReferenceFrame_t referenceFrame);

/**
 * The rate at which heat energy is conducting into or out of the part via contact with
 * other parts. Measured in energy per unit time, or power, in Watts.
 * A positive value means the part is gaining heat energy, and negative means it is
 * losing heat energy.
 */
krpc_error_t krpc_SpaceCenter_Part_ThermalConductionFlux(krpc_connection_t connection, float * returnValue, krpc_SpaceCenter_Part_t instance);

/**
 * The reference frame that is fixed relative to this part, and centered on its
 * center of mass.
 *
 * - The origin is at the center of mass of the part, as returned by
 *   SpaceCenter::Part::center_of_mass.
 * - The axes rotate with the part.
 * - The x, y and z axis directions depend on the design of the part.
 *
 * For docking port parts, this reference frame is not necessarily equivalent to the
 * reference frame for the docking port, returned by
 * SpaceCenter::DockingPort::reference_frame.
 */
krpc_error_t krpc_SpaceCenter_Part_CenterOfMassReferenceFrame(krpc_connection_t connection, krpc_SpaceCenter_ReferenceFrame_t * returnValue, krpc_SpaceCenter_Part_t instance);

/**
 * Whether this part is crossfeed capable.
 */
krpc_error_t krpc_SpaceCenter_Part_Crossfeed(krpc_connection_t connection, bool * returnValue, krpc_SpaceCenter_Part_t instance);

/**
 * A SpaceCenter::Antenna if the part is an antenna, otherwise null.
 */
krpc_error_t krpc_SpaceCenter_Part_Antenna(krpc_connection_t connection, krpc_SpaceCenter_Antenna_t * returnValue, krpc_SpaceCenter_Part_t instance);

/**
 * The inertia tensor of the part in the parts reference frame
 * (SpaceCenter::ReferenceFrame).
 * Returns the 3x3 matrix as a list of elements, in row-major order.
 */
krpc_error_t krpc_SpaceCenter_Part_InertiaTensor(krpc_connection_t connection, krpc_list_double_t * returnValue, krpc_SpaceCenter_Part_t instance);

/**
 * The moment of inertia of the part in kg.m^2 around its center of mass
 * in the parts reference frame (SpaceCenter::ReferenceFrame).
 */
krpc_error_t krpc_SpaceCenter_Part_MomentOfInertia(krpc_connection_t connection, krpc_tuple_double_double_double_t * returnValue, krpc_SpaceCenter_Part_t instance);

/**
 * A SpaceCenter::RCS if the part is an RCS block/thruster, otherwise null.
 */
krpc_error_t krpc_SpaceCenter_Part_RCS(krpc_connection_t connection, krpc_SpaceCenter_RCS_t * returnValue, krpc_SpaceCenter_Part_t instance);

/**
 * Whether the part is highlighted.
 */
krpc_error_t krpc_SpaceCenter_Part_Highlighted(krpc_connection_t connection, bool * returnValue, krpc_SpaceCenter_Part_t instance);

/**
 * An SpaceCenter::Experiment if the part is a science experiment, otherwise null.
 */
krpc_error_t krpc_SpaceCenter_Part_Experiment(krpc_connection_t connection, krpc_SpaceCenter_Experiment_t * returnValue, krpc_SpaceCenter_Part_t instance);

/**
 * The reference frame that is fixed relative to this part, and centered on a fixed
 * position within the part, defined by the parts model.
 *
 * - The origin is at the position of the part, as returned by
 *   SpaceCenter::Part::position.
 * - The axes rotate with the part.
 * - The x, y and z axis directions depend on the design of the part.
 *
 * For docking port parts, this reference frame is not necessarily equivalent to the
 * reference frame for the docking port, returned by
 * SpaceCenter::DockingPort::reference_frame.
 */
krpc_error_t krpc_SpaceCenter_Part_ReferenceFrame(krpc_connection_t connection, krpc_SpaceCenter_ReferenceFrame_t * returnValue, krpc_SpaceCenter_Part_t instance);

/**
 * A measure of how much energy it takes to increase the internal temperature of the part,
 * in Joules per Kelvin.
 */
krpc_error_t krpc_SpaceCenter_Part_ThermalMass(krpc_connection_t connection, float * returnValue, krpc_SpaceCenter_Part_t instance);

/**
 * Whether the part is
 * <a href="https://wiki.kerbalspaceprogram.com/wiki/Massless_part">massless</a>.
 */
krpc_error_t krpc_SpaceCenter_Part_Massless(krpc_connection_t connection, bool * returnValue, krpc_SpaceCenter_Part_t instance);

/**
 * A SpaceCenter::Sensor if the part is a sensor, otherwise null.
 */
krpc_error_t krpc_SpaceCenter_Part_Sensor(krpc_connection_t connection, krpc_SpaceCenter_Sensor_t * returnValue, krpc_SpaceCenter_Part_t instance);

/**
 * A SpaceCenter::Resources object for the part.
 */
krpc_error_t krpc_SpaceCenter_Part_Resources(krpc_connection_t connection, krpc_SpaceCenter_Resources_t * returnValue, krpc_SpaceCenter_Part_t instance);

/**
 * The parts that are connected to this part via fuel lines, where the direction of the
 * fuel line is out of this part.
 */
krpc_error_t krpc_SpaceCenter_Part_FuelLinesTo(krpc_connection_t connection, krpc_list_object_t * returnValue, krpc_SpaceCenter_Part_t instance);

/**
 * An SpaceCenter::Engine if the part is an engine, otherwise null.
 */
krpc_error_t krpc_SpaceCenter_Part_Engine(krpc_connection_t connection, krpc_SpaceCenter_Engine_t * returnValue, krpc_SpaceCenter_Part_t instance);

/**
 * The rate at which heat energy is radiating into or out of the part from the surrounding
 * environment. Measured in energy per unit time, or power, in Watts.
 * A positive value means the part is gaining heat energy, and negative means it is
 * losing heat energy.
 */
krpc_error_t krpc_SpaceCenter_Part_ThermalRadiationFlux(krpc_connection_t connection, float * returnValue, krpc_SpaceCenter_Part_t instance);

/**
 * The parts parent. Returns null if the part does not have a parent.
 * This, in combination with SpaceCenter::Part::children, can be used to traverse the vessels
 * parts tree.
 */
krpc_error_t krpc_SpaceCenter_Part_Parent(krpc_connection_t connection, krpc_SpaceCenter_Part_t * returnValue, krpc_SpaceCenter_Part_t instance);

/**
 * A SpaceCenter::Leg if the part is a landing leg, otherwise null.
 */
krpc_error_t krpc_SpaceCenter_Part_Leg(krpc_connection_t connection, krpc_SpaceCenter_Leg_t * returnValue, krpc_SpaceCenter_Part_t instance);

/**
 * Whether the part is radially attached to its parent, i.e. on the side of its parent.
 * If the part has no parent, returns false.
 */
krpc_error_t krpc_SpaceCenter_Part_RadiallyAttached(krpc_connection_t connection, bool * returnValue, krpc_SpaceCenter_Part_t instance);

/**
 * Title of the part, as shown when the part is right clicked in-game. For example "Mk1-2 Command Pod".
 */
krpc_error_t krpc_SpaceCenter_Part_Title(krpc_connection_t connection, char * * returnValue, krpc_SpaceCenter_Part_t instance);

/**
 * The parts that are connected to this part via fuel lines, where the direction of the
 * fuel line is into this part.
 */
krpc_error_t krpc_SpaceCenter_Part_FuelLinesFrom(krpc_connection_t connection, krpc_list_object_t * returnValue, krpc_SpaceCenter_Part_t instance);

/**
 * The rate at which heat energy is convecting into or out of the part from the
 * surrounding atmosphere. Measured in energy per unit time, or power, in Watts.
 * A positive value means the part is gaining heat energy, and negative means it is
 * losing heat energy.
 */
krpc_error_t krpc_SpaceCenter_Part_ThermalConvectionFlux(krpc_connection_t connection, float * returnValue, krpc_SpaceCenter_Part_t instance);

/**
 * A SpaceCenter::ResourceConverter if the part is a resource converter,
 * otherwise null.
 */
krpc_error_t krpc_SpaceCenter_Part_ResourceConverter(krpc_connection_t connection, krpc_SpaceCenter_ResourceConverter_t * returnValue, krpc_SpaceCenter_Part_t instance);

/**
 * The color used to highlight the part, as an RGB triple.
 */
krpc_error_t krpc_SpaceCenter_Part_HighlightColor(krpc_connection_t connection, krpc_tuple_double_double_double_t * returnValue, krpc_SpaceCenter_Part_t instance);

/**
 * A SpaceCenter::SolarPanel if the part is a solar panel, otherwise null.
 */
krpc_error_t krpc_SpaceCenter_Part_SolarPanel(krpc_connection_t connection, krpc_SpaceCenter_SolarPanel_t * returnValue, krpc_SpaceCenter_Part_t instance);

/**
 * The stage in which this part will be decoupled. Returns -1 if the part is never
 * decoupled from the vessel.
 */
krpc_error_t krpc_SpaceCenter_Part_DecoupleStage(krpc_connection_t connection, int32_t * returnValue, krpc_SpaceCenter_Part_t instance);

/**
 * A SpaceCenter::Wheel if the part is a wheel, otherwise null.
 */
krpc_error_t krpc_SpaceCenter_Part_Wheel(krpc_connection_t connection, krpc_SpaceCenter_Wheel_t * returnValue, krpc_SpaceCenter_Part_t instance);

/**
 * The dynamic pressure acting on the part, in Pascals.
 */
krpc_error_t krpc_SpaceCenter_Part_DynamicPressure(krpc_connection_t connection, float * returnValue, krpc_SpaceCenter_Part_t instance);

/**
 * Maximum temperature that the skin of the part can survive, in Kelvin.
 */
krpc_error_t krpc_SpaceCenter_Part_MaxSkinTemperature(krpc_connection_t connection, double * returnValue, krpc_SpaceCenter_Part_t instance);

/**
 * Whether this part is a fuel line.
 */
krpc_error_t krpc_SpaceCenter_Part_IsFuelLine(krpc_connection_t connection, bool * returnValue, krpc_SpaceCenter_Part_t instance);

/**
 * The impact tolerance of the part, in meters per second.
 */
krpc_error_t krpc_SpaceCenter_Part_ImpactTolerance(krpc_connection_t connection, double * returnValue, krpc_SpaceCenter_Part_t instance);

/**
 * An SpaceCenter::Intake if the part is an intake, otherwise null.
 *
 * This includes any part that generates thrust. This covers many different types
 * of engine, including liquid fuel rockets, solid rocket boosters and jet engines.
 * For RCS thrusters see SpaceCenter::RCS.
 */
krpc_error_t krpc_SpaceCenter_Part_Intake(krpc_connection_t connection, krpc_SpaceCenter_Intake_t * returnValue, krpc_SpaceCenter_Part_t instance);

/**
 * A SpaceCenter::ResourceHarvester if the part is a resource harvester,
 * otherwise null.
 */
krpc_error_t krpc_SpaceCenter_Part_ResourceHarvester(krpc_connection_t connection, krpc_SpaceCenter_ResourceHarvester_t * returnValue, krpc_SpaceCenter_Part_t instance);

/**
 * Temperature of the part, in Kelvin.
 */
krpc_error_t krpc_SpaceCenter_Part_Temperature(krpc_connection_t connection, double * returnValue, krpc_SpaceCenter_Part_t instance);

/**
 * Internal name of the part, as used in
 * <a href="https://wiki.kerbalspaceprogram.com/wiki/CFG_File_Documentation">part cfg files</a>.
 * For example "Mark1-2Pod".
 */
krpc_error_t krpc_SpaceCenter_Part_Name(krpc_connection_t connection, char * * returnValue, krpc_SpaceCenter_Part_t instance);

/**
 * The rate at which heat energy is transferring between the part's skin and its internals.
 * Measured in energy per unit time, or power, in Watts.
 * A positive value means the part's internals are gaining heat energy,
 * and negative means its skin is gaining heat energy.
 */
krpc_error_t krpc_SpaceCenter_Part_ThermalSkinToInternalFlux(krpc_connection_t connection, float * returnValue, krpc_SpaceCenter_Part_t instance);

/**
 * Whether the part is shielded from the exterior of the vessel, for example by a fairing.
 */
krpc_error_t krpc_SpaceCenter_Part_Shielded(krpc_connection_t connection, bool * returnValue, krpc_SpaceCenter_Part_t instance);

/**
 * A SpaceCenter::Decoupler if the part is a decoupler, otherwise null.
 */
krpc_error_t krpc_SpaceCenter_Part_Decoupler(krpc_connection_t connection, krpc_SpaceCenter_Decoupler_t * returnValue, krpc_SpaceCenter_Part_t instance);

/**
 * A SpaceCenter::Light if the part is a light, otherwise null.
 */
krpc_error_t krpc_SpaceCenter_Part_Light(krpc_connection_t connection, krpc_SpaceCenter_Light_t * returnValue, krpc_SpaceCenter_Part_t instance);

/**
 * The modules for this part.
 */
krpc_error_t krpc_SpaceCenter_Part_Modules(krpc_connection_t connection, krpc_list_object_t * returnValue, krpc_SpaceCenter_Part_t instance);

/**
 * The name tag for the part. Can be set to a custom string using the
 * in-game user interface.
 *
 * This requires either the
 * <a href="https://github.com/krpc/NameTag/releases/latest">NameTag</a> or
 * <a href="https://forum.kerbalspaceprogram.com/index.php?/topic/61827-/">kOS</a>
 * mod to be installed.
 */
krpc_error_t krpc_SpaceCenter_Part_set_Tag(krpc_connection_t connection, krpc_SpaceCenter_Part_t instance, const char * value);

/**
 * A SpaceCenter::Radiator if the part is a radiator, otherwise null.
 */
krpc_error_t krpc_SpaceCenter_Part_Radiator(krpc_connection_t connection, krpc_SpaceCenter_Radiator_t * returnValue, krpc_SpaceCenter_Part_t instance);

/**
 * The name tag for the part. Can be set to a custom string using the
 * in-game user interface.
 *
 * This requires either the
 * <a href="https://github.com/krpc/NameTag/releases/latest">NameTag</a> or
 * <a href="https://forum.kerbalspaceprogram.com/index.php?/topic/61827-/">kOS</a>
 * mod to be installed.
 */
krpc_error_t krpc_SpaceCenter_Part_Tag(krpc_connection_t connection, char * * returnValue, krpc_SpaceCenter_Part_t instance);

/**
 * A SpaceCenter::ReactionWheel if the part is a reaction wheel, otherwise null.
 */
krpc_error_t krpc_SpaceCenter_Part_ReactionWheel(krpc_connection_t connection, krpc_SpaceCenter_ReactionWheel_t * returnValue, krpc_SpaceCenter_Part_t instance);

/**
 * The current mass of the part, including resources it contains, in kilograms.
 * Returns zero if the part is massless.
 */
krpc_error_t krpc_SpaceCenter_Part_Mass(krpc_connection_t connection, double * returnValue, krpc_SpaceCenter_Part_t instance);

/**
 * Whether the part is axially attached to its parent, i.e. on the top
 * or bottom of its parent. If the part has no parent, returns false.
 */
krpc_error_t krpc_SpaceCenter_Part_AxiallyAttached(krpc_connection_t connection, bool * returnValue, krpc_SpaceCenter_Part_t instance);

/**
 * A measure of how much energy it takes to increase the skin temperature of the part,
 * in Joules per Kelvin.
 */
krpc_error_t krpc_SpaceCenter_Part_ThermalSkinMass(krpc_connection_t connection, float * returnValue, krpc_SpaceCenter_Part_t instance);

/**
 * The rate at which heat energy is begin generated by the part.
 * For example, some engines generate heat by combusting fuel.
 * Measured in energy per unit time, or power, in Watts.
 * A positive value means the part is gaining heat energy, and negative means it is losing
 * heat energy.
 */
krpc_error_t krpc_SpaceCenter_Part_ThermalInternalFlux(krpc_connection_t connection, float * returnValue, krpc_SpaceCenter_Part_t instance);

/**
 * Temperature of the skin of the part, in Kelvin.
 */
krpc_error_t krpc_SpaceCenter_Part_SkinTemperature(krpc_connection_t connection, double * returnValue, krpc_SpaceCenter_Part_t instance);

/**
 * A SpaceCenter::DockingPort if the part is a docking port, otherwise null.
 */
krpc_error_t krpc_SpaceCenter_Part_DockingPort(krpc_connection_t connection, krpc_SpaceCenter_DockingPort_t * returnValue, krpc_SpaceCenter_Part_t instance);

/**
 * A SpaceCenter::CargoBay if the part is a cargo bay, otherwise null.
 */
krpc_error_t krpc_SpaceCenter_Part_CargoBay(krpc_connection_t connection, krpc_SpaceCenter_CargoBay_t * returnValue, krpc_SpaceCenter_Part_t instance);

/**
 * Maximum temperature that the part can survive, in Kelvin.
 */
krpc_error_t krpc_SpaceCenter_Part_MaxTemperature(krpc_connection_t connection, double * returnValue, krpc_SpaceCenter_Part_t instance);

/**
 * Whether the part is highlighted.
 */
krpc_error_t krpc_SpaceCenter_Part_set_Highlighted(krpc_connection_t connection, krpc_SpaceCenter_Part_t instance, bool value);

/**
 * The color used to highlight the part, as an RGB triple.
 */
krpc_error_t krpc_SpaceCenter_Part_set_HighlightColor(krpc_connection_t connection, krpc_SpaceCenter_Part_t instance, const krpc_tuple_double_double_double_t * value);

/**
 * A SpaceCenter::Fairing if the part is a fairing, otherwise null.
 */
krpc_error_t krpc_SpaceCenter_Part_Fairing(krpc_connection_t connection, krpc_SpaceCenter_Fairing_t * returnValue, krpc_SpaceCenter_Part_t instance);

/**
 * A SpaceCenter::ControlSurface if the part is an aerodynamic control surface,
 * otherwise null.
 */
krpc_error_t krpc_SpaceCenter_Part_ControlSurface(krpc_connection_t connection, krpc_SpaceCenter_ControlSurface_t * returnValue, krpc_SpaceCenter_Part_t instance);

/**
 * A SpaceCenter::LaunchClamp if the part is a launch clamp, otherwise null.
 */
krpc_error_t krpc_SpaceCenter_Part_LaunchClamp(krpc_connection_t connection, krpc_SpaceCenter_LaunchClamp_t * returnValue, krpc_SpaceCenter_Part_t instance);

/**
 * A SpaceCenter::Parachute if the part is a parachute, otherwise null.
 */
krpc_error_t krpc_SpaceCenter_Part_Parachute(krpc_connection_t connection, krpc_SpaceCenter_Parachute_t * returnValue, krpc_SpaceCenter_Part_t instance);

/**
 * The mass of the part, not including any resources it contains, in kilograms.
 * Returns zero if the part is massless.
 */
krpc_error_t krpc_SpaceCenter_Part_DryMass(krpc_connection_t connection, double * returnValue, krpc_SpaceCenter_Part_t instance);

/**
 * The cost of the part, in units of funds.
 */
krpc_error_t krpc_SpaceCenter_Part_Cost(krpc_connection_t connection, double * returnValue, krpc_SpaceCenter_Part_t instance);

/**
 * The vessel that contains this part.
 */
krpc_error_t krpc_SpaceCenter_Part_Vessel(krpc_connection_t connection, krpc_SpaceCenter_Vessel_t * returnValue, krpc_SpaceCenter_Part_t instance);

/**
 * The stage in which this part will be activated. Returns -1 if the part is not
 * activated by staging.
 */
krpc_error_t krpc_SpaceCenter_Part_Stage(krpc_connection_t connection, int32_t * returnValue, krpc_SpaceCenter_Part_t instance);

/**
 * The parts children. Returns an empty list if the part has no children.
 * This, in combination with SpaceCenter::Part::parent, can be used to traverse the vessels
 * parts tree.
 */
krpc_error_t krpc_SpaceCenter_Part_Children(krpc_connection_t connection, krpc_list_object_t * returnValue, krpc_SpaceCenter_Part_t instance);

/**
 * A measure of how much energy it takes to increase the temperature of the resources
 * contained in the part, in Joules per Kelvin.
 */
krpc_error_t krpc_SpaceCenter_Part_ThermalResourceMass(krpc_connection_t connection, float * returnValue, krpc_SpaceCenter_Part_t instance);

/**
 * A list of all parts that are decoupled in the given stage.
 * @param stage
 */
krpc_error_t krpc_SpaceCenter_Parts_InDecoupleStage(krpc_connection_t connection, krpc_list_object_t * returnValue, krpc_SpaceCenter_Parts_t instance, int32_t stage);

/**
 * A list of all parts that are activated in the given stage.
 * @param stage
 */
krpc_error_t krpc_SpaceCenter_Parts_InStage(krpc_connection_t connection, krpc_list_object_t * returnValue, krpc_SpaceCenter_Parts_t instance, int32_t stage);

/**
 * A list of modules (combined across all parts in the vessel) whose
 * SpaceCenter::Module::name is moduleName.
 * @param moduleName
 */
krpc_error_t krpc_SpaceCenter_Parts_ModulesWithName(krpc_connection_t connection, krpc_list_object_t * returnValue, krpc_SpaceCenter_Parts_t instance, const char * moduleName);

/**
 * A list of all parts that contain a SpaceCenter::Module whose
 * SpaceCenter::Module::name is moduleName.
 * @param moduleName
 */
krpc_error_t krpc_SpaceCenter_Parts_WithModule(krpc_connection_t connection, krpc_list_object_t * returnValue, krpc_SpaceCenter_Parts_t instance, const char * moduleName);

/**
 * A list of parts whose SpaceCenter::Part::name is name.
 * @param name
 */
krpc_error_t krpc_SpaceCenter_Parts_WithName(krpc_connection_t connection, krpc_list_object_t * returnValue, krpc_SpaceCenter_Parts_t instance, const char * name);

/**
 * A list of all parts whose SpaceCenter::Part::tag is tag.
 * @param tag
 */
krpc_error_t krpc_SpaceCenter_Parts_WithTag(krpc_connection_t connection, krpc_list_object_t * returnValue, krpc_SpaceCenter_Parts_t instance, const char * tag);

/**
 * A list of all parts whose SpaceCenter::Part::title is title.
 * @param title
 */
krpc_error_t krpc_SpaceCenter_Parts_WithTitle(krpc_connection_t connection, krpc_list_object_t * returnValue, krpc_SpaceCenter_Parts_t instance, const char * title);

/**
 * A list of all resource converters in the vessel.
 */
krpc_error_t krpc_SpaceCenter_Parts_ResourceConverters(krpc_connection_t connection, krpc_list_object_t * returnValue, krpc_SpaceCenter_Parts_t instance);

/**
 * A list of all engines in the vessel.
 *
 * This includes any part that generates thrust. This covers many different types
 * of engine, including liquid fuel rockets, solid rocket boosters, jet engines and
 * RCS thrusters.
 */
krpc_error_t krpc_SpaceCenter_Parts_Engines(krpc_connection_t connection, krpc_list_object_t * returnValue, krpc_SpaceCenter_Parts_t instance);

/**
 * A list of all RCS blocks/thrusters in the vessel.
 */
krpc_error_t krpc_SpaceCenter_Parts_RCS(krpc_connection_t connection, krpc_list_object_t * returnValue, krpc_SpaceCenter_Parts_t instance);

/**
 * A list of all lights in the vessel.
 */
krpc_error_t krpc_SpaceCenter_Parts_Lights(krpc_connection_t connection, krpc_list_object_t * returnValue, krpc_SpaceCenter_Parts_t instance);

/**
 * A list of all resource harvesters in the vessel.
 */
krpc_error_t krpc_SpaceCenter_Parts_ResourceHarvesters(krpc_connection_t connection, krpc_list_object_t * returnValue, krpc_SpaceCenter_Parts_t instance);

/**
 * A list of all landing legs attached to the vessel.
 */
krpc_error_t krpc_SpaceCenter_Parts_Legs(krpc_connection_t connection, krpc_list_object_t * returnValue, krpc_SpaceCenter_Parts_t instance);

/**
 * A list of all launch clamps attached to the vessel.
 */
krpc_error_t krpc_SpaceCenter_Parts_LaunchClamps(krpc_connection_t connection, krpc_list_object_t * returnValue, krpc_SpaceCenter_Parts_t instance);

/**
 * The part from which the vessel is controlled.
 */
krpc_error_t krpc_SpaceCenter_Parts_set_Controlling(krpc_connection_t connection, krpc_SpaceCenter_Parts_t instance, krpc_SpaceCenter_Part_t value);

/**
 * A list of all fairings in the vessel.
 */
krpc_error_t krpc_SpaceCenter_Parts_Fairings(krpc_connection_t connection, krpc_list_object_t * returnValue, krpc_SpaceCenter_Parts_t instance);

/**
 * A list of all cargo bays in the vessel.
 */
krpc_error_t krpc_SpaceCenter_Parts_CargoBays(krpc_connection_t connection, krpc_list_object_t * returnValue, krpc_SpaceCenter_Parts_t instance);

/**
 * The part from which the vessel is controlled.
 */
krpc_error_t krpc_SpaceCenter_Parts_Controlling(krpc_connection_t connection, krpc_SpaceCenter_Part_t * returnValue, krpc_SpaceCenter_Parts_t instance);

/**
 * A list of all docking ports in the vessel.
 */
krpc_error_t krpc_SpaceCenter_Parts_DockingPorts(krpc_connection_t connection, krpc_list_object_t * returnValue, krpc_SpaceCenter_Parts_t instance);

/**
 * A list of all intakes in the vessel.
 */
krpc_error_t krpc_SpaceCenter_Parts_Intakes(krpc_connection_t connection, krpc_list_object_t * returnValue, krpc_SpaceCenter_Parts_t instance);

/**
 * A list of all sensors in the vessel.
 */
krpc_error_t krpc_SpaceCenter_Parts_Sensors(krpc_connection_t connection, krpc_list_object_t * returnValue, krpc_SpaceCenter_Parts_t instance);

/**
 * A list of all control surfaces in the vessel.
 */
krpc_error_t krpc_SpaceCenter_Parts_ControlSurfaces(krpc_connection_t connection, krpc_list_object_t * returnValue, krpc_SpaceCenter_Parts_t instance);

/**
 * A list of all antennas in the vessel.
 */
krpc_error_t krpc_SpaceCenter_Parts_Antennas(krpc_connection_t connection, krpc_list_object_t * returnValue, krpc_SpaceCenter_Parts_t instance);

/**
 * A list of all parachutes in the vessel.
 */
krpc_error_t krpc_SpaceCenter_Parts_Parachutes(krpc_connection_t connection, krpc_list_object_t * returnValue, krpc_SpaceCenter_Parts_t instance);

/**
 * A list of all wheels in the vessel.
 */
krpc_error_t krpc_SpaceCenter_Parts_Wheels(krpc_connection_t connection, krpc_list_object_t * returnValue, krpc_SpaceCenter_Parts_t instance);

/**
 * The vessels root part.
 */
krpc_error_t krpc_SpaceCenter_Parts_Root(krpc_connection_t connection, krpc_SpaceCenter_Part_t * returnValue, krpc_SpaceCenter_Parts_t instance);

/**
 * A list of all of the vessels parts.
 */
krpc_error_t krpc_SpaceCenter_Parts_All(krpc_connection_t connection, krpc_list_object_t * returnValue, krpc_SpaceCenter_Parts_t instance);

/**
 * A list of all reaction wheels in the vessel.
 */
krpc_error_t krpc_SpaceCenter_Parts_ReactionWheels(krpc_connection_t connection, krpc_list_object_t * returnValue, krpc_SpaceCenter_Parts_t instance);

/**
 * A list of all radiators in the vessel.
 */
krpc_error_t krpc_SpaceCenter_Parts_Radiators(krpc_connection_t connection, krpc_list_object_t * returnValue, krpc_SpaceCenter_Parts_t instance);

/**
 * A list of all solar panels in the vessel.
 */
krpc_error_t krpc_SpaceCenter_Parts_SolarPanels(krpc_connection_t connection, krpc_list_object_t * returnValue, krpc_SpaceCenter_Parts_t instance);

/**
 * A list of all science experiments in the vessel.
 */
krpc_error_t krpc_SpaceCenter_Parts_Experiments(krpc_connection_t connection, krpc_list_object_t * returnValue, krpc_SpaceCenter_Parts_t instance);

/**
 * A list of all decouplers in the vessel.
 */
krpc_error_t krpc_SpaceCenter_Parts_Decouplers(krpc_connection_t connection, krpc_list_object_t * returnValue, krpc_SpaceCenter_Parts_t instance);

/**
 * The propellant ratio.
 */
krpc_error_t krpc_SpaceCenter_Propellant_Ratio(krpc_connection_t connection, float * returnValue, krpc_SpaceCenter_Propellant_t instance);

/**
 * The name of the propellant.
 */
krpc_error_t krpc_SpaceCenter_Propellant_Name(krpc_connection_t connection, char * * returnValue, krpc_SpaceCenter_Propellant_t instance);

/**
 * If this propellant should be ignored for thrust curve calculations.
 */
krpc_error_t krpc_SpaceCenter_Propellant_IgnoreForThrustCurve(krpc_connection_t connection, bool * returnValue, krpc_SpaceCenter_Propellant_t instance);

/**
 * If this propellant should be ignored when calculating required mass flow
 * given specific impulse.
 */
krpc_error_t krpc_SpaceCenter_Propellant_IgnoreForIsp(krpc_connection_t connection, bool * returnValue, krpc_SpaceCenter_Propellant_t instance);

/**
 * The current amount of propellant.
 */
krpc_error_t krpc_SpaceCenter_Propellant_CurrentAmount(krpc_connection_t connection, double * returnValue, krpc_SpaceCenter_Propellant_t instance);

/**
 * If this propellant is deprived.
 */
krpc_error_t krpc_SpaceCenter_Propellant_IsDeprived(krpc_connection_t connection, bool * returnValue, krpc_SpaceCenter_Propellant_t instance);

/**
 * If this propellant has a stack gauge or not.
 */
krpc_error_t krpc_SpaceCenter_Propellant_DrawStackGauge(krpc_connection_t connection, bool * returnValue, krpc_SpaceCenter_Propellant_t instance);

/**
 * The required amount of propellant.
 */
krpc_error_t krpc_SpaceCenter_Propellant_CurrentRequirement(krpc_connection_t connection, double * returnValue, krpc_SpaceCenter_Propellant_t instance);

/**
 * The total amount of the underlying resource currently reachable given
 * resource flow rules.
 */
krpc_error_t krpc_SpaceCenter_Propellant_TotalResourceAvailable(krpc_connection_t connection, double * returnValue, krpc_SpaceCenter_Propellant_t instance);

/**
 * The total vehicle capacity for the underlying propellant resource,
 * restricted by resource flow rules.
 */
krpc_error_t krpc_SpaceCenter_Propellant_TotalResourceCapacity(krpc_connection_t connection, double * returnValue, krpc_SpaceCenter_Propellant_t instance);

/**
 * The maximum amount of thrust that can be produced by the RCS thrusters when active
 * in a vacuum, in Newtons.
 */
krpc_error_t krpc_SpaceCenter_RCS_MaxVacuumThrust(krpc_connection_t connection, float * returnValue, krpc_SpaceCenter_RCS_t instance);

/**
 * Whether the RCS thruster will fire when roll control input is given.
 */
krpc_error_t krpc_SpaceCenter_RCS_RollEnabled(krpc_connection_t connection, bool * returnValue, krpc_SpaceCenter_RCS_t instance);

/**
 * Whether the RCS thrusters are enabled.
 */
krpc_error_t krpc_SpaceCenter_RCS_set_Enabled(krpc_connection_t connection, krpc_SpaceCenter_RCS_t instance, bool value);

/**
 * Whether the RCS thruster will fire when pitch control input is given.
 */
krpc_error_t krpc_SpaceCenter_RCS_ForwardEnabled(krpc_connection_t connection, bool * returnValue, krpc_SpaceCenter_RCS_t instance);

/**
 * The maximum amount of thrust that can be produced by the RCS thrusters when active,
 * in Newtons.
 */
krpc_error_t krpc_SpaceCenter_RCS_MaxThrust(krpc_connection_t connection, float * returnValue, krpc_SpaceCenter_RCS_t instance);

/**
 * Whether the RCS thruster will fire when roll control input is given.
 */
krpc_error_t krpc_SpaceCenter_RCS_set_RightEnabled(krpc_connection_t connection, krpc_SpaceCenter_RCS_t instance, bool value);

/**
 * The part object for this RCS.
 */
krpc_error_t krpc_SpaceCenter_RCS_Part(krpc_connection_t connection, krpc_SpaceCenter_Part_t * returnValue, krpc_SpaceCenter_RCS_t instance);

/**
 * A list of thrusters, one of each nozzel in the RCS part.
 */
krpc_error_t krpc_SpaceCenter_RCS_Thrusters(krpc_connection_t connection, krpc_list_object_t * returnValue, krpc_SpaceCenter_RCS_t instance);

/**
 * Whether the RCS thrusters are active.
 * An RCS thruster is inactive if the RCS action group is disabled
 * (SpaceCenter::Control::rcs), the RCS thruster itself is not enabled
 * (SpaceCenter::RCS::enabled) or it is covered by a fairing (SpaceCenter::Part::shielded).
 */
krpc_error_t krpc_SpaceCenter_RCS_Active(krpc_connection_t connection, bool * returnValue, krpc_SpaceCenter_RCS_t instance);

/**
 * The names of resources that the RCS consumes.
 */
krpc_error_t krpc_SpaceCenter_RCS_Propellants(krpc_connection_t connection, krpc_list_string_t * returnValue, krpc_SpaceCenter_RCS_t instance);

/**
 * Whether the RCS has fuel available.
 *
 * The RCS thruster must be activated for this property to update correctly.
 */
krpc_error_t krpc_SpaceCenter_RCS_HasFuel(krpc_connection_t connection, bool * returnValue, krpc_SpaceCenter_RCS_t instance);

/**
 * The ratios of resources that the RCS consumes. A dictionary mapping resource names
 * to the ratios at which they are consumed by the RCS.
 */
krpc_error_t krpc_SpaceCenter_RCS_PropellantRatios(krpc_connection_t connection, krpc_dictionary_string_float_t * returnValue, krpc_SpaceCenter_RCS_t instance);

/**
 * Whether the RCS thrusters are enabled.
 */
krpc_error_t krpc_SpaceCenter_RCS_Enabled(krpc_connection_t connection, bool * returnValue, krpc_SpaceCenter_RCS_t instance);

/**
 * Whether the RCS thruster will fire when pitch control input is given.
 */
krpc_error_t krpc_SpaceCenter_RCS_PitchEnabled(krpc_connection_t connection, bool * returnValue, krpc_SpaceCenter_RCS_t instance);

/**
 * Whether the RCS thruster will fire when yaw control input is given.
 */
krpc_error_t krpc_SpaceCenter_RCS_set_UpEnabled(krpc_connection_t connection, krpc_SpaceCenter_RCS_t instance, bool value);

/**
 * Whether the RCS thruster will fire when yaw control input is given.
 */
krpc_error_t krpc_SpaceCenter_RCS_set_YawEnabled(krpc_connection_t connection, krpc_SpaceCenter_RCS_t instance, bool value);

/**
 * Whether the RCS thruster will fire when pitch control input is given.
 */
krpc_error_t krpc_SpaceCenter_RCS_set_PitchEnabled(krpc_connection_t connection, krpc_SpaceCenter_RCS_t instance, bool value);

/**
 * The specific impulse of the RCS at sea level on Kerbin, in seconds.
 */
krpc_error_t krpc_SpaceCenter_RCS_KerbinSeaLevelSpecificImpulse(krpc_connection_t connection, float * returnValue, krpc_SpaceCenter_RCS_t instance);

/**
 * Whether the RCS thruster will fire when roll control input is given.
 */
krpc_error_t krpc_SpaceCenter_RCS_RightEnabled(krpc_connection_t connection, bool * returnValue, krpc_SpaceCenter_RCS_t instance);

/**
 * The available torque, in Newton meters, that can be produced by this RCS,
 * in the positive and negative pitch, roll and yaw axes of the vessel. These axes
 * correspond to the coordinate axes of the SpaceCenter::Vessel::reference_frame.
 * Returns zero if RCS is disable.
 */
krpc_error_t krpc_SpaceCenter_RCS_AvailableTorque(krpc_connection_t connection, krpc_tuple_tuple_double_double_double_tuple_double_double_double_t * returnValue, krpc_SpaceCenter_RCS_t instance);

/**
 * The current specific impulse of the RCS, in seconds. Returns zero
 * if the RCS is not active.
 */
krpc_error_t krpc_SpaceCenter_RCS_SpecificImpulse(krpc_connection_t connection, float * returnValue, krpc_SpaceCenter_RCS_t instance);

/**
 * Whether the RCS thruster will fire when pitch control input is given.
 */
krpc_error_t krpc_SpaceCenter_RCS_set_ForwardEnabled(krpc_connection_t connection, krpc_SpaceCenter_RCS_t instance, bool value);

/**
 * Whether the RCS thruster will fire when yaw control input is given.
 */
krpc_error_t krpc_SpaceCenter_RCS_UpEnabled(krpc_connection_t connection, bool * returnValue, krpc_SpaceCenter_RCS_t instance);

/**
 * Whether the RCS thruster will fire when roll control input is given.
 */
krpc_error_t krpc_SpaceCenter_RCS_set_RollEnabled(krpc_connection_t connection, krpc_SpaceCenter_RCS_t instance, bool value);

/**
 * The vacuum specific impulse of the RCS, in seconds.
 */
krpc_error_t krpc_SpaceCenter_RCS_VacuumSpecificImpulse(krpc_connection_t connection, float * returnValue, krpc_SpaceCenter_RCS_t instance);

/**
 * Whether the RCS thruster will fire when yaw control input is given.
 */
krpc_error_t krpc_SpaceCenter_RCS_YawEnabled(krpc_connection_t connection, bool * returnValue, krpc_SpaceCenter_RCS_t instance);

/**
 * For a deployable radiator, true if the radiator is extended.
 * If the radiator is not deployable, this is always true.
 */
krpc_error_t krpc_SpaceCenter_Radiator_set_Deployed(krpc_connection_t connection, krpc_SpaceCenter_Radiator_t instance, bool value);

/**
 * The current state of the radiator.
 *
 * A fixed radiator is always SpaceCenter::RadiatorState::extended.
 */
krpc_error_t krpc_SpaceCenter_Radiator_State(krpc_connection_t connection, krpc_SpaceCenter_RadiatorState_t * returnValue, krpc_SpaceCenter_Radiator_t instance);

/**
 * The part object for this radiator.
 */
krpc_error_t krpc_SpaceCenter_Radiator_Part(krpc_connection_t connection, krpc_SpaceCenter_Part_t * returnValue, krpc_SpaceCenter_Radiator_t instance);

/**
 * For a deployable radiator, true if the radiator is extended.
 * If the radiator is not deployable, this is always true.
 */
krpc_error_t krpc_SpaceCenter_Radiator_Deployed(krpc_connection_t connection, bool * returnValue, krpc_SpaceCenter_Radiator_t instance);

/**
 * Whether the radiator is deployable.
 */
krpc_error_t krpc_SpaceCenter_Radiator_Deployable(krpc_connection_t connection, bool * returnValue, krpc_SpaceCenter_Radiator_t instance);

/**
 * The maximum torque, in Newton meters, that can be produced by this reaction wheel,
 * when it is active, in the positive and negative pitch, roll and yaw axes of the vessel.
 * These axes correspond to the coordinate axes of the SpaceCenter::Vessel::reference_frame.
 */
krpc_error_t krpc_SpaceCenter_ReactionWheel_MaxTorque(krpc_connection_t connection, krpc_tuple_tuple_double_double_double_tuple_double_double_double_t * returnValue, krpc_SpaceCenter_ReactionWheel_t instance);

/**
 * Whether the reaction wheel is active.
 */
krpc_error_t krpc_SpaceCenter_ReactionWheel_set_Active(krpc_connection_t connection, krpc_SpaceCenter_ReactionWheel_t instance, bool value);

/**
 * Whether the reaction wheel is broken.
 */
krpc_error_t krpc_SpaceCenter_ReactionWheel_Broken(krpc_connection_t connection, bool * returnValue, krpc_SpaceCenter_ReactionWheel_t instance);

/**
 * The part object for this reaction wheel.
 */
krpc_error_t krpc_SpaceCenter_ReactionWheel_Part(krpc_connection_t connection, krpc_SpaceCenter_Part_t * returnValue, krpc_SpaceCenter_ReactionWheel_t instance);

/**
 * Whether the reaction wheel is active.
 */
krpc_error_t krpc_SpaceCenter_ReactionWheel_Active(krpc_connection_t connection, bool * returnValue, krpc_SpaceCenter_ReactionWheel_t instance);

/**
 * The available torque, in Newton meters, that can be produced by this reaction wheel,
 * in the positive and negative pitch, roll and yaw axes of the vessel. These axes
 * correspond to the coordinate axes of the SpaceCenter::Vessel::reference_frame.
 * Returns zero if the reaction wheel is inactive or broken.
 */
krpc_error_t krpc_SpaceCenter_ReactionWheel_AvailableTorque(krpc_connection_t connection, krpc_tuple_tuple_double_double_double_tuple_double_double_double_t * returnValue, krpc_SpaceCenter_ReactionWheel_t instance);

/**
 * Create a hybrid reference frame. This is a custom reference frame
 * whose components inherited from other reference frames.
 * @param position The reference frame providing the position of the origin.
 * @param rotation The reference frame providing the rotation of the frame.
 * @param velocity The reference frame providing the linear velocity of the frame.
 * @param angularVelocity The reference frame providing the angular velocity
 * of the frame.
 *
 * The position reference frame is required but all other
 * reference frames are optional. If omitted, they are set to the
 * position reference frame.
 */
krpc_error_t krpc_SpaceCenter_ReferenceFrame_CreateHybrid(krpc_connection_t connection, krpc_SpaceCenter_ReferenceFrame_t * returnValue, krpc_SpaceCenter_ReferenceFrame_t position, krpc_SpaceCenter_ReferenceFrame_t rotation, krpc_SpaceCenter_ReferenceFrame_t velocity, krpc_SpaceCenter_ReferenceFrame_t angularVelocity);

/**
 * Create a relative reference frame. This is a custom reference frame
 * whose components offset the components of a parent reference frame.
 * @param referenceFrame The parent reference frame on which to
 * base this reference frame.
 * @param position The offset of the position of the origin,
 * as a position vector. Defaults to (0, 0, 0)
 * @param rotation The rotation to apply to the parent frames rotation,
 * as a quaternion of the form (x, y, z, w).
 * Defaults to (0, 0, 0, 1) (i.e. no rotation)
 * @param velocity The linear velocity to offset the parent frame by,
 * as a vector pointing in the direction of travel, whose magnitude is the speed in
 * meters per second. Defaults to (0, 0, 0).
 * @param angularVelocity The angular velocity to offset the parent frame by,
 * as a vector. This vector points in the direction of the axis of rotation,
 * and its magnitude is the speed of the rotation in radians per second.
 * Defaults to (0, 0, 0).
 */
krpc_error_t krpc_SpaceCenter_ReferenceFrame_CreateRelative(krpc_connection_t connection, krpc_SpaceCenter_ReferenceFrame_t * returnValue, krpc_SpaceCenter_ReferenceFrame_t referenceFrame, const krpc_tuple_double_double_double_t * position, const krpc_tuple_double_double_double_double_t * rotation, const krpc_tuple_double_double_double_t * velocity, const krpc_tuple_double_double_double_t * angularVelocity);

/**
 * The name of the resource.
 */
krpc_error_t krpc_SpaceCenter_Resource_Name(krpc_connection_t connection, char * * returnValue, krpc_SpaceCenter_Resource_t instance);

/**
 * The density of the resource, in kg/l.
 */
krpc_error_t krpc_SpaceCenter_Resource_Density(krpc_connection_t connection, float * returnValue, krpc_SpaceCenter_Resource_t instance);

/**
 * The total amount of the resource that can be stored in the part.
 */
krpc_error_t krpc_SpaceCenter_Resource_Max(krpc_connection_t connection, float * returnValue, krpc_SpaceCenter_Resource_t instance);

/**
 * Whether use of this resource is enabled.
 */
krpc_error_t krpc_SpaceCenter_Resource_Enabled(krpc_connection_t connection, bool * returnValue, krpc_SpaceCenter_Resource_t instance);

/**
 * The flow mode of the resource.
 */
krpc_error_t krpc_SpaceCenter_Resource_FlowMode(krpc_connection_t connection, krpc_SpaceCenter_ResourceFlowMode_t * returnValue, krpc_SpaceCenter_Resource_t instance);

/**
 * The amount of the resource that is currently stored in the part.
 */
krpc_error_t krpc_SpaceCenter_Resource_Amount(krpc_connection_t connection, float * returnValue, krpc_SpaceCenter_Resource_t instance);

/**
 * The part containing the resource.
 */
krpc_error_t krpc_SpaceCenter_Resource_Part(krpc_connection_t connection, krpc_SpaceCenter_Part_t * returnValue, krpc_SpaceCenter_Resource_t instance);

/**
 * Whether use of this resource is enabled.
 */
krpc_error_t krpc_SpaceCenter_Resource_set_Enabled(krpc_connection_t connection, krpc_SpaceCenter_Resource_t instance, bool value);

/**
 * True if the specified converter is active.
 * @param index Index of the converter.
 */
krpc_error_t krpc_SpaceCenter_ResourceConverter_Active(krpc_connection_t connection, bool * returnValue, krpc_SpaceCenter_ResourceConverter_t instance, int32_t index);

/**
 * List of the names of resources consumed by the specified converter.
 * @param index Index of the converter.
 */
krpc_error_t krpc_SpaceCenter_ResourceConverter_Inputs(krpc_connection_t connection, krpc_list_string_t * returnValue, krpc_SpaceCenter_ResourceConverter_t instance, int32_t index);

/**
 * The name of the specified converter.
 * @param index Index of the converter.
 */
krpc_error_t krpc_SpaceCenter_ResourceConverter_Name(krpc_connection_t connection, char * * returnValue, krpc_SpaceCenter_ResourceConverter_t instance, int32_t index);

/**
 * List of the names of resources produced by the specified converter.
 * @param index Index of the converter.
 */
krpc_error_t krpc_SpaceCenter_ResourceConverter_Outputs(krpc_connection_t connection, krpc_list_string_t * returnValue, krpc_SpaceCenter_ResourceConverter_t instance, int32_t index);

/**
 * Start the specified converter.
 * @param index Index of the converter.
 */
krpc_error_t krpc_SpaceCenter_ResourceConverter_Start(krpc_connection_t connection, krpc_SpaceCenter_ResourceConverter_t instance, int32_t index);

/**
 * The state of the specified converter.
 * @param index Index of the converter.
 */
krpc_error_t krpc_SpaceCenter_ResourceConverter_State(krpc_connection_t connection, krpc_SpaceCenter_ResourceConverterState_t * returnValue, krpc_SpaceCenter_ResourceConverter_t instance, int32_t index);

/**
 * Status information for the specified converter.
 * This is the full status message shown in the in-game UI.
 * @param index Index of the converter.
 */
krpc_error_t krpc_SpaceCenter_ResourceConverter_StatusInfo(krpc_connection_t connection, char * * returnValue, krpc_SpaceCenter_ResourceConverter_t instance, int32_t index);

/**
 * Stop the specified converter.
 * @param index Index of the converter.
 */
krpc_error_t krpc_SpaceCenter_ResourceConverter_Stop(krpc_connection_t connection, krpc_SpaceCenter_ResourceConverter_t instance, int32_t index);

/**
 * The number of converters in the part.
 */
krpc_error_t krpc_SpaceCenter_ResourceConverter_Count(krpc_connection_t connection, int32_t * returnValue, krpc_SpaceCenter_ResourceConverter_t instance);

/**
 * The part object for this converter.
 */
krpc_error_t krpc_SpaceCenter_ResourceConverter_Part(krpc_connection_t connection, krpc_SpaceCenter_Part_t * returnValue, krpc_SpaceCenter_ResourceConverter_t instance);

/**
 * Whether the harvester is deployed.
 */
krpc_error_t krpc_SpaceCenter_ResourceHarvester_set_Deployed(krpc_connection_t connection, krpc_SpaceCenter_ResourceHarvester_t instance, bool value);

/**
 * The thermal efficiency of the drill, as a percentage of its maximum.
 */
krpc_error_t krpc_SpaceCenter_ResourceHarvester_ThermalEfficiency(krpc_connection_t connection, float * returnValue, krpc_SpaceCenter_ResourceHarvester_t instance);

/**
 * The core temperature at which the drill will operate with peak efficiency, in Kelvin.
 */
krpc_error_t krpc_SpaceCenter_ResourceHarvester_OptimumCoreTemperature(krpc_connection_t connection, float * returnValue, krpc_SpaceCenter_ResourceHarvester_t instance);

/**
 * Whether the harvester is actively drilling.
 */
krpc_error_t krpc_SpaceCenter_ResourceHarvester_set_Active(krpc_connection_t connection, krpc_SpaceCenter_ResourceHarvester_t instance, bool value);

/**
 * The rate at which the drill is extracting ore, in units per second.
 */
krpc_error_t krpc_SpaceCenter_ResourceHarvester_ExtractionRate(krpc_connection_t connection, float * returnValue, krpc_SpaceCenter_ResourceHarvester_t instance);

/**
 * The state of the harvester.
 */
krpc_error_t krpc_SpaceCenter_ResourceHarvester_State(krpc_connection_t connection, krpc_SpaceCenter_ResourceHarvesterState_t * returnValue, krpc_SpaceCenter_ResourceHarvester_t instance);

/**
 * The part object for this harvester.
 */
krpc_error_t krpc_SpaceCenter_ResourceHarvester_Part(krpc_connection_t connection, krpc_SpaceCenter_Part_t * returnValue, krpc_SpaceCenter_ResourceHarvester_t instance);

/**
 * The core temperature of the drill, in Kelvin.
 */
krpc_error_t krpc_SpaceCenter_ResourceHarvester_CoreTemperature(krpc_connection_t connection, float * returnValue, krpc_SpaceCenter_ResourceHarvester_t instance);

/**
 * Whether the harvester is actively drilling.
 */
krpc_error_t krpc_SpaceCenter_ResourceHarvester_Active(krpc_connection_t connection, bool * returnValue, krpc_SpaceCenter_ResourceHarvester_t instance);

/**
 * Whether the harvester is deployed.
 */
krpc_error_t krpc_SpaceCenter_ResourceHarvester_Deployed(krpc_connection_t connection, bool * returnValue, krpc_SpaceCenter_ResourceHarvester_t instance);

/**
 * Start transferring a resource transfer between a pair of parts. The transfer will move
 * at most maxAmount units of the resource, depending on how much of
 * the resource is available in the source part and how much storage is available in the
 * destination part.
 * Use SpaceCenter::ResourceTransfer::complete to check if the transfer is complete.
 * Use SpaceCenter::ResourceTransfer::amount to see how much of the resource has been transferred.
 * @param fromPart The part to transfer to.
 * @param toPart The part to transfer from.
 * @param resource The name of the resource to transfer.
 * @param maxAmount The maximum amount of resource to transfer.
 */
krpc_error_t krpc_SpaceCenter_ResourceTransfer_Start(krpc_connection_t connection, krpc_SpaceCenter_ResourceTransfer_t * returnValue, krpc_SpaceCenter_Part_t fromPart, krpc_SpaceCenter_Part_t toPart, const char * resource, float maxAmount);

/**
 * The amount of the resource that has been transferred.
 */
krpc_error_t krpc_SpaceCenter_ResourceTransfer_Amount(krpc_connection_t connection, float * returnValue, krpc_SpaceCenter_ResourceTransfer_t instance);

/**
 * Whether the transfer has completed.
 */
krpc_error_t krpc_SpaceCenter_ResourceTransfer_Complete(krpc_connection_t connection, bool * returnValue, krpc_SpaceCenter_ResourceTransfer_t instance);

/**
 * Returns the amount of a resource that is currently stored.
 * @param name The name of the resource.
 */
krpc_error_t krpc_SpaceCenter_Resources_Amount(krpc_connection_t connection, float * returnValue, krpc_SpaceCenter_Resources_t instance, const char * name);

/**
 * Check whether the named resource can be stored.
 * @param name The name of the resource.
 */
krpc_error_t krpc_SpaceCenter_Resources_HasResource(krpc_connection_t connection, bool * returnValue, krpc_SpaceCenter_Resources_t instance, const char * name);

/**
 * Returns the amount of a resource that can be stored.
 * @param name The name of the resource.
 */
krpc_error_t krpc_SpaceCenter_Resources_Max(krpc_connection_t connection, float * returnValue, krpc_SpaceCenter_Resources_t instance, const char * name);

/**
 * All the individual resources with the given name that can be stored.
 */
krpc_error_t krpc_SpaceCenter_Resources_WithResource(krpc_connection_t connection, krpc_list_object_t * returnValue, krpc_SpaceCenter_Resources_t instance, const char * name);

/**
 * Returns the density of a resource, in kg/l.
 * @param name The name of the resource.
 */
krpc_error_t krpc_SpaceCenter_Resources_Density(krpc_connection_t connection, float * returnValue, const char * name);

/**
 * Returns the flow mode of a resource.
 * @param name The name of the resource.
 */
krpc_error_t krpc_SpaceCenter_Resources_FlowMode(krpc_connection_t connection, krpc_SpaceCenter_ResourceFlowMode_t * returnValue, const char * name);

/**
 * Whether use of all the resources are enabled.
 *
 * This is true if all of the resources are enabled.
 * If any of the resources are not enabled, this is false.
 */
krpc_error_t krpc_SpaceCenter_Resources_set_Enabled(krpc_connection_t connection, krpc_SpaceCenter_Resources_t instance, bool value);

/**
 * All the individual resources that can be stored.
 */
krpc_error_t krpc_SpaceCenter_Resources_All(krpc_connection_t connection, krpc_list_object_t * returnValue, krpc_SpaceCenter_Resources_t instance);

/**
 * Whether use of all the resources are enabled.
 *
 * This is true if all of the resources are enabled.
 * If any of the resources are not enabled, this is false.
 */
krpc_error_t krpc_SpaceCenter_Resources_Enabled(krpc_connection_t connection, bool * returnValue, krpc_SpaceCenter_Resources_t instance);

/**
 * A list of resource names that can be stored.
 */
krpc_error_t krpc_SpaceCenter_Resources_Names(krpc_connection_t connection, krpc_list_string_t * returnValue, krpc_SpaceCenter_Resources_t instance);

/**
 * Transmit value.
 */
krpc_error_t krpc_SpaceCenter_ScienceData_TransmitValue(krpc_connection_t connection, float * returnValue, krpc_SpaceCenter_ScienceData_t instance);

/**
 * Science value.
 */
krpc_error_t krpc_SpaceCenter_ScienceData_ScienceValue(krpc_connection_t connection, float * returnValue, krpc_SpaceCenter_ScienceData_t instance);

/**
 * Data amount.
 */
krpc_error_t krpc_SpaceCenter_ScienceData_DataAmount(krpc_connection_t connection, float * returnValue, krpc_SpaceCenter_ScienceData_t instance);

/**
 * Title of science subject, displayed in science archives
 */
krpc_error_t krpc_SpaceCenter_ScienceSubject_Title(krpc_connection_t connection, char * * returnValue, krpc_SpaceCenter_ScienceSubject_t instance);

/**
 * Amount of science already earned from this subject, not updated until after
 * transmission/recovery.
 */
krpc_error_t krpc_SpaceCenter_ScienceSubject_Science(krpc_connection_t connection, float * returnValue, krpc_SpaceCenter_ScienceSubject_t instance);

/**
 * Multiply science value by this to determine data amount in mits.
 */
krpc_error_t krpc_SpaceCenter_ScienceSubject_DataScale(krpc_connection_t connection, float * returnValue, krpc_SpaceCenter_ScienceSubject_t instance);

/**
 * Whether the experiment has been completed.
 */
krpc_error_t krpc_SpaceCenter_ScienceSubject_IsComplete(krpc_connection_t connection, bool * returnValue, krpc_SpaceCenter_ScienceSubject_t instance);

/**
 * Total science allowable for this subject.
 */
krpc_error_t krpc_SpaceCenter_ScienceSubject_ScienceCap(krpc_connection_t connection, float * returnValue, krpc_SpaceCenter_ScienceSubject_t instance);

/**
 * Diminishing value multiplier for decreasing the science value returned from repeated
 * experiments.
 */
krpc_error_t krpc_SpaceCenter_ScienceSubject_ScientificValue(krpc_connection_t connection, float * returnValue, krpc_SpaceCenter_ScienceSubject_t instance);

/**
 * Multiplier for specific Celestial Body/Experiment Situation combination.
 */
krpc_error_t krpc_SpaceCenter_ScienceSubject_SubjectValue(krpc_connection_t connection, float * returnValue, krpc_SpaceCenter_ScienceSubject_t instance);

/**
 * Whether the sensor is active.
 */
krpc_error_t krpc_SpaceCenter_Sensor_Active(krpc_connection_t connection, bool * returnValue, krpc_SpaceCenter_Sensor_t instance);

/**
 * The part object for this sensor.
 */
krpc_error_t krpc_SpaceCenter_Sensor_Part(krpc_connection_t connection, krpc_SpaceCenter_Part_t * returnValue, krpc_SpaceCenter_Sensor_t instance);

/**
 * The current value of the sensor.
 */
krpc_error_t krpc_SpaceCenter_Sensor_Value(krpc_connection_t connection, char * * returnValue, krpc_SpaceCenter_Sensor_t instance);

/**
 * Whether the sensor is active.
 */
krpc_error_t krpc_SpaceCenter_Sensor_set_Active(krpc_connection_t connection, krpc_SpaceCenter_Sensor_t instance, bool value);

/**
 * Whether the solar panel is extended.
 */
krpc_error_t krpc_SpaceCenter_SolarPanel_set_Deployed(krpc_connection_t connection, krpc_SpaceCenter_SolarPanel_t instance, bool value);

/**
 * The current amount of energy being generated by the solar panel, in
 * units of charge per second.
 */
krpc_error_t krpc_SpaceCenter_SolarPanel_EnergyFlow(krpc_connection_t connection, float * returnValue, krpc_SpaceCenter_SolarPanel_t instance);

/**
 * Whether the solar panel is deployable.
 */
krpc_error_t krpc_SpaceCenter_SolarPanel_Deployable(krpc_connection_t connection, bool * returnValue, krpc_SpaceCenter_SolarPanel_t instance);

/**
 * The current state of the solar panel.
 */
krpc_error_t krpc_SpaceCenter_SolarPanel_State(krpc_connection_t connection, krpc_SpaceCenter_SolarPanelState_t * returnValue, krpc_SpaceCenter_SolarPanel_t instance);

/**
 * The part object for this solar panel.
 */
krpc_error_t krpc_SpaceCenter_SolarPanel_Part(krpc_connection_t connection, krpc_SpaceCenter_Part_t * returnValue, krpc_SpaceCenter_SolarPanel_t instance);

/**
 * The current amount of sunlight that is incident on the solar panel,
 * as a percentage. A value between 0 and 1.
 */
krpc_error_t krpc_SpaceCenter_SolarPanel_SunExposure(krpc_connection_t connection, float * returnValue, krpc_SpaceCenter_SolarPanel_t instance);

/**
 * Whether the solar panel is extended.
 */
krpc_error_t krpc_SpaceCenter_SolarPanel_Deployed(krpc_connection_t connection, bool * returnValue, krpc_SpaceCenter_SolarPanel_t instance);

/**
 * Position around which the gimbal pivots.
 * @return The position as a vector.
 * @param referenceFrame The reference frame that the returned
 * position vector is in.
 */
krpc_error_t krpc_SpaceCenter_Thruster_GimbalPosition(krpc_connection_t connection, krpc_tuple_double_double_double_t * returnValue, krpc_SpaceCenter_Thruster_t instance, krpc_SpaceCenter_ReferenceFrame_t referenceFrame);

/**
 * The direction of the force generated by the thruster, when the engine is in its
 * initial position (no gimballing), in the given reference frame.
 * This is opposite to the direction in which the thruster expels propellant.
 * @return The direction as a unit vector.
 * @param referenceFrame The reference frame that the returned
 * direction is in.
 */
krpc_error_t krpc_SpaceCenter_Thruster_InitialThrustDirection(krpc_connection_t connection, krpc_tuple_double_double_double_t * returnValue, krpc_SpaceCenter_Thruster_t instance, krpc_SpaceCenter_ReferenceFrame_t referenceFrame);

/**
 * The position at which the thruster generates thrust, when the engine is in its
 * initial position (no gimballing), in the given reference frame.
 * @return The position as a vector.
 * @param referenceFrame The reference frame that the returned
 * position vector is in.
 *
 * This position can move when the gimbal rotates. This is because the thrust position and
 * gimbal position are not necessarily the same.
 */
krpc_error_t krpc_SpaceCenter_Thruster_InitialThrustPosition(krpc_connection_t connection, krpc_tuple_double_double_double_t * returnValue, krpc_SpaceCenter_Thruster_t instance, krpc_SpaceCenter_ReferenceFrame_t referenceFrame);

/**
 * The direction of the force generated by the thruster, in the given reference frame.
 * This is opposite to the direction in which the thruster expels propellant.
 * For gimballed engines, this takes into account the current rotation of the gimbal.
 * @return The direction as a unit vector.
 * @param referenceFrame The reference frame that the returned
 * direction is in.
 */
krpc_error_t krpc_SpaceCenter_Thruster_ThrustDirection(krpc_connection_t connection, krpc_tuple_double_double_double_t * returnValue, krpc_SpaceCenter_Thruster_t instance, krpc_SpaceCenter_ReferenceFrame_t referenceFrame);

/**
 * The position at which the thruster generates thrust, in the given reference frame.
 * For gimballed engines, this takes into account the current rotation of the gimbal.
 * @return The position as a vector.
 * @param referenceFrame The reference frame that the returned
 * position vector is in.
 */
krpc_error_t krpc_SpaceCenter_Thruster_ThrustPosition(krpc_connection_t connection, krpc_tuple_double_double_double_t * returnValue, krpc_SpaceCenter_Thruster_t instance, krpc_SpaceCenter_ReferenceFrame_t referenceFrame);

/**
 * A reference frame that is fixed relative to the thruster and orientated with
 * its thrust direction (SpaceCenter::Thruster::thrust_direction).
 * For gimballed engines, this takes into account the current rotation of the gimbal.
 *
 * - The origin is at the position of thrust for this thruster
 *   (SpaceCenter::Thruster::thrust_position).
 * - The axes rotate with the thrust direction.
 *   This is the direction in which the thruster expels propellant, including any gimballing.
 * - The y-axis points along the thrust direction.
 * - The x-axis and z-axis are perpendicular to the thrust direction.
 */
krpc_error_t krpc_SpaceCenter_Thruster_ThrustReferenceFrame(krpc_connection_t connection, krpc_SpaceCenter_ReferenceFrame_t * returnValue, krpc_SpaceCenter_Thruster_t instance);

/**
 * Whether the thruster is gimballed.
 */
krpc_error_t krpc_SpaceCenter_Thruster_Gimballed(krpc_connection_t connection, bool * returnValue, krpc_SpaceCenter_Thruster_t instance);

/**
 * The SpaceCenter::Part that contains this thruster.
 */
krpc_error_t krpc_SpaceCenter_Thruster_Part(krpc_connection_t connection, krpc_SpaceCenter_Part_t * returnValue, krpc_SpaceCenter_Thruster_t instance);

/**
 * The current gimbal angle in the pitch, roll and yaw axes, in degrees.
 */
krpc_error_t krpc_SpaceCenter_Thruster_GimbalAngle(krpc_connection_t connection, krpc_tuple_double_double_double_t * returnValue, krpc_SpaceCenter_Thruster_t instance);

/**
 * The angular velocity of the vessel, in the given reference frame.
 * @return The angular velocity as a vector. The magnitude of the vector is the rotational
 * speed of the vessel, in radians per second. The direction of the vector indicates the
 * axis of rotation, using the right-hand rule.
 * @param referenceFrame The reference frame the returned
 * angular velocity is in.
 */
krpc_error_t krpc_SpaceCenter_Vessel_AngularVelocity(krpc_connection_t connection, krpc_tuple_double_double_double_t * returnValue, krpc_SpaceCenter_Vessel_t instance, krpc_SpaceCenter_ReferenceFrame_t referenceFrame);

/**
 * The axis-aligned bounding box of the vessel in the given reference frame.
 * @return The positions of the minimum and maximum vertices of the box,
 * as position vectors.
 * @param referenceFrame The reference frame that the returned
 * position vectors are in.
 */
krpc_error_t krpc_SpaceCenter_Vessel_BoundingBox(krpc_connection_t connection, krpc_tuple_tuple_double_double_double_tuple_double_double_double_t * returnValue, krpc_SpaceCenter_Vessel_t instance, krpc_SpaceCenter_ReferenceFrame_t referenceFrame);

/**
 * The direction in which the vessel is pointing, in the given reference frame.
 * @return The direction as a unit vector.
 * @param referenceFrame The reference frame that the returned
 * direction is in.
 */
krpc_error_t krpc_SpaceCenter_Vessel_Direction(krpc_connection_t connection, krpc_tuple_double_double_double_t * returnValue, krpc_SpaceCenter_Vessel_t instance, krpc_SpaceCenter_ReferenceFrame_t referenceFrame);

/**
 * Returns a SpaceCenter::Flight object that can be used to get flight
 * telemetry for the vessel, in the specified reference frame.
 * @param referenceFrame Reference frame. Defaults to the vessel's surface reference frame
 * (SpaceCenter::Vessel::surface_reference_frame).
 */
krpc_error_t krpc_SpaceCenter_Vessel_Flight(krpc_connection_t connection, krpc_SpaceCenter_Flight_t * returnValue, krpc_SpaceCenter_Vessel_t instance, krpc_SpaceCenter_ReferenceFrame_t referenceFrame);

/**
 * The position of the center of mass of the vessel, in the given reference frame.
 * @return The position as a vector.
 * @param referenceFrame The reference frame that the returned
 * position vector is in.
 */
krpc_error_t krpc_SpaceCenter_Vessel_Position(krpc_connection_t connection, krpc_tuple_double_double_double_t * returnValue, krpc_SpaceCenter_Vessel_t instance, krpc_SpaceCenter_ReferenceFrame_t referenceFrame);

/**
 * Recover the vessel.
 */
krpc_error_t krpc_SpaceCenter_Vessel_Recover(krpc_connection_t connection, krpc_SpaceCenter_Vessel_t instance);

/**
 * Returns a SpaceCenter::Resources object, that can used to get
 * information about resources stored in a given stage.
 * @param stage Get resources for parts that are decoupled in this stage.
 * @param cumulative When false, returns the resources for parts
 * decoupled in just the given stage. When true returns the resources decoupled in
 * the given stage and all subsequent stages combined.
 */
krpc_error_t krpc_SpaceCenter_Vessel_ResourcesInDecoupleStage(krpc_connection_t connection, krpc_SpaceCenter_Resources_t * returnValue, krpc_SpaceCenter_Vessel_t instance, int32_t stage, bool cumulative);

/**
 * The rotation of the vessel, in the given reference frame.
 * @return The rotation as a quaternion of the form (x, y, z, w).
 * @param referenceFrame The reference frame that the returned
 * rotation is in.
 */
krpc_error_t krpc_SpaceCenter_Vessel_Rotation(krpc_connection_t connection, krpc_tuple_double_double_double_double_t * returnValue, krpc_SpaceCenter_Vessel_t instance, krpc_SpaceCenter_ReferenceFrame_t referenceFrame);

/**
 * The velocity of the center of mass of the vessel, in the given reference frame.
 * @return The velocity as a vector. The vector points in the direction of travel,
 * and its magnitude is the speed of the body in meters per second.
 * @param referenceFrame The reference frame that the returned
 * velocity vector is in.
 */
krpc_error_t krpc_SpaceCenter_Vessel_Velocity(krpc_connection_t connection, krpc_tuple_double_double_double_t * returnValue, krpc_SpaceCenter_Vessel_t instance, krpc_SpaceCenter_ReferenceFrame_t referenceFrame);

/**
 * The name of the biome the vessel is currently in.
 */
krpc_error_t krpc_SpaceCenter_Vessel_Biome(krpc_connection_t connection, char * * returnValue, krpc_SpaceCenter_Vessel_t instance);

/**
 * The total maximum thrust that can be produced by the vessel's active
 * engines when the vessel is in a vacuum, in Newtons. This is computed by
 * summing SpaceCenter::Engine::max_vacuum_thrust for every active engine.
 */
krpc_error_t krpc_SpaceCenter_Vessel_MaxVacuumThrust(krpc_connection_t connection, float * returnValue, krpc_SpaceCenter_Vessel_t instance);

/**
 * The reference frame that is fixed relative to the vessel,
 * and orientated with the vessel.
 *
 * - The origin is at the center of mass of the vessel.
 * - The axes rotate with the vessel.
 * - The x-axis points out to the right of the vessel.
 * - The y-axis points in the forward direction of the vessel.
 * - The z-axis points out of the bottom off the vessel.
 */
krpc_error_t krpc_SpaceCenter_Vessel_ReferenceFrame(krpc_connection_t connection, krpc_SpaceCenter_ReferenceFrame_t * returnValue, krpc_SpaceCenter_Vessel_t instance);

/**
 * The crew in the vessel.
 */
krpc_error_t krpc_SpaceCenter_Vessel_Crew(krpc_connection_t connection, krpc_list_object_t * returnValue, krpc_SpaceCenter_Vessel_t instance);

/**
 * The maximum torque that parts (excluding reaction wheels, gimballed engines,
 * RCS and control surfaces) can generate.
 * Returns the torques in N.m around each of the coordinate axes of the
 * vessels reference frame (SpaceCenter::ReferenceFrame).
 * These axes are equivalent to the pitch, roll and yaw axes of the vessel.
 */
krpc_error_t krpc_SpaceCenter_Vessel_AvailableOtherTorque(krpc_connection_t connection, krpc_tuple_tuple_double_double_double_tuple_double_double_double_t * returnValue, krpc_SpaceCenter_Vessel_t instance);

/**
 * The reference frame that is fixed relative to the vessel,
 * and orientated with the vessels orbital prograde/normal/radial directions.
 *
 * - The origin is at the center of mass of the vessel.
 * - The axes rotate with the orbital prograde/normal/radial directions.
 * - The x-axis points in the orbital anti-radial direction.
 * - The y-axis points in the orbital prograde direction.
 * - The z-axis points in the orbital normal direction.
 *
 * Be careful not to confuse this with 'orbit' mode on the navball.
 */
krpc_error_t krpc_SpaceCenter_Vessel_OrbitalReferenceFrame(krpc_connection_t connection, krpc_SpaceCenter_ReferenceFrame_t * returnValue, krpc_SpaceCenter_Vessel_t instance);

/**
 * The type of the vessel.
 */
krpc_error_t krpc_SpaceCenter_Vessel_Type(krpc_connection_t connection, krpc_SpaceCenter_VesselType_t * returnValue, krpc_SpaceCenter_Vessel_t instance);

/**
 * A SpaceCenter::Resources object, that can used to get information
 * about resources stored in the vessel.
 */
krpc_error_t krpc_SpaceCenter_Vessel_Resources(krpc_connection_t connection, krpc_SpaceCenter_Resources_t * returnValue, krpc_SpaceCenter_Vessel_t instance);

/**
 * The inertia tensor of the vessel around its center of mass,
 * in the vessels reference frame (SpaceCenter::ReferenceFrame).
 * Returns the 3x3 matrix as a list of elements, in row-major order.
 */
krpc_error_t krpc_SpaceCenter_Vessel_InertiaTensor(krpc_connection_t connection, krpc_list_double_t * returnValue, krpc_SpaceCenter_Vessel_t instance);

/**
 * The total maximum thrust that can be produced by the vessel's active
 * engines, in Newtons. This is computed by summing
 * SpaceCenter::Engine::max_thrust for every active engine.
 */
krpc_error_t krpc_SpaceCenter_Vessel_MaxThrust(krpc_connection_t connection, float * returnValue, krpc_SpaceCenter_Vessel_t instance);

/**
 * The moment of inertia of the vessel around its center of mass in kg.m^2.
 * The inertia values in the returned 3-tuple are around the
 * pitch, roll and yaw directions respectively.
 * This corresponds to the vessels reference frame (SpaceCenter::ReferenceFrame).
 */
krpc_error_t krpc_SpaceCenter_Vessel_MomentOfInertia(krpc_connection_t connection, krpc_tuple_double_double_double_t * returnValue, krpc_SpaceCenter_Vessel_t instance);

/**
 * The type of the vessel.
 */
krpc_error_t krpc_SpaceCenter_Vessel_set_Type(krpc_connection_t connection, krpc_SpaceCenter_Vessel_t instance, krpc_SpaceCenter_VesselType_t value);

/**
 * The maximum torque that the currently active RCS thrusters can generate.
 * Returns the torques in N.m around each of the coordinate axes of the
 * vessels reference frame (SpaceCenter::ReferenceFrame).
 * These axes are equivalent to the pitch, roll and yaw axes of the vessel.
 */
krpc_error_t krpc_SpaceCenter_Vessel_AvailableRCSTorque(krpc_connection_t connection, krpc_tuple_tuple_double_double_double_tuple_double_double_double_t * returnValue, krpc_SpaceCenter_Vessel_t instance);

/**
 * The total thrust currently being produced by the vessel's engines, in
 * Newtons. This is computed by summing SpaceCenter::Engine::thrust for
 * every engine in the vessel.
 */
krpc_error_t krpc_SpaceCenter_Vessel_Thrust(krpc_connection_t connection, float * returnValue, krpc_SpaceCenter_Vessel_t instance);

/**
 * The maximum torque that the aerodynamic control surfaces can generate.
 * Returns the torques in N.m around each of the coordinate axes of the
 * vessels reference frame (SpaceCenter::ReferenceFrame).
 * These axes are equivalent to the pitch, roll and yaw axes of the vessel.
 */
krpc_error_t krpc_SpaceCenter_Vessel_AvailableControlSurfaceTorque(krpc_connection_t connection, krpc_tuple_tuple_double_double_double_tuple_double_double_double_t * returnValue, krpc_SpaceCenter_Vessel_t instance);

/**
 * The name of the vessel.
 */
krpc_error_t krpc_SpaceCenter_Vessel_set_Name(krpc_connection_t connection, krpc_SpaceCenter_Vessel_t instance, const char * value);

/**
 * Gets the total available thrust that can be produced by the vessel's
 * active engines, in Newtons. This is computed by summing
 * SpaceCenter::Engine::available_thrust for every active engine in the vessel.
 */
krpc_error_t krpc_SpaceCenter_Vessel_AvailableThrust(krpc_connection_t connection, float * returnValue, krpc_SpaceCenter_Vessel_t instance);

/**
 * The name of the vessel.
 */
krpc_error_t krpc_SpaceCenter_Vessel_Name(krpc_connection_t connection, char * * returnValue, krpc_SpaceCenter_Vessel_t instance);

/**
 * The current orbit of the vessel.
 */
krpc_error_t krpc_SpaceCenter_Vessel_Orbit(krpc_connection_t connection, krpc_SpaceCenter_Orbit_t * returnValue, krpc_SpaceCenter_Vessel_t instance);

/**
 * The number of crew that are occupying the vessel.
 */
krpc_error_t krpc_SpaceCenter_Vessel_CrewCount(krpc_connection_t connection, int32_t * returnValue, krpc_SpaceCenter_Vessel_t instance);

/**
 * The number of crew that can occupy the vessel.
 */
krpc_error_t krpc_SpaceCenter_Vessel_CrewCapacity(krpc_connection_t connection, int32_t * returnValue, krpc_SpaceCenter_Vessel_t instance);

/**
 * The total mass of the vessel, including resources, in kg.
 */
krpc_error_t krpc_SpaceCenter_Vessel_Mass(krpc_connection_t connection, float * returnValue, krpc_SpaceCenter_Vessel_t instance);

/**
 * The combined specific impulse of all active engines at sea level on Kerbin, in seconds.
 * This is computed using the formula
 * <a href="https://wiki.kerbalspaceprogram.com/wiki/Specific_impulse#Multiple_engines">described here</a>.
 */
krpc_error_t krpc_SpaceCenter_Vessel_KerbinSeaLevelSpecificImpulse(krpc_connection_t connection, float * returnValue, krpc_SpaceCenter_Vessel_t instance);

/**
 * The situation the vessel is in.
 */
krpc_error_t krpc_SpaceCenter_Vessel_Situation(krpc_connection_t connection, krpc_SpaceCenter_VesselSituation_t * returnValue, krpc_SpaceCenter_Vessel_t instance);

/**
 * The reference frame that is fixed relative to the vessel,
 * and orientated with the velocity vector of the vessel relative
 * to the surface of the body being orbited.
 *
 * - The origin is at the center of mass of the vessel.
 * - The axes rotate with the vessel's velocity vector.
 * - The y-axis points in the direction of the vessel's velocity vector,
 *   relative to the surface of the body being orbited.
 * - The z-axis is in the plane of the
 *   <a href="https://en.wikipedia.org/wiki/Horizon">astronomical horizon</a>.
 * - The x-axis is orthogonal to the other two axes.
 */
krpc_error_t krpc_SpaceCenter_Vessel_SurfaceVelocityReferenceFrame(krpc_connection_t connection, krpc_SpaceCenter_ReferenceFrame_t * returnValue, krpc_SpaceCenter_Vessel_t instance);

/**
 * The maximum torque that the vessel generates. Includes contributions from
 * reaction wheels, RCS, gimballed engines and aerodynamic control surfaces.
 * Returns the torques in N.m around each of the coordinate axes of the
 * vessels reference frame (SpaceCenter::ReferenceFrame).
 * These axes are equivalent to the pitch, roll and yaw axes of the vessel.
 */
krpc_error_t krpc_SpaceCenter_Vessel_AvailableTorque(krpc_connection_t connection, krpc_tuple_tuple_double_double_double_tuple_double_double_double_t * returnValue, krpc_SpaceCenter_Vessel_t instance);

/**
 * Whether the vessel is recoverable.
 */
krpc_error_t krpc_SpaceCenter_Vessel_Recoverable(krpc_connection_t connection, bool * returnValue, krpc_SpaceCenter_Vessel_t instance);

/**
 * Returns a SpaceCenter::Control object that can be used to manipulate
 * the vessel's control inputs. For example, its pitch/yaw/roll controls,
 * RCS and thrust.
 */
krpc_error_t krpc_SpaceCenter_Vessel_Control(krpc_connection_t connection, krpc_SpaceCenter_Control_t * returnValue, krpc_SpaceCenter_Vessel_t instance);

/**
 * The maximum torque that the currently active and gimballed engines can generate.
 * Returns the torques in N.m around each of the coordinate axes of the
 * vessels reference frame (SpaceCenter::ReferenceFrame).
 * These axes are equivalent to the pitch, roll and yaw axes of the vessel.
 */
krpc_error_t krpc_SpaceCenter_Vessel_AvailableEngineTorque(krpc_connection_t connection, krpc_tuple_tuple_double_double_double_tuple_double_double_double_t * returnValue, krpc_SpaceCenter_Vessel_t instance);

/**
 * The combined specific impulse of all active engines, in seconds. This is computed using the formula
 * <a href="https://wiki.kerbalspaceprogram.com/wiki/Specific_impulse#Multiple_engines">described here</a>.
 */
krpc_error_t krpc_SpaceCenter_Vessel_SpecificImpulse(krpc_connection_t connection, float * returnValue, krpc_SpaceCenter_Vessel_t instance);

/**
 * Returns a SpaceCenter::Comms object that can be used to interact
 * with CommNet for this vessel.
 */
krpc_error_t krpc_SpaceCenter_Vessel_Comms(krpc_connection_t connection, krpc_SpaceCenter_Comms_t * returnValue, krpc_SpaceCenter_Vessel_t instance);

/**
 * The total mass of the vessel, excluding resources, in kg.
 */
krpc_error_t krpc_SpaceCenter_Vessel_DryMass(krpc_connection_t connection, float * returnValue, krpc_SpaceCenter_Vessel_t instance);

/**
 * The maximum torque that the currently active and powered reaction wheels can generate.
 * Returns the torques in N.m around each of the coordinate axes of the
 * vessels reference frame (SpaceCenter::ReferenceFrame).
 * These axes are equivalent to the pitch, roll and yaw axes of the vessel.
 */
krpc_error_t krpc_SpaceCenter_Vessel_AvailableReactionWheelTorque(krpc_connection_t connection, krpc_tuple_tuple_double_double_double_tuple_double_double_double_t * returnValue, krpc_SpaceCenter_Vessel_t instance);

/**
 * The combined vacuum specific impulse of all active engines, in seconds. This is computed using the formula
 * <a href="https://wiki.kerbalspaceprogram.com/wiki/Specific_impulse#Multiple_engines">described here</a>.
 */
krpc_error_t krpc_SpaceCenter_Vessel_VacuumSpecificImpulse(krpc_connection_t connection, float * returnValue, krpc_SpaceCenter_Vessel_t instance);

/**
 * The mission elapsed time in seconds.
 */
krpc_error_t krpc_SpaceCenter_Vessel_MET(krpc_connection_t connection, double * returnValue, krpc_SpaceCenter_Vessel_t instance);

/**
 * A SpaceCenter::Parts object, that can used to interact with the parts that make up this vessel.
 */
krpc_error_t krpc_SpaceCenter_Vessel_Parts(krpc_connection_t connection, krpc_SpaceCenter_Parts_t * returnValue, krpc_SpaceCenter_Vessel_t instance);

/**
 * An SpaceCenter::AutoPilot object, that can be used to perform
 * simple auto-piloting of the vessel.
 */
krpc_error_t krpc_SpaceCenter_Vessel_AutoPilot(krpc_connection_t connection, krpc_SpaceCenter_AutoPilot_t * returnValue, krpc_SpaceCenter_Vessel_t instance);

/**
 * The reference frame that is fixed relative to the vessel,
 * and orientated with the surface of the body being orbited.
 *
 * - The origin is at the center of mass of the vessel.
 * - The axes rotate with the north and up directions on the surface of the body.
 * - The x-axis points in the <a href="https://en.wikipedia.org/wiki/Zenith">zenith</a>
 *   direction (upwards, normal to the body being orbited, from the center of the body towards the center of
 *   mass of the vessel).
 * - The y-axis points northwards towards the
 *   <a href="https://en.wikipedia.org/wiki/Horizon">astronomical horizon</a> (north, and tangential to the
 *   surface of the body -- the direction in which a compass would point when on the surface).
 * - The z-axis points eastwards towards the
 *   <a href="https://en.wikipedia.org/wiki/Horizon">astronomical horizon</a> (east, and tangential to the
 *   surface of the body -- east on a compass when on the surface).
 *
 * Be careful not to confuse this with 'surface' mode on the navball.
 */
krpc_error_t krpc_SpaceCenter_Vessel_SurfaceReferenceFrame(krpc_connection_t connection, krpc_SpaceCenter_ReferenceFrame_t * returnValue, krpc_SpaceCenter_Vessel_t instance);

/**
 * Removes the waypoint.
 */
krpc_error_t krpc_SpaceCenter_Waypoint_Remove(krpc_connection_t connection, krpc_SpaceCenter_Waypoint_t instance);

/**
 * true if the waypoint is near to the surface of a body.
 */
krpc_error_t krpc_SpaceCenter_Waypoint_NearSurface(krpc_connection_t connection, bool * returnValue, krpc_SpaceCenter_Waypoint_t instance);

/**
 * The integer index of this waypoint within its cluster of sibling waypoints.
 * In other words, when you have a cluster of waypoints called "Somewhere Alpha",
 * "Somewhere Beta" and "Somewhere Gamma", the alpha site has index 0, the beta
 * site has index 1 and the gamma site has index 2.
 * When SpaceCenter::Waypoint::clustered is false, this is zero.
 */
krpc_error_t krpc_SpaceCenter_Waypoint_Index(krpc_connection_t connection, int32_t * returnValue, krpc_SpaceCenter_Waypoint_t instance);

/**
 * true if the waypoint is attached to the ground.
 */
krpc_error_t krpc_SpaceCenter_Waypoint_Grounded(krpc_connection_t connection, bool * returnValue, krpc_SpaceCenter_Waypoint_t instance);

/**
 * The latitude of the waypoint.
 */
krpc_error_t krpc_SpaceCenter_Waypoint_Latitude(krpc_connection_t connection, double * returnValue, krpc_SpaceCenter_Waypoint_t instance);

/**
 * The altitude of the waypoint above the surface of the body or sea level,
 * whichever is closer, in meters.
 */
krpc_error_t krpc_SpaceCenter_Waypoint_set_SurfaceAltitude(krpc_connection_t connection, krpc_SpaceCenter_Waypoint_t instance, double value);

/**
 * The celestial body the waypoint is attached to.
 */
krpc_error_t krpc_SpaceCenter_Waypoint_Body(krpc_connection_t connection, krpc_SpaceCenter_CelestialBody_t * returnValue, krpc_SpaceCenter_Waypoint_t instance);

/**
 * Whether the waypoint belongs to a contract.
 */
krpc_error_t krpc_SpaceCenter_Waypoint_HasContract(krpc_connection_t connection, bool * returnValue, krpc_SpaceCenter_Waypoint_t instance);

/**
 * true if this waypoint is part of a set of clustered waypoints with greek letter
 * names appended (Alpha, Beta, Gamma, etc).
 * If true, there is a one-to-one correspondence with the greek letter name and
 * the SpaceCenter::Waypoint::index.
 */
krpc_error_t krpc_SpaceCenter_Waypoint_Clustered(krpc_connection_t connection, bool * returnValue, krpc_SpaceCenter_Waypoint_t instance);

/**
 * The icon of the waypoint.
 */
krpc_error_t krpc_SpaceCenter_Waypoint_Icon(krpc_connection_t connection, char * * returnValue, krpc_SpaceCenter_Waypoint_t instance);

/**
 * The name of the waypoint as it appears on the map and the contract.
 */
krpc_error_t krpc_SpaceCenter_Waypoint_set_Name(krpc_connection_t connection, krpc_SpaceCenter_Waypoint_t instance, const char * value);

/**
 * The name of the waypoint as it appears on the map and the contract.
 */
krpc_error_t krpc_SpaceCenter_Waypoint_Name(krpc_connection_t connection, char * * returnValue, krpc_SpaceCenter_Waypoint_t instance);

/**
 * The altitude of the waypoint above sea level, in meters.
 */
krpc_error_t krpc_SpaceCenter_Waypoint_set_MeanAltitude(krpc_connection_t connection, krpc_SpaceCenter_Waypoint_t instance, double value);

/**
 * The altitude of the waypoint above sea level, in meters.
 */
krpc_error_t krpc_SpaceCenter_Waypoint_MeanAltitude(krpc_connection_t connection, double * returnValue, krpc_SpaceCenter_Waypoint_t instance);

/**
 * The associated contract.
 */
krpc_error_t krpc_SpaceCenter_Waypoint_Contract(krpc_connection_t connection, krpc_SpaceCenter_Contract_t * returnValue, krpc_SpaceCenter_Waypoint_t instance);

/**
 * The altitude of the waypoint above the surface of the body, in meters.
 * When over water, this is the altitude above the sea floor.
 */
krpc_error_t krpc_SpaceCenter_Waypoint_BedrockAltitude(krpc_connection_t connection, double * returnValue, krpc_SpaceCenter_Waypoint_t instance);

/**
 * The longitude of the waypoint.
 */
krpc_error_t krpc_SpaceCenter_Waypoint_Longitude(krpc_connection_t connection, double * returnValue, krpc_SpaceCenter_Waypoint_t instance);

/**
 * The seed of the icon color. See SpaceCenter::WaypointManager::colors for example colors.
 */
krpc_error_t krpc_SpaceCenter_Waypoint_set_Color(krpc_connection_t connection, krpc_SpaceCenter_Waypoint_t instance, int32_t value);

/**
 * The altitude of the waypoint above the surface of the body or sea level,
 * whichever is closer, in meters.
 */
krpc_error_t krpc_SpaceCenter_Waypoint_SurfaceAltitude(krpc_connection_t connection, double * returnValue, krpc_SpaceCenter_Waypoint_t instance);

/**
 * The celestial body the waypoint is attached to.
 */
krpc_error_t krpc_SpaceCenter_Waypoint_set_Body(krpc_connection_t connection, krpc_SpaceCenter_Waypoint_t instance, krpc_SpaceCenter_CelestialBody_t value);

/**
 * The seed of the icon color. See SpaceCenter::WaypointManager::colors for example colors.
 */
krpc_error_t krpc_SpaceCenter_Waypoint_Color(krpc_connection_t connection, int32_t * returnValue, krpc_SpaceCenter_Waypoint_t instance);

/**
 * The altitude of the waypoint above the surface of the body, in meters.
 * When over water, this is the altitude above the sea floor.
 */
krpc_error_t krpc_SpaceCenter_Waypoint_set_BedrockAltitude(krpc_connection_t connection, krpc_SpaceCenter_Waypoint_t instance, double value);

/**
 * The icon of the waypoint.
 */
krpc_error_t krpc_SpaceCenter_Waypoint_set_Icon(krpc_connection_t connection, krpc_SpaceCenter_Waypoint_t instance, const char * value);

/**
 * The latitude of the waypoint.
 */
krpc_error_t krpc_SpaceCenter_Waypoint_set_Latitude(krpc_connection_t connection, krpc_SpaceCenter_Waypoint_t instance, double value);

/**
 * The longitude of the waypoint.
 */
krpc_error_t krpc_SpaceCenter_Waypoint_set_Longitude(krpc_connection_t connection, krpc_SpaceCenter_Waypoint_t instance, double value);

/**
 * Creates a waypoint at the given position at ground level, and returns a
 * SpaceCenter::Waypoint object that can be used to modify it.
 * @param latitude Latitude of the waypoint.
 * @param longitude Longitude of the waypoint.
 * @param body Celestial body the waypoint is attached to.
 * @param name Name of the waypoint.
 * @return
 */
krpc_error_t krpc_SpaceCenter_WaypointManager_AddWaypoint(krpc_connection_t connection, krpc_SpaceCenter_Waypoint_t * returnValue, krpc_SpaceCenter_WaypointManager_t instance, double latitude, double longitude, krpc_SpaceCenter_CelestialBody_t body, const char * name);

/**
 * Creates a waypoint at the given position and altitude, and returns a
 * SpaceCenter::Waypoint object that can be used to modify it.
 * @param latitude Latitude of the waypoint.
 * @param longitude Longitude of the waypoint.
 * @param altitude Altitude (above sea level) of the waypoint.
 * @param body Celestial body the waypoint is attached to.
 * @param name Name of the waypoint.
 * @return
 */
krpc_error_t krpc_SpaceCenter_WaypointManager_AddWaypointAtAltitude(krpc_connection_t connection, krpc_SpaceCenter_Waypoint_t * returnValue, krpc_SpaceCenter_WaypointManager_t instance, double latitude, double longitude, double altitude, krpc_SpaceCenter_CelestialBody_t body, const char * name);

/**
 * An example map of known color - seed pairs.
 * Any other integers may be used as seed.
 */
krpc_error_t krpc_SpaceCenter_WaypointManager_Colors(krpc_connection_t connection, krpc_dictionary_string_int32_t * returnValue, krpc_SpaceCenter_WaypointManager_t instance);

/**
 * A list of all existing waypoints.
 */
krpc_error_t krpc_SpaceCenter_WaypointManager_Waypoints(krpc_connection_t connection, krpc_list_object_t * returnValue, krpc_SpaceCenter_WaypointManager_t instance);

/**
 * Returns all available icons (from "GameData/Squad/Contracts/Icons/").
 */
krpc_error_t krpc_SpaceCenter_WaypointManager_Icons(krpc_connection_t connection, krpc_list_string_t * returnValue, krpc_SpaceCenter_WaypointManager_t instance);

/**
 * Setting for the traction control.
 * Only takes effect if the wheel has automatic traction control enabled.
 * A value between 0 and 5 inclusive.
 */
krpc_error_t krpc_SpaceCenter_Wheel_TractionControl(krpc_connection_t connection, float * returnValue, krpc_SpaceCenter_Wheel_t instance);

/**
 * The braking force, as a percentage of maximum, when the brakes are applied.
 */
krpc_error_t krpc_SpaceCenter_Wheel_set_Brakes(krpc_connection_t connection, krpc_SpaceCenter_Wheel_t instance, float value);

/**
 * Current stress on the wheel.
 */
krpc_error_t krpc_SpaceCenter_Wheel_Stress(krpc_connection_t connection, float * returnValue, krpc_SpaceCenter_Wheel_t instance);

/**
 * Whether the wheel is touching the ground.
 */
krpc_error_t krpc_SpaceCenter_Wheel_Grounded(krpc_connection_t connection, bool * returnValue, krpc_SpaceCenter_Wheel_t instance);

/**
 * Whether the wheel has brakes.
 */
krpc_error_t krpc_SpaceCenter_Wheel_HasBrakes(krpc_connection_t connection, bool * returnValue, krpc_SpaceCenter_Wheel_t instance);

/**
 * The output of the motor. This is the torque currently being generated, in Newton meters.
 */
krpc_error_t krpc_SpaceCenter_Wheel_MotorOutput(krpc_connection_t connection, float * returnValue, krpc_SpaceCenter_Wheel_t instance);

/**
 * Whether the wheel is repairable.
 */
krpc_error_t krpc_SpaceCenter_Wheel_Repairable(krpc_connection_t connection, bool * returnValue, krpc_SpaceCenter_Wheel_t instance);

/**
 * Whether automatic traction control is enabled.
 * A wheel only has traction control if it is powered.
 */
krpc_error_t krpc_SpaceCenter_Wheel_set_TractionControlEnabled(krpc_connection_t connection, krpc_SpaceCenter_Wheel_t instance, bool value);

/**
 * The current state of the wheel.
 */
krpc_error_t krpc_SpaceCenter_Wheel_State(krpc_connection_t connection, krpc_SpaceCenter_WheelState_t * returnValue, krpc_SpaceCenter_Wheel_t instance);

/**
 * Suspension spring strength, as set in the editor.
 */
krpc_error_t krpc_SpaceCenter_Wheel_SuspensionSpringStrength(krpc_connection_t connection, float * returnValue, krpc_SpaceCenter_Wheel_t instance);

/**
 * Whether the direction of the motor is inverted.
 */
krpc_error_t krpc_SpaceCenter_Wheel_MotorState(krpc_connection_t connection, krpc_SpaceCenter_MotorState_t * returnValue, krpc_SpaceCenter_Wheel_t instance);

/**
 * Whether the motor is enabled.
 */
krpc_error_t krpc_SpaceCenter_Wheel_MotorEnabled(krpc_connection_t connection, bool * returnValue, krpc_SpaceCenter_Wheel_t instance);

/**
 * Whether the wheel is deployable.
 */
krpc_error_t krpc_SpaceCenter_Wheel_Deployable(krpc_connection_t connection, bool * returnValue, krpc_SpaceCenter_Wheel_t instance);

/**
 * Whether the motor is enabled.
 */
krpc_error_t krpc_SpaceCenter_Wheel_set_MotorEnabled(krpc_connection_t connection, krpc_SpaceCenter_Wheel_t instance, bool value);

/**
 * Manual friction control value. Only has an effect if automatic friction control is disabled.
 * A value between 0 and 5 inclusive.
 */
krpc_error_t krpc_SpaceCenter_Wheel_ManualFrictionControl(krpc_connection_t connection, float * returnValue, krpc_SpaceCenter_Wheel_t instance);

/**
 * Suspension damper strength, as set in the editor.
 */
krpc_error_t krpc_SpaceCenter_Wheel_SuspensionDamperStrength(krpc_connection_t connection, float * returnValue, krpc_SpaceCenter_Wheel_t instance);

/**
 * Manual setting for the motor limiter.
 * Only takes effect if the wheel has automatic traction control disabled.
 * A value between 0 and 100 inclusive.
 */
krpc_error_t krpc_SpaceCenter_Wheel_DriveLimiter(krpc_connection_t connection, float * returnValue, krpc_SpaceCenter_Wheel_t instance);

/**
 * Whether the wheel has suspension.
 */
krpc_error_t krpc_SpaceCenter_Wheel_HasSuspension(krpc_connection_t connection, bool * returnValue, krpc_SpaceCenter_Wheel_t instance);

/**
 * Whether the wheel is powered by a motor.
 */
krpc_error_t krpc_SpaceCenter_Wheel_Powered(krpc_connection_t connection, bool * returnValue, krpc_SpaceCenter_Wheel_t instance);

/**
 * Whether the wheel is broken.
 */
krpc_error_t krpc_SpaceCenter_Wheel_Broken(krpc_connection_t connection, bool * returnValue, krpc_SpaceCenter_Wheel_t instance);

/**
 * The part object for this wheel.
 */
krpc_error_t krpc_SpaceCenter_Wheel_Part(krpc_connection_t connection, krpc_SpaceCenter_Part_t * returnValue, krpc_SpaceCenter_Wheel_t instance);

/**
 * Current stress on the wheel as a percentage of its stress tolerance.
 */
krpc_error_t krpc_SpaceCenter_Wheel_StressPercentage(krpc_connection_t connection, float * returnValue, krpc_SpaceCenter_Wheel_t instance);

/**
 * Setting for the traction control.
 * Only takes effect if the wheel has automatic traction control enabled.
 * A value between 0 and 5 inclusive.
 */
krpc_error_t krpc_SpaceCenter_Wheel_set_TractionControl(krpc_connection_t connection, krpc_SpaceCenter_Wheel_t instance, float value);

/**
 * Whether the wheel steering is enabled.
 */
krpc_error_t krpc_SpaceCenter_Wheel_set_SteeringEnabled(krpc_connection_t connection, krpc_SpaceCenter_Wheel_t instance, bool value);

/**
 * Whether automatic traction control is enabled.
 * A wheel only has traction control if it is powered.
 */
krpc_error_t krpc_SpaceCenter_Wheel_TractionControlEnabled(krpc_connection_t connection, bool * returnValue, krpc_SpaceCenter_Wheel_t instance);

/**
 * Whether the wheel is deployed.
 */
krpc_error_t krpc_SpaceCenter_Wheel_Deployed(krpc_connection_t connection, bool * returnValue, krpc_SpaceCenter_Wheel_t instance);

/**
 * Whether the wheel is deployed.
 */
krpc_error_t krpc_SpaceCenter_Wheel_set_Deployed(krpc_connection_t connection, krpc_SpaceCenter_Wheel_t instance, bool value);

/**
 * Whether the wheel has steering.
 */
krpc_error_t krpc_SpaceCenter_Wheel_Steerable(krpc_connection_t connection, bool * returnValue, krpc_SpaceCenter_Wheel_t instance);

/**
 * Manual friction control value. Only has an effect if automatic friction control is disabled.
 * A value between 0 and 5 inclusive.
 */
krpc_error_t krpc_SpaceCenter_Wheel_set_ManualFrictionControl(krpc_connection_t connection, krpc_SpaceCenter_Wheel_t instance, float value);

/**
 * Whether the wheel steering is enabled.
 */
krpc_error_t krpc_SpaceCenter_Wheel_SteeringEnabled(krpc_connection_t connection, bool * returnValue, krpc_SpaceCenter_Wheel_t instance);

/**
 * Manual setting for the motor limiter.
 * Only takes effect if the wheel has automatic traction control disabled.
 * A value between 0 and 100 inclusive.
 */
krpc_error_t krpc_SpaceCenter_Wheel_set_DriveLimiter(krpc_connection_t connection, krpc_SpaceCenter_Wheel_t instance, float value);

/**
 * Whether automatic friction control is enabled.
 */
krpc_error_t krpc_SpaceCenter_Wheel_AutoFrictionControl(krpc_connection_t connection, bool * returnValue, krpc_SpaceCenter_Wheel_t instance);

/**
 * Whether the wheel steering is inverted.
 */
krpc_error_t krpc_SpaceCenter_Wheel_SteeringInverted(krpc_connection_t connection, bool * returnValue, krpc_SpaceCenter_Wheel_t instance);

/**
 * Stress tolerance of the wheel.
 */
krpc_error_t krpc_SpaceCenter_Wheel_StressTolerance(krpc_connection_t connection, float * returnValue, krpc_SpaceCenter_Wheel_t instance);

/**
 * Whether the direction of the motor is inverted.
 */
krpc_error_t krpc_SpaceCenter_Wheel_set_MotorInverted(krpc_connection_t connection, krpc_SpaceCenter_Wheel_t instance, bool value);

/**
 * The braking force, as a percentage of maximum, when the brakes are applied.
 */
krpc_error_t krpc_SpaceCenter_Wheel_Brakes(krpc_connection_t connection, float * returnValue, krpc_SpaceCenter_Wheel_t instance);

/**
 * Whether the wheel steering is inverted.
 */
krpc_error_t krpc_SpaceCenter_Wheel_set_SteeringInverted(krpc_connection_t connection, krpc_SpaceCenter_Wheel_t instance, bool value);

/**
 * Current deflection of the wheel.
 */
krpc_error_t krpc_SpaceCenter_Wheel_Deflection(krpc_connection_t connection, float * returnValue, krpc_SpaceCenter_Wheel_t instance);

/**
 * Radius of the wheel, in meters.
 */
krpc_error_t krpc_SpaceCenter_Wheel_Radius(krpc_connection_t connection, float * returnValue, krpc_SpaceCenter_Wheel_t instance);

/**
 * Current slip of the wheel.
 */
krpc_error_t krpc_SpaceCenter_Wheel_Slip(krpc_connection_t connection, float * returnValue, krpc_SpaceCenter_Wheel_t instance);

/**
 * Whether the direction of the motor is inverted.
 */
krpc_error_t krpc_SpaceCenter_Wheel_MotorInverted(krpc_connection_t connection, bool * returnValue, krpc_SpaceCenter_Wheel_t instance);

/**
 * Whether automatic friction control is enabled.
 */
krpc_error_t krpc_SpaceCenter_Wheel_set_AutoFrictionControl(krpc_connection_t connection, krpc_SpaceCenter_Wheel_t instance, bool value);

// Implementation

#ifndef KRPC_IMPL_TYPE_LIST_OBJECT
#define KRPC_IMPL_TYPE_LIST_OBJECT

static bool krpc_encode_callback_items_list_object(
  pb_ostream_t * stream, const pb_field_t * field, void * const * arg) {
  const krpc_list_object_t * value = (const krpc_list_object_t*)(*arg);
  size_t i = 0;
  for (; i < value->size; i++) {
    if (!pb_encode_tag_for_field(stream, field))
      KRPC_CALLBACK_RETURN_ERROR("encoding tag for list item");
    size_t size;
    KRPC_CALLBACK_RETURN_ON_ERROR(krpc_encode_size_object(&size, value->items[i]));
    if (!pb_encode_varint(stream, size))
      KRPC_CALLBACK_RETURN_ERROR("encoding size for list item");
    KRPC_CALLBACK_RETURN_ON_ERROR(krpc_encode_object(stream, value->items[i]));
  }
  return true;
}

inline krpc_error_t krpc_encode_list_object(
  pb_ostream_t * stream, const krpc_list_object_t * value) {
  krpc_schema_List message = krpc_schema_List_init_default;
  message.items.funcs.encode = &krpc_encode_callback_items_list_object;
  message.items.arg = (krpc_list_object_t*)value;
  KRPC_RETURN_ON_ERROR(krpc_encode_message_List(stream, &message));
  return KRPC_OK;
}

inline krpc_error_t krpc_encode_size_list_object(
  size_t * size, const krpc_list_object_t * value) {
  pb_ostream_t stream = PB_OSTREAM_SIZING;
  KRPC_RETURN_ON_ERROR(krpc_encode_list_object(&stream, value));
  *size = stream.bytes_written;
  return KRPC_OK;
}

inline bool krpc_encode_callback_list_object(
  pb_ostream_t * stream, const pb_field_t * field, void * const * arg) {
  if (!pb_encode_tag_for_field(stream, field))
    KRPC_CALLBACK_RETURN_ERROR("encoding tag for list_object");
  krpc_list_object_t * value = (krpc_list_object_t*)(*arg);
  size_t size;
  KRPC_CALLBACK_RETURN_ON_ERROR(krpc_encode_size_list_object(&size, value));
  if (!pb_encode_varint(stream, size))
    KRPC_CALLBACK_RETURN_ERROR("encoding size for list_object");
  KRPC_CALLBACK_RETURN_ON_ERROR(krpc_encode_list_object(stream, value));
  return true;
}

static bool krpc_decode_callback_item_list_object(
  pb_istream_t * stream, const pb_field_t * field, void ** arg) {
  typedef struct { size_t capacity; krpc_list_object_t * value; } State;
  State * state = (State*)(*arg);
  size_t i = state->value->size;
  state->value->size++;
  if (state->capacity > 0 && state->value->size > state->capacity) {
    state->value->items = (krpc_SpaceCenter_Propellant_t*)krpc_recalloc(state->value->items, state->capacity, KRPC_ALLOC_BLOCK_SIZE, sizeof(krpc_SpaceCenter_Propellant_t));
    state->capacity += KRPC_ALLOC_BLOCK_SIZE;
  }
  KRPC_CALLBACK_RETURN_ON_ERROR(krpc_decode_object(stream, &state->value->items[i]));
  return true;
}

inline krpc_error_t krpc_decode_list_object(
  pb_istream_t * stream, krpc_list_object_t * value) {
  typedef struct { size_t capacity; krpc_list_object_t * value; } State;
  State state = { 0, value };
  value->size = 0;
  if (value->items == NULL) {
    value->items = (krpc_SpaceCenter_Propellant_t*)krpc_calloc(KRPC_ALLOC_BLOCK_SIZE, sizeof(krpc_SpaceCenter_Propellant_t));
    state.capacity = KRPC_ALLOC_BLOCK_SIZE;
  }
  krpc_schema_List message = krpc_schema_List_init_default;
  message.items.funcs.decode = &krpc_decode_callback_item_list_object;
  message.items.arg = &state;
  KRPC_RETURN_ON_ERROR(krpc_decode_message_List(stream, &message));
  return KRPC_OK;
}

#endif  // KRPC_IMPL_TYPE_LIST_OBJECT

#ifndef KRPC_IMPL_TYPE_LIST_OBJECT
#define KRPC_IMPL_TYPE_LIST_OBJECT

static bool krpc_encode_callback_items_list_object(
  pb_ostream_t * stream, const pb_field_t * field, void * const * arg) {
  const krpc_list_object_t * value = (const krpc_list_object_t*)(*arg);
  size_t i = 0;
  for (; i < value->size; i++) {
    if (!pb_encode_tag_for_field(stream, field))
      KRPC_CALLBACK_RETURN_ERROR("encoding tag for list item");
    size_t size;
    KRPC_CALLBACK_RETURN_ON_ERROR(krpc_encode_size_object(&size, value->items[i]));
    if (!pb_encode_varint(stream, size))
      KRPC_CALLBACK_RETURN_ERROR("encoding size for list item");
    KRPC_CALLBACK_RETURN_ON_ERROR(krpc_encode_object(stream, value->items[i]));
  }
  return true;
}

inline krpc_error_t krpc_encode_list_object(
  pb_ostream_t * stream, const krpc_list_object_t * value) {
  krpc_schema_List message = krpc_schema_List_init_default;
  message.items.funcs.encode = &krpc_encode_callback_items_list_object;
  message.items.arg = (krpc_list_object_t*)value;
  KRPC_RETURN_ON_ERROR(krpc_encode_message_List(stream, &message));
  return KRPC_OK;
}

inline krpc_error_t krpc_encode_size_list_object(
  size_t * size, const krpc_list_object_t * value) {
  pb_ostream_t stream = PB_OSTREAM_SIZING;
  KRPC_RETURN_ON_ERROR(krpc_encode_list_object(&stream, value));
  *size = stream.bytes_written;
  return KRPC_OK;
}

inline bool krpc_encode_callback_list_object(
  pb_ostream_t * stream, const pb_field_t * field, void * const * arg) {
  if (!pb_encode_tag_for_field(stream, field))
    KRPC_CALLBACK_RETURN_ERROR("encoding tag for list_object");
  krpc_list_object_t * value = (krpc_list_object_t*)(*arg);
  size_t size;
  KRPC_CALLBACK_RETURN_ON_ERROR(krpc_encode_size_list_object(&size, value));
  if (!pb_encode_varint(stream, size))
    KRPC_CALLBACK_RETURN_ERROR("encoding size for list_object");
  KRPC_CALLBACK_RETURN_ON_ERROR(krpc_encode_list_object(stream, value));
  return true;
}

static bool krpc_decode_callback_item_list_object(
  pb_istream_t * stream, const pb_field_t * field, void ** arg) {
  typedef struct { size_t capacity; krpc_list_object_t * value; } State;
  State * state = (State*)(*arg);
  size_t i = state->value->size;
  state->value->size++;
  if (state->capacity > 0 && state->value->size > state->capacity) {
    state->value->items = (krpc_SpaceCenter_Leg_t*)krpc_recalloc(state->value->items, state->capacity, KRPC_ALLOC_BLOCK_SIZE, sizeof(krpc_SpaceCenter_Leg_t));
    state->capacity += KRPC_ALLOC_BLOCK_SIZE;
  }
  KRPC_CALLBACK_RETURN_ON_ERROR(krpc_decode_object(stream, &state->value->items[i]));
  return true;
}

inline krpc_error_t krpc_decode_list_object(
  pb_istream_t * stream, krpc_list_object_t * value) {
  typedef struct { size_t capacity; krpc_list_object_t * value; } State;
  State state = { 0, value };
  value->size = 0;
  if (value->items == NULL) {
    value->items = (krpc_SpaceCenter_Leg_t*)krpc_calloc(KRPC_ALLOC_BLOCK_SIZE, sizeof(krpc_SpaceCenter_Leg_t));
    state.capacity = KRPC_ALLOC_BLOCK_SIZE;
  }
  krpc_schema_List message = krpc_schema_List_init_default;
  message.items.funcs.decode = &krpc_decode_callback_item_list_object;
  message.items.arg = &state;
  KRPC_RETURN_ON_ERROR(krpc_decode_message_List(stream, &message));
  return KRPC_OK;
}

#endif  // KRPC_IMPL_TYPE_LIST_OBJECT

#ifndef KRPC_IMPL_TYPE_TUPLE_DOUBLE_DOUBLE_DOUBLE
#define KRPC_IMPL_TYPE_TUPLE_DOUBLE_DOUBLE_DOUBLE

static bool krpc_encode_callback_items_tuple_double_double_double(
  pb_ostream_t * stream, const pb_field_t * field, void * const * arg) {
  const krpc_tuple_double_double_double_t * value = (const krpc_tuple_double_double_double_t*)(*arg);
  {
    if (!pb_encode_tag_for_field(stream, field))
      KRPC_CALLBACK_RETURN_ERROR("encoding tag for tuple item");
    size_t size;
    KRPC_CALLBACK_RETURN_ON_ERROR(krpc_encode_size_double(&size, value->e0));
    if (!pb_encode_varint(stream, size))
      KRPC_CALLBACK_RETURN_ERROR("encoding size for tuple item");
    KRPC_CALLBACK_RETURN_ON_ERROR(krpc_encode_double(stream, value->e0));
  }
  {
    if (!pb_encode_tag_for_field(stream, field))
      KRPC_CALLBACK_RETURN_ERROR("encoding tag for tuple item");
    size_t size;
    KRPC_CALLBACK_RETURN_ON_ERROR(krpc_encode_size_double(&size, value->e1));
    if (!pb_encode_varint(stream, size))
      KRPC_CALLBACK_RETURN_ERROR("encoding size for tuple item");
    KRPC_CALLBACK_RETURN_ON_ERROR(krpc_encode_double(stream, value->e1));
  }
  {
    if (!pb_encode_tag_for_field(stream, field))
      KRPC_CALLBACK_RETURN_ERROR("encoding tag for tuple item");
    size_t size;
    KRPC_CALLBACK_RETURN_ON_ERROR(krpc_encode_size_double(&size, value->e2));
    if (!pb_encode_varint(stream, size))
      KRPC_CALLBACK_RETURN_ERROR("encoding size for tuple item");
    KRPC_CALLBACK_RETURN_ON_ERROR(krpc_encode_double(stream, value->e2));
  }
  return true;
}

inline krpc_error_t krpc_encode_tuple_double_double_double(
  pb_ostream_t * stream, const krpc_tuple_double_double_double_t * value) {
  krpc_schema_Tuple message = krpc_schema_Tuple_init_default;
  message.items.funcs.encode = &krpc_encode_callback_items_tuple_double_double_double;
  message.items.arg = (krpc_tuple_double_double_double_t*)value;
  KRPC_RETURN_ON_ERROR(krpc_encode_message_Tuple(stream, &message));
  return KRPC_OK;
}

inline krpc_error_t krpc_encode_size_tuple_double_double_double(
  size_t * size, const krpc_tuple_double_double_double_t * value) {
  pb_ostream_t stream = PB_OSTREAM_SIZING;
  KRPC_RETURN_ON_ERROR(krpc_encode_tuple_double_double_double(&stream, value));
  *size = stream.bytes_written;
  return KRPC_OK;
}

inline bool krpc_encode_callback_tuple_double_double_double(
  pb_ostream_t * stream, const pb_field_t * field, void * const * arg) {
  if (!pb_encode_tag_for_field(stream, field))
    KRPC_CALLBACK_RETURN_ERROR("encoding tag for tuple_double_double_double");
  krpc_tuple_double_double_double_t * value = (krpc_tuple_double_double_double_t*)(*arg);
  size_t size;
  KRPC_CALLBACK_RETURN_ON_ERROR(krpc_encode_size_tuple_double_double_double(&size, value));
  if (!pb_encode_varint(stream, size))
    KRPC_CALLBACK_RETURN_ERROR("encoding size for tuple_double_double_double");
  KRPC_CALLBACK_RETURN_ON_ERROR(krpc_encode_tuple_double_double_double(stream, value));
  return true;
}

static bool krpc_decode_callback_item_tuple_double_double_double(
  pb_istream_t * stream, const pb_field_t * field, void ** arg) {
  typedef struct {size_t pos; krpc_tuple_double_double_double_t * value;} State;
  State * state = (State*)(*arg);
  krpc_tuple_double_double_double_t * value = state->value;
  switch (state->pos) {
  case 0:
    KRPC_CALLBACK_RETURN_ON_ERROR(krpc_decode_double(stream, &value->e0));
    break;
  case 1:
    KRPC_CALLBACK_RETURN_ON_ERROR(krpc_decode_double(stream, &value->e1));
    break;
  case 2:
    KRPC_CALLBACK_RETURN_ON_ERROR(krpc_decode_double(stream, &value->e2));
    break;
  default:
    KRPC_CALLBACK_RETURN_ERROR("unexpected tuple item");
  }
  state->pos++;
  return true;
}

inline krpc_error_t krpc_decode_tuple_double_double_double(
  pb_istream_t * stream, krpc_tuple_double_double_double_t * value) {
  krpc_schema_Tuple message = krpc_schema_Tuple_init_default;
  message.items.funcs.decode = &krpc_decode_callback_item_tuple_double_double_double;
  typedef struct { size_t pos; krpc_tuple_double_double_double_t * value; } State;
  State state = { 0, value };
  message.items.arg = &state;
  KRPC_RETURN_ON_ERROR(krpc_decode_message_Tuple(stream, &message));
  return KRPC_OK;
}

#endif  // KRPC_IMPL_TYPE_TUPLE_DOUBLE_DOUBLE_DOUBLE

#ifndef KRPC_IMPL_TYPE_TUPLE_TUPLE_DOUBLE_DOUBLE_DOUBLE_TUPLE_DOUBLE_DOUBLE_DOUBLE
#define KRPC_IMPL_TYPE_TUPLE_TUPLE_DOUBLE_DOUBLE_DOUBLE_TUPLE_DOUBLE_DOUBLE_DOUBLE

static bool krpc_encode_callback_items_tuple_tuple_double_double_double_tuple_double_double_double(
  pb_ostream_t * stream, const pb_field_t * field, void * const * arg) {
  const krpc_tuple_tuple_double_double_double_tuple_double_double_double_t * value = (const krpc_tuple_tuple_double_double_double_tuple_double_double_double_t*)(*arg);
  {
    if (!pb_encode_tag_for_field(stream, field))
      KRPC_CALLBACK_RETURN_ERROR("encoding tag for tuple item");
    size_t size;
    KRPC_CALLBACK_RETURN_ON_ERROR(krpc_encode_size_tuple_double_double_double(&size, &value->e0));
    if (!pb_encode_varint(stream, size))
      KRPC_CALLBACK_RETURN_ERROR("encoding size for tuple item");
    KRPC_CALLBACK_RETURN_ON_ERROR(krpc_encode_tuple_double_double_double(stream, &value->e0));
  }
  {
    if (!pb_encode_tag_for_field(stream, field))
      KRPC_CALLBACK_RETURN_ERROR("encoding tag for tuple item");
    size_t size;
    KRPC_CALLBACK_RETURN_ON_ERROR(krpc_encode_size_tuple_double_double_double(&size, &value->e1));
    if (!pb_encode_varint(stream, size))
      KRPC_CALLBACK_RETURN_ERROR("encoding size for tuple item");
    KRPC_CALLBACK_RETURN_ON_ERROR(krpc_encode_tuple_double_double_double(stream, &value->e1));
  }
  return true;
}

inline krpc_error_t krpc_encode_tuple_tuple_double_double_double_tuple_double_double_double(
  pb_ostream_t * stream, const krpc_tuple_tuple_double_double_double_tuple_double_double_double_t * value) {
  krpc_schema_Tuple message = krpc_schema_Tuple_init_default;
  message.items.funcs.encode = &krpc_encode_callback_items_tuple_tuple_double_double_double_tuple_double_double_double;
  message.items.arg = (krpc_tuple_tuple_double_double_double_tuple_double_double_double_t*)value;
  KRPC_RETURN_ON_ERROR(krpc_encode_message_Tuple(stream, &message));
  return KRPC_OK;
}

inline krpc_error_t krpc_encode_size_tuple_tuple_double_double_double_tuple_double_double_double(
  size_t * size, const krpc_tuple_tuple_double_double_double_tuple_double_double_double_t * value) {
  pb_ostream_t stream = PB_OSTREAM_SIZING;
  KRPC_RETURN_ON_ERROR(krpc_encode_tuple_tuple_double_double_double_tuple_double_double_double(&stream, value));
  *size = stream.bytes_written;
  return KRPC_OK;
}

inline bool krpc_encode_callback_tuple_tuple_double_double_double_tuple_double_double_double(
  pb_ostream_t * stream, const pb_field_t * field, void * const * arg) {
  if (!pb_encode_tag_for_field(stream, field))
    KRPC_CALLBACK_RETURN_ERROR("encoding tag for tuple_tuple_double_double_double_tuple_double_double_double");
  krpc_tuple_tuple_double_double_double_tuple_double_double_double_t * value = (krpc_tuple_tuple_double_double_double_tuple_double_double_double_t*)(*arg);
  size_t size;
  KRPC_CALLBACK_RETURN_ON_ERROR(krpc_encode_size_tuple_tuple_double_double_double_tuple_double_double_double(&size, value));
  if (!pb_encode_varint(stream, size))
    KRPC_CALLBACK_RETURN_ERROR("encoding size for tuple_tuple_double_double_double_tuple_double_double_double");
  KRPC_CALLBACK_RETURN_ON_ERROR(krpc_encode_tuple_tuple_double_double_double_tuple_double_double_double(stream, value));
  return true;
}

static bool krpc_decode_callback_item_tuple_tuple_double_double_double_tuple_double_double_double(
  pb_istream_t * stream, const pb_field_t * field, void ** arg) {
  typedef struct {size_t pos; krpc_tuple_tuple_double_double_double_tuple_double_double_double_t * value;} State;
  State * state = (State*)(*arg);
  krpc_tuple_tuple_double_double_double_tuple_double_double_double_t * value = state->value;
  switch (state->pos) {
  case 0:
    KRPC_CALLBACK_RETURN_ON_ERROR(krpc_decode_tuple_double_double_double(stream, &value->e0));
    break;
  case 1:
    KRPC_CALLBACK_RETURN_ON_ERROR(krpc_decode_tuple_double_double_double(stream, &value->e1));
    break;
  default:
    KRPC_CALLBACK_RETURN_ERROR("unexpected tuple item");
  }
  state->pos++;
  return true;
}

inline krpc_error_t krpc_decode_tuple_tuple_double_double_double_tuple_double_double_double(
  pb_istream_t * stream, krpc_tuple_tuple_double_double_double_tuple_double_double_double_t * value) {
  krpc_schema_Tuple message = krpc_schema_Tuple_init_default;
  message.items.funcs.decode = &krpc_decode_callback_item_tuple_tuple_double_double_double_tuple_double_double_double;
  typedef struct { size_t pos; krpc_tuple_tuple_double_double_double_tuple_double_double_double_t * value; } State;
  State state = { 0, value };
  message.items.arg = &state;
  KRPC_RETURN_ON_ERROR(krpc_decode_message_Tuple(stream, &message));
  return KRPC_OK;
}

#endif  // KRPC_IMPL_TYPE_TUPLE_TUPLE_DOUBLE_DOUBLE_DOUBLE_TUPLE_DOUBLE_DOUBLE_DOUBLE

#ifndef KRPC_IMPL_TYPE_LIST_OBJECT
#define KRPC_IMPL_TYPE_LIST_OBJECT

static bool krpc_encode_callback_items_list_object(
  pb_ostream_t * stream, const pb_field_t * field, void * const * arg) {
  const krpc_list_object_t * value = (const krpc_list_object_t*)(*arg);
  size_t i = 0;
  for (; i < value->size; i++) {
    if (!pb_encode_tag_for_field(stream, field))
      KRPC_CALLBACK_RETURN_ERROR("encoding tag for list item");
    size_t size;
    KRPC_CALLBACK_RETURN_ON_ERROR(krpc_encode_size_object(&size, value->items[i]));
    if (!pb_encode_varint(stream, size))
      KRPC_CALLBACK_RETURN_ERROR("encoding size for list item");
    KRPC_CALLBACK_RETURN_ON_ERROR(krpc_encode_object(stream, value->items[i]));
  }
  return true;
}

inline krpc_error_t krpc_encode_list_object(
  pb_ostream_t * stream, const krpc_list_object_t * value) {
  krpc_schema_List message = krpc_schema_List_init_default;
  message.items.funcs.encode = &krpc_encode_callback_items_list_object;
  message.items.arg = (krpc_list_object_t*)value;
  KRPC_RETURN_ON_ERROR(krpc_encode_message_List(stream, &message));
  return KRPC_OK;
}

inline krpc_error_t krpc_encode_size_list_object(
  size_t * size, const krpc_list_object_t * value) {
  pb_ostream_t stream = PB_OSTREAM_SIZING;
  KRPC_RETURN_ON_ERROR(krpc_encode_list_object(&stream, value));
  *size = stream.bytes_written;
  return KRPC_OK;
}

inline bool krpc_encode_callback_list_object(
  pb_ostream_t * stream, const pb_field_t * field, void * const * arg) {
  if (!pb_encode_tag_for_field(stream, field))
    KRPC_CALLBACK_RETURN_ERROR("encoding tag for list_object");
  krpc_list_object_t * value = (krpc_list_object_t*)(*arg);
  size_t size;
  KRPC_CALLBACK_RETURN_ON_ERROR(krpc_encode_size_list_object(&size, value));
  if (!pb_encode_varint(stream, size))
    KRPC_CALLBACK_RETURN_ERROR("encoding size for list_object");
  KRPC_CALLBACK_RETURN_ON_ERROR(krpc_encode_list_object(stream, value));
  return true;
}

static bool krpc_decode_callback_item_list_object(
  pb_istream_t * stream, const pb_field_t * field, void ** arg) {
  typedef struct { size_t capacity; krpc_list_object_t * value; } State;
  State * state = (State*)(*arg);
  size_t i = state->value->size;
  state->value->size++;
  if (state->capacity > 0 && state->value->size > state->capacity) {
    state->value->items = (krpc_SpaceCenter_Decoupler_t*)krpc_recalloc(state->value->items, state->capacity, KRPC_ALLOC_BLOCK_SIZE, sizeof(krpc_SpaceCenter_Decoupler_t));
    state->capacity += KRPC_ALLOC_BLOCK_SIZE;
  }
  KRPC_CALLBACK_RETURN_ON_ERROR(krpc_decode_object(stream, &state->value->items[i]));
  return true;
}

inline krpc_error_t krpc_decode_list_object(
  pb_istream_t * stream, krpc_list_object_t * value) {
  typedef struct { size_t capacity; krpc_list_object_t * value; } State;
  State state = { 0, value };
  value->size = 0;
  if (value->items == NULL) {
    value->items = (krpc_SpaceCenter_Decoupler_t*)krpc_calloc(KRPC_ALLOC_BLOCK_SIZE, sizeof(krpc_SpaceCenter_Decoupler_t));
    state.capacity = KRPC_ALLOC_BLOCK_SIZE;
  }
  krpc_schema_List message = krpc_schema_List_init_default;
  message.items.funcs.decode = &krpc_decode_callback_item_list_object;
  message.items.arg = &state;
  KRPC_RETURN_ON_ERROR(krpc_decode_message_List(stream, &message));
  return KRPC_OK;
}

#endif  // KRPC_IMPL_TYPE_LIST_OBJECT

#ifndef KRPC_IMPL_TYPE_DICTIONARY_STRING_FLOAT
#define KRPC_IMPL_TYPE_DICTIONARY_STRING_FLOAT

static bool krpc_encode_callback_key_dictionary_string_float(
  pb_ostream_t * stream, const pb_field_t * field, void * const * arg) {
  if (!pb_encode_tag_for_field(stream, field))
    KRPC_CALLBACK_RETURN_ERROR("encoding tag for dictionary entry key");
  const char * * key = (const char **)(*arg);
  size_t size = 0;
  KRPC_CALLBACK_RETURN_ON_ERROR(krpc_encode_size_string(&size, *key));
  if (!pb_encode_varint(stream, size))
    KRPC_CALLBACK_RETURN_ERROR("encoding size for dictionary entry key");
  KRPC_CALLBACK_RETURN_ON_ERROR(krpc_encode_string(stream, *key));
  return true;
}

static bool krpc_encode_callback_value_dictionary_string_float(
  pb_ostream_t * stream, const pb_field_t * field, void * const * arg) {
  if (!pb_encode_tag_for_field(stream, field))
    KRPC_CALLBACK_RETURN_ERROR("encoding tag for dictionary entry value");
  const float * value = (const float*)(*arg);
  size_t size = 0;
  KRPC_CALLBACK_RETURN_ON_ERROR(krpc_encode_size_float(&size, *value));
  if (!pb_encode_varint(stream, size))
    KRPC_CALLBACK_RETURN_ERROR("encoding size for dictionary entry value");
  KRPC_CALLBACK_RETURN_ON_ERROR(krpc_encode_float(stream, *value));
  return true;
}

static bool krpc_encode_callback_entry_dictionary_string_float(
  pb_ostream_t * stream, const pb_field_t * field, void * const * arg) {
  const krpc_dictionary_string_float_t * value = (const krpc_dictionary_string_float_t*)(*arg);
  krpc_schema_DictionaryEntry entry = krpc_schema_DictionaryEntry_init_default;
  entry.key.funcs.encode = &krpc_encode_callback_key_dictionary_string_float;
  entry.value.funcs.encode = &krpc_encode_callback_value_dictionary_string_float;
  size_t i = 0;
  for (; i < value->size; i++) {
    entry.key.arg = &value->entries[i].key;
    entry.value.arg = &value->entries[i].value;
    if (!pb_encode_tag_for_field(stream, field))
      KRPC_CALLBACK_RETURN_ERROR("encoding tag for dictionary entry");
    size_t size;
    KRPC_CALLBACK_RETURN_ON_ERROR(krpc_encode_size_message_DictionaryEntry(&size, &entry));
    if (!pb_encode_varint(stream, size))
      KRPC_CALLBACK_RETURN_ERROR("encoding size for dictionary item");
    KRPC_CALLBACK_RETURN_ON_ERROR(krpc_encode_message_DictionaryEntry(stream, &entry));
  }
  return true;
}

inline krpc_error_t krpc_encode_dictionary_string_float(
  pb_ostream_t * stream, const krpc_dictionary_string_float_t * value) {
  krpc_schema_Dictionary message = krpc_schema_Dictionary_init_default;
  message.entries.funcs.encode = &krpc_encode_callback_entry_dictionary_string_float;
  message.entries.arg = (krpc_dictionary_string_float_t*)value;
  KRPC_RETURN_ON_ERROR(krpc_encode_message_Dictionary(stream, &message));
  return KRPC_OK;
}

inline krpc_error_t krpc_encode_size_dictionary_string_float(
  size_t * size, const krpc_dictionary_string_float_t * value) {
  pb_ostream_t stream = PB_OSTREAM_SIZING;
  KRPC_RETURN_ON_ERROR(krpc_encode_dictionary_string_float(&stream, value));
  *size = stream.bytes_written;
  return KRPC_OK;
}

inline bool krpc_encode_callback_dictionary_string_float(
  pb_ostream_t * stream, const pb_field_t * field, void * const * arg) {
  if (!pb_encode_tag_for_field(stream, field))
    KRPC_CALLBACK_RETURN_ERROR("encoding tag for dictionary_string_float");
  krpc_dictionary_string_float_t * value = (krpc_dictionary_string_float_t*)(*arg);
  size_t size;
  KRPC_CALLBACK_RETURN_ON_ERROR(krpc_encode_size_dictionary_string_float(&size, value));
  if (!pb_encode_varint(stream, size))
    KRPC_CALLBACK_RETURN_ERROR("encoding size for dictionary_string_float");
  KRPC_CALLBACK_RETURN_ON_ERROR(krpc_encode_dictionary_string_float(stream, value));
  return true;
}

static bool krpc_decode_callback_key_dictionary_string_float(
  pb_istream_t * stream, const pb_field_t * field, void ** arg) {
  char * * key = (char **)(*arg);
  KRPC_CALLBACK_RETURN_ON_ERROR(krpc_decode_string(stream, key));
  return true;
}

static bool krpc_decode_callback_value_dictionary_string_float(
  pb_istream_t * stream, const pb_field_t * field, void ** arg) {
  float * value = (float*)(*arg);
  KRPC_CALLBACK_RETURN_ON_ERROR(krpc_decode_float(stream, value));
  return true;
}

static bool krpc_decode_callback_entry_dictionary_string_float(
  pb_istream_t * stream, const pb_field_t * field, void ** arg) {
  typedef struct { size_t capacity; krpc_dictionary_string_float_t * value; } State;
  State * state = (State*)(*arg);
  krpc_dictionary_string_float_t * value = state->value;
  size_t i = value->size;
  value->size++;
  if (state->capacity > 0 && state->value->size > state->capacity) {
    state->value->entries = (krpc_dictionary_entry_string_float_t*)krpc_recalloc(state->value->entries, state->capacity, KRPC_ALLOC_BLOCK_SIZE, sizeof(krpc_dictionary_entry_string_float_t));
    state->capacity += KRPC_ALLOC_BLOCK_SIZE;
  }
  krpc_schema_DictionaryEntry message = krpc_schema_DictionaryEntry_init_default;
  message.key.funcs.decode = &krpc_decode_callback_key_dictionary_string_float;
  message.key.arg = &value->entries[i].key;
  message.value.funcs.decode = &krpc_decode_callback_value_dictionary_string_float;
  message.value.arg = &value->entries[i].value;
  KRPC_CALLBACK_RETURN_ON_ERROR(krpc_decode_message_DictionaryEntry(stream, &message));
  return true;
}

inline krpc_error_t krpc_decode_dictionary_string_float(
  pb_istream_t * stream, krpc_dictionary_string_float_t * value) {
  typedef struct { size_t capacity; krpc_dictionary_string_float_t * value; } State;
  State state = { 0, value };
  value->size = 0;
  if (value->entries == NULL) {
    value->entries = (krpc_dictionary_entry_string_float_t*)krpc_calloc(KRPC_ALLOC_BLOCK_SIZE, sizeof(krpc_dictionary_entry_string_float_t));
    state.capacity = KRPC_ALLOC_BLOCK_SIZE;
  }
  krpc_schema_Dictionary message = krpc_schema_Dictionary_init_default;
  message.entries.funcs.decode = &krpc_decode_callback_entry_dictionary_string_float;
  message.entries.arg = &state;
  KRPC_RETURN_ON_ERROR(krpc_decode_message_Dictionary(stream, &message));
  return KRPC_OK;
}

#endif  // KRPC_IMPL_TYPE_DICTIONARY_STRING_FLOAT

#ifndef KRPC_IMPL_TYPE_LIST_OBJECT
#define KRPC_IMPL_TYPE_LIST_OBJECT

static bool krpc_encode_callback_items_list_object(
  pb_ostream_t * stream, const pb_field_t * field, void * const * arg) {
  const krpc_list_object_t * value = (const krpc_list_object_t*)(*arg);
  size_t i = 0;
  for (; i < value->size; i++) {
    if (!pb_encode_tag_for_field(stream, field))
      KRPC_CALLBACK_RETURN_ERROR("encoding tag for list item");
    size_t size;
    KRPC_CALLBACK_RETURN_ON_ERROR(krpc_encode_size_object(&size, value->items[i]));
    if (!pb_encode_varint(stream, size))
      KRPC_CALLBACK_RETURN_ERROR("encoding size for list item");
    KRPC_CALLBACK_RETURN_ON_ERROR(krpc_encode_object(stream, value->items[i]));
  }
  return true;
}

inline krpc_error_t krpc_encode_list_object(
  pb_ostream_t * stream, const krpc_list_object_t * value) {
  krpc_schema_List message = krpc_schema_List_init_default;
  message.items.funcs.encode = &krpc_encode_callback_items_list_object;
  message.items.arg = (krpc_list_object_t*)value;
  KRPC_RETURN_ON_ERROR(krpc_encode_message_List(stream, &message));
  return KRPC_OK;
}

inline krpc_error_t krpc_encode_size_list_object(
  size_t * size, const krpc_list_object_t * value) {
  pb_ostream_t stream = PB_OSTREAM_SIZING;
  KRPC_RETURN_ON_ERROR(krpc_encode_list_object(&stream, value));
  *size = stream.bytes_written;
  return KRPC_OK;
}

inline bool krpc_encode_callback_list_object(
  pb_ostream_t * stream, const pb_field_t * field, void * const * arg) {
  if (!pb_encode_tag_for_field(stream, field))
    KRPC_CALLBACK_RETURN_ERROR("encoding tag for list_object");
  krpc_list_object_t * value = (krpc_list_object_t*)(*arg);
  size_t size;
  KRPC_CALLBACK_RETURN_ON_ERROR(krpc_encode_size_list_object(&size, value));
  if (!pb_encode_varint(stream, size))
    KRPC_CALLBACK_RETURN_ERROR("encoding size for list_object");
  KRPC_CALLBACK_RETURN_ON_ERROR(krpc_encode_list_object(stream, value));
  return true;
}

static bool krpc_decode_callback_item_list_object(
  pb_istream_t * stream, const pb_field_t * field, void ** arg) {
  typedef struct { size_t capacity; krpc_list_object_t * value; } State;
  State * state = (State*)(*arg);
  size_t i = state->value->size;
  state->value->size++;
  if (state->capacity > 0 && state->value->size > state->capacity) {
    state->value->items = (krpc_SpaceCenter_CommLink_t*)krpc_recalloc(state->value->items, state->capacity, KRPC_ALLOC_BLOCK_SIZE, sizeof(krpc_SpaceCenter_CommLink_t));
    state->capacity += KRPC_ALLOC_BLOCK_SIZE;
  }
  KRPC_CALLBACK_RETURN_ON_ERROR(krpc_decode_object(stream, &state->value->items[i]));
  return true;
}

inline krpc_error_t krpc_decode_list_object(
  pb_istream_t * stream, krpc_list_object_t * value) {
  typedef struct { size_t capacity; krpc_list_object_t * value; } State;
  State state = { 0, value };
  value->size = 0;
  if (value->items == NULL) {
    value->items = (krpc_SpaceCenter_CommLink_t*)krpc_calloc(KRPC_ALLOC_BLOCK_SIZE, sizeof(krpc_SpaceCenter_CommLink_t));
    state.capacity = KRPC_ALLOC_BLOCK_SIZE;
  }
  krpc_schema_List message = krpc_schema_List_init_default;
  message.items.funcs.decode = &krpc_decode_callback_item_list_object;
  message.items.arg = &state;
  KRPC_RETURN_ON_ERROR(krpc_decode_message_List(stream, &message));
  return KRPC_OK;
}

#endif  // KRPC_IMPL_TYPE_LIST_OBJECT

#ifndef KRPC_IMPL_TYPE_LIST_OBJECT
#define KRPC_IMPL_TYPE_LIST_OBJECT

static bool krpc_encode_callback_items_list_object(
  pb_ostream_t * stream, const pb_field_t * field, void * const * arg) {
  const krpc_list_object_t * value = (const krpc_list_object_t*)(*arg);
  size_t i = 0;
  for (; i < value->size; i++) {
    if (!pb_encode_tag_for_field(stream, field))
      KRPC_CALLBACK_RETURN_ERROR("encoding tag for list item");
    size_t size;
    KRPC_CALLBACK_RETURN_ON_ERROR(krpc_encode_size_object(&size, value->items[i]));
    if (!pb_encode_varint(stream, size))
      KRPC_CALLBACK_RETURN_ERROR("encoding size for list item");
    KRPC_CALLBACK_RETURN_ON_ERROR(krpc_encode_object(stream, value->items[i]));
  }
  return true;
}

inline krpc_error_t krpc_encode_list_object(
  pb_ostream_t * stream, const krpc_list_object_t * value) {
  krpc_schema_List message = krpc_schema_List_init_default;
  message.items.funcs.encode = &krpc_encode_callback_items_list_object;
  message.items.arg = (krpc_list_object_t*)value;
  KRPC_RETURN_ON_ERROR(krpc_encode_message_List(stream, &message));
  return KRPC_OK;
}

inline krpc_error_t krpc_encode_size_list_object(
  size_t * size, const krpc_list_object_t * value) {
  pb_ostream_t stream = PB_OSTREAM_SIZING;
  KRPC_RETURN_ON_ERROR(krpc_encode_list_object(&stream, value));
  *size = stream.bytes_written;
  return KRPC_OK;
}

inline bool krpc_encode_callback_list_object(
  pb_ostream_t * stream, const pb_field_t * field, void * const * arg) {
  if (!pb_encode_tag_for_field(stream, field))
    KRPC_CALLBACK_RETURN_ERROR("encoding tag for list_object");
  krpc_list_object_t * value = (krpc_list_object_t*)(*arg);
  size_t size;
  KRPC_CALLBACK_RETURN_ON_ERROR(krpc_encode_size_list_object(&size, value));
  if (!pb_encode_varint(stream, size))
    KRPC_CALLBACK_RETURN_ERROR("encoding size for list_object");
  KRPC_CALLBACK_RETURN_ON_ERROR(krpc_encode_list_object(stream, value));
  return true;
}

static bool krpc_decode_callback_item_list_object(
  pb_istream_t * stream, const pb_field_t * field, void ** arg) {
  typedef struct { size_t capacity; krpc_list_object_t * value; } State;
  State * state = (State*)(*arg);
  size_t i = state->value->size;
  state->value->size++;
  if (state->capacity > 0 && state->value->size > state->capacity) {
    state->value->items = (krpc_SpaceCenter_CelestialBody_t*)krpc_recalloc(state->value->items, state->capacity, KRPC_ALLOC_BLOCK_SIZE, sizeof(krpc_SpaceCenter_CelestialBody_t));
    state->capacity += KRPC_ALLOC_BLOCK_SIZE;
  }
  KRPC_CALLBACK_RETURN_ON_ERROR(krpc_decode_object(stream, &state->value->items[i]));
  return true;
}

inline krpc_error_t krpc_decode_list_object(
  pb_istream_t * stream, krpc_list_object_t * value) {
  typedef struct { size_t capacity; krpc_list_object_t * value; } State;
  State state = { 0, value };
  value->size = 0;
  if (value->items == NULL) {
    value->items = (krpc_SpaceCenter_CelestialBody_t*)krpc_calloc(KRPC_ALLOC_BLOCK_SIZE, sizeof(krpc_SpaceCenter_CelestialBody_t));
    state.capacity = KRPC_ALLOC_BLOCK_SIZE;
  }
  krpc_schema_List message = krpc_schema_List_init_default;
  message.items.funcs.decode = &krpc_decode_callback_item_list_object;
  message.items.arg = &state;
  KRPC_RETURN_ON_ERROR(krpc_decode_message_List(stream, &message));
  return KRPC_OK;
}

#endif  // KRPC_IMPL_TYPE_LIST_OBJECT

#ifndef KRPC_IMPL_TYPE_LIST_STRING
#define KRPC_IMPL_TYPE_LIST_STRING

static bool krpc_encode_callback_items_list_string(
  pb_ostream_t * stream, const pb_field_t * field, void * const * arg) {
  const krpc_list_string_t * value = (const krpc_list_string_t*)(*arg);
  size_t i = 0;
  for (; i < value->size; i++) {
    if (!pb_encode_tag_for_field(stream, field))
      KRPC_CALLBACK_RETURN_ERROR("encoding tag for list item");
    size_t size;
    KRPC_CALLBACK_RETURN_ON_ERROR(krpc_encode_size_string(&size, value->items[i]));
    if (!pb_encode_varint(stream, size))
      KRPC_CALLBACK_RETURN_ERROR("encoding size for list item");
    KRPC_CALLBACK_RETURN_ON_ERROR(krpc_encode_string(stream, value->items[i]));
  }
  return true;
}

inline krpc_error_t krpc_encode_list_string(
  pb_ostream_t * stream, const krpc_list_string_t * value) {
  krpc_schema_List message = krpc_schema_List_init_default;
  message.items.funcs.encode = &krpc_encode_callback_items_list_string;
  message.items.arg = (krpc_list_string_t*)value;
  KRPC_RETURN_ON_ERROR(krpc_encode_message_List(stream, &message));
  return KRPC_OK;
}

inline krpc_error_t krpc_encode_size_list_string(
  size_t * size, const krpc_list_string_t * value) {
  pb_ostream_t stream = PB_OSTREAM_SIZING;
  KRPC_RETURN_ON_ERROR(krpc_encode_list_string(&stream, value));
  *size = stream.bytes_written;
  return KRPC_OK;
}

inline bool krpc_encode_callback_list_string(
  pb_ostream_t * stream, const pb_field_t * field, void * const * arg) {
  if (!pb_encode_tag_for_field(stream, field))
    KRPC_CALLBACK_RETURN_ERROR("encoding tag for list_string");
  krpc_list_string_t * value = (krpc_list_string_t*)(*arg);
  size_t size;
  KRPC_CALLBACK_RETURN_ON_ERROR(krpc_encode_size_list_string(&size, value));
  if (!pb_encode_varint(stream, size))
    KRPC_CALLBACK_RETURN_ERROR("encoding size for list_string");
  KRPC_CALLBACK_RETURN_ON_ERROR(krpc_encode_list_string(stream, value));
  return true;
}

static bool krpc_decode_callback_item_list_string(
  pb_istream_t * stream, const pb_field_t * field, void ** arg) {
  typedef struct { size_t capacity; krpc_list_string_t * value; } State;
  State * state = (State*)(*arg);
  size_t i = state->value->size;
  state->value->size++;
  if (state->capacity > 0 && state->value->size > state->capacity) {
    state->value->items = (char **)krpc_recalloc(state->value->items, state->capacity, KRPC_ALLOC_BLOCK_SIZE, sizeof(char *));
    state->capacity += KRPC_ALLOC_BLOCK_SIZE;
  }
  KRPC_CALLBACK_RETURN_ON_ERROR(krpc_decode_string(stream, &state->value->items[i]));
  return true;
}

inline krpc_error_t krpc_decode_list_string(
  pb_istream_t * stream, krpc_list_string_t * value) {
  typedef struct { size_t capacity; krpc_list_string_t * value; } State;
  State state = { 0, value };
  value->size = 0;
  if (value->items == NULL) {
    value->items = (char **)krpc_calloc(KRPC_ALLOC_BLOCK_SIZE, sizeof(char *));
    state.capacity = KRPC_ALLOC_BLOCK_SIZE;
  }
  krpc_schema_List message = krpc_schema_List_init_default;
  message.items.funcs.decode = &krpc_decode_callback_item_list_string;
  message.items.arg = &state;
  KRPC_RETURN_ON_ERROR(krpc_decode_message_List(stream, &message));
  return KRPC_OK;
}

#endif  // KRPC_IMPL_TYPE_LIST_STRING

#ifndef KRPC_IMPL_TYPE_LIST_OBJECT
#define KRPC_IMPL_TYPE_LIST_OBJECT

static bool krpc_encode_callback_items_list_object(
  pb_ostream_t * stream, const pb_field_t * field, void * const * arg) {
  const krpc_list_object_t * value = (const krpc_list_object_t*)(*arg);
  size_t i = 0;
  for (; i < value->size; i++) {
    if (!pb_encode_tag_for_field(stream, field))
      KRPC_CALLBACK_RETURN_ERROR("encoding tag for list item");
    size_t size;
    KRPC_CALLBACK_RETURN_ON_ERROR(krpc_encode_size_object(&size, value->items[i]));
    if (!pb_encode_varint(stream, size))
      KRPC_CALLBACK_RETURN_ERROR("encoding size for list item");
    KRPC_CALLBACK_RETURN_ON_ERROR(krpc_encode_object(stream, value->items[i]));
  }
  return true;
}

inline krpc_error_t krpc_encode_list_object(
  pb_ostream_t * stream, const krpc_list_object_t * value) {
  krpc_schema_List message = krpc_schema_List_init_default;
  message.items.funcs.encode = &krpc_encode_callback_items_list_object;
  message.items.arg = (krpc_list_object_t*)value;
  KRPC_RETURN_ON_ERROR(krpc_encode_message_List(stream, &message));
  return KRPC_OK;
}

inline krpc_error_t krpc_encode_size_list_object(
  size_t * size, const krpc_list_object_t * value) {
  pb_ostream_t stream = PB_OSTREAM_SIZING;
  KRPC_RETURN_ON_ERROR(krpc_encode_list_object(&stream, value));
  *size = stream.bytes_written;
  return KRPC_OK;
}

inline bool krpc_encode_callback_list_object(
  pb_ostream_t * stream, const pb_field_t * field, void * const * arg) {
  if (!pb_encode_tag_for_field(stream, field))
    KRPC_CALLBACK_RETURN_ERROR("encoding tag for list_object");
  krpc_list_object_t * value = (krpc_list_object_t*)(*arg);
  size_t size;
  KRPC_CALLBACK_RETURN_ON_ERROR(krpc_encode_size_list_object(&size, value));
  if (!pb_encode_varint(stream, size))
    KRPC_CALLBACK_RETURN_ERROR("encoding size for list_object");
  KRPC_CALLBACK_RETURN_ON_ERROR(krpc_encode_list_object(stream, value));
  return true;
}

static bool krpc_decode_callback_item_list_object(
  pb_istream_t * stream, const pb_field_t * field, void ** arg) {
  typedef struct { size_t capacity; krpc_list_object_t * value; } State;
  State * state = (State*)(*arg);
  size_t i = state->value->size;
  state->value->size++;
  if (state->capacity > 0 && state->value->size > state->capacity) {
    state->value->items = (krpc_SpaceCenter_Intake_t*)krpc_recalloc(state->value->items, state->capacity, KRPC_ALLOC_BLOCK_SIZE, sizeof(krpc_SpaceCenter_Intake_t));
    state->capacity += KRPC_ALLOC_BLOCK_SIZE;
  }
  KRPC_CALLBACK_RETURN_ON_ERROR(krpc_decode_object(stream, &state->value->items[i]));
  return true;
}

inline krpc_error_t krpc_decode_list_object(
  pb_istream_t * stream, krpc_list_object_t * value) {
  typedef struct { size_t capacity; krpc_list_object_t * value; } State;
  State state = { 0, value };
  value->size = 0;
  if (value->items == NULL) {
    value->items = (krpc_SpaceCenter_Intake_t*)krpc_calloc(KRPC_ALLOC_BLOCK_SIZE, sizeof(krpc_SpaceCenter_Intake_t));
    state.capacity = KRPC_ALLOC_BLOCK_SIZE;
  }
  krpc_schema_List message = krpc_schema_List_init_default;
  message.items.funcs.decode = &krpc_decode_callback_item_list_object;
  message.items.arg = &state;
  KRPC_RETURN_ON_ERROR(krpc_decode_message_List(stream, &message));
  return KRPC_OK;
}

#endif  // KRPC_IMPL_TYPE_LIST_OBJECT

#ifndef KRPC_IMPL_TYPE_LIST_OBJECT
#define KRPC_IMPL_TYPE_LIST_OBJECT

static bool krpc_encode_callback_items_list_object(
  pb_ostream_t * stream, const pb_field_t * field, void * const * arg) {
  const krpc_list_object_t * value = (const krpc_list_object_t*)(*arg);
  size_t i = 0;
  for (; i < value->size; i++) {
    if (!pb_encode_tag_for_field(stream, field))
      KRPC_CALLBACK_RETURN_ERROR("encoding tag for list item");
    size_t size;
    KRPC_CALLBACK_RETURN_ON_ERROR(krpc_encode_size_object(&size, value->items[i]));
    if (!pb_encode_varint(stream, size))
      KRPC_CALLBACK_RETURN_ERROR("encoding size for list item");
    KRPC_CALLBACK_RETURN_ON_ERROR(krpc_encode_object(stream, value->items[i]));
  }
  return true;
}

inline krpc_error_t krpc_encode_list_object(
  pb_ostream_t * stream, const krpc_list_object_t * value) {
  krpc_schema_List message = krpc_schema_List_init_default;
  message.items.funcs.encode = &krpc_encode_callback_items_list_object;
  message.items.arg = (krpc_list_object_t*)value;
  KRPC_RETURN_ON_ERROR(krpc_encode_message_List(stream, &message));
  return KRPC_OK;
}

inline krpc_error_t krpc_encode_size_list_object(
  size_t * size, const krpc_list_object_t * value) {
  pb_ostream_t stream = PB_OSTREAM_SIZING;
  KRPC_RETURN_ON_ERROR(krpc_encode_list_object(&stream, value));
  *size = stream.bytes_written;
  return KRPC_OK;
}

inline bool krpc_encode_callback_list_object(
  pb_ostream_t * stream, const pb_field_t * field, void * const * arg) {
  if (!pb_encode_tag_for_field(stream, field))
    KRPC_CALLBACK_RETURN_ERROR("encoding tag for list_object");
  krpc_list_object_t * value = (krpc_list_object_t*)(*arg);
  size_t size;
  KRPC_CALLBACK_RETURN_ON_ERROR(krpc_encode_size_list_object(&size, value));
  if (!pb_encode_varint(stream, size))
    KRPC_CALLBACK_RETURN_ERROR("encoding size for list_object");
  KRPC_CALLBACK_RETURN_ON_ERROR(krpc_encode_list_object(stream, value));
  return true;
}

static bool krpc_decode_callback_item_list_object(
  pb_istream_t * stream, const pb_field_t * field, void ** arg) {
  typedef struct { size_t capacity; krpc_list_object_t * value; } State;
  State * state = (State*)(*arg);
  size_t i = state->value->size;
  state->value->size++;
  if (state->capacity > 0 && state->value->size > state->capacity) {
    state->value->items = (krpc_SpaceCenter_ContractParameter_t*)krpc_recalloc(state->value->items, state->capacity, KRPC_ALLOC_BLOCK_SIZE, sizeof(krpc_SpaceCenter_ContractParameter_t));
    state->capacity += KRPC_ALLOC_BLOCK_SIZE;
  }
  KRPC_CALLBACK_RETURN_ON_ERROR(krpc_decode_object(stream, &state->value->items[i]));
  return true;
}

inline krpc_error_t krpc_decode_list_object(
  pb_istream_t * stream, krpc_list_object_t * value) {
  typedef struct { size_t capacity; krpc_list_object_t * value; } State;
  State state = { 0, value };
  value->size = 0;
  if (value->items == NULL) {
    value->items = (krpc_SpaceCenter_ContractParameter_t*)krpc_calloc(KRPC_ALLOC_BLOCK_SIZE, sizeof(krpc_SpaceCenter_ContractParameter_t));
    state.capacity = KRPC_ALLOC_BLOCK_SIZE;
  }
  krpc_schema_List message = krpc_schema_List_init_default;
  message.items.funcs.decode = &krpc_decode_callback_item_list_object;
  message.items.arg = &state;
  KRPC_RETURN_ON_ERROR(krpc_decode_message_List(stream, &message));
  return KRPC_OK;
}

#endif  // KRPC_IMPL_TYPE_LIST_OBJECT

#ifndef KRPC_IMPL_TYPE_LIST_OBJECT
#define KRPC_IMPL_TYPE_LIST_OBJECT

static bool krpc_encode_callback_items_list_object(
  pb_ostream_t * stream, const pb_field_t * field, void * const * arg) {
  const krpc_list_object_t * value = (const krpc_list_object_t*)(*arg);
  size_t i = 0;
  for (; i < value->size; i++) {
    if (!pb_encode_tag_for_field(stream, field))
      KRPC_CALLBACK_RETURN_ERROR("encoding tag for list item");
    size_t size;
    KRPC_CALLBACK_RETURN_ON_ERROR(krpc_encode_size_object(&size, value->items[i]));
    if (!pb_encode_varint(stream, size))
      KRPC_CALLBACK_RETURN_ERROR("encoding size for list item");
    KRPC_CALLBACK_RETURN_ON_ERROR(krpc_encode_object(stream, value->items[i]));
  }
  return true;
}

inline krpc_error_t krpc_encode_list_object(
  pb_ostream_t * stream, const krpc_list_object_t * value) {
  krpc_schema_List message = krpc_schema_List_init_default;
  message.items.funcs.encode = &krpc_encode_callback_items_list_object;
  message.items.arg = (krpc_list_object_t*)value;
  KRPC_RETURN_ON_ERROR(krpc_encode_message_List(stream, &message));
  return KRPC_OK;
}

inline krpc_error_t krpc_encode_size_list_object(
  size_t * size, const krpc_list_object_t * value) {
  pb_ostream_t stream = PB_OSTREAM_SIZING;
  KRPC_RETURN_ON_ERROR(krpc_encode_list_object(&stream, value));
  *size = stream.bytes_written;
  return KRPC_OK;
}

inline bool krpc_encode_callback_list_object(
  pb_ostream_t * stream, const pb_field_t * field, void * const * arg) {
  if (!pb_encode_tag_for_field(stream, field))
    KRPC_CALLBACK_RETURN_ERROR("encoding tag for list_object");
  krpc_list_object_t * value = (krpc_list_object_t*)(*arg);
  size_t size;
  KRPC_CALLBACK_RETURN_ON_ERROR(krpc_encode_size_list_object(&size, value));
  if (!pb_encode_varint(stream, size))
    KRPC_CALLBACK_RETURN_ERROR("encoding size for list_object");
  KRPC_CALLBACK_RETURN_ON_ERROR(krpc_encode_list_object(stream, value));
  return true;
}

static bool krpc_decode_callback_item_list_object(
  pb_istream_t * stream, const pb_field_t * field, void ** arg) {
  typedef struct { size_t capacity; krpc_list_object_t * value; } State;
  State * state = (State*)(*arg);
  size_t i = state->value->size;
  state->value->size++;
  if (state->capacity > 0 && state->value->size > state->capacity) {
    state->value->items = (krpc_SpaceCenter_Module_t*)krpc_recalloc(state->value->items, state->capacity, KRPC_ALLOC_BLOCK_SIZE, sizeof(krpc_SpaceCenter_Module_t));
    state->capacity += KRPC_ALLOC_BLOCK_SIZE;
  }
  KRPC_CALLBACK_RETURN_ON_ERROR(krpc_decode_object(stream, &state->value->items[i]));
  return true;
}

inline krpc_error_t krpc_decode_list_object(
  pb_istream_t * stream, krpc_list_object_t * value) {
  typedef struct { size_t capacity; krpc_list_object_t * value; } State;
  State state = { 0, value };
  value->size = 0;
  if (value->items == NULL) {
    value->items = (krpc_SpaceCenter_Module_t*)krpc_calloc(KRPC_ALLOC_BLOCK_SIZE, sizeof(krpc_SpaceCenter_Module_t));
    state.capacity = KRPC_ALLOC_BLOCK_SIZE;
  }
  krpc_schema_List message = krpc_schema_List_init_default;
  message.items.funcs.decode = &krpc_decode_callback_item_list_object;
  message.items.arg = &state;
  KRPC_RETURN_ON_ERROR(krpc_decode_message_List(stream, &message));
  return KRPC_OK;
}

#endif  // KRPC_IMPL_TYPE_LIST_OBJECT

#ifndef KRPC_IMPL_TYPE_LIST_OBJECT
#define KRPC_IMPL_TYPE_LIST_OBJECT

static bool krpc_encode_callback_items_list_object(
  pb_ostream_t * stream, const pb_field_t * field, void * const * arg) {
  const krpc_list_object_t * value = (const krpc_list_object_t*)(*arg);
  size_t i = 0;
  for (; i < value->size; i++) {
    if (!pb_encode_tag_for_field(stream, field))
      KRPC_CALLBACK_RETURN_ERROR("encoding tag for list item");
    size_t size;
    KRPC_CALLBACK_RETURN_ON_ERROR(krpc_encode_size_object(&size, value->items[i]));
    if (!pb_encode_varint(stream, size))
      KRPC_CALLBACK_RETURN_ERROR("encoding size for list item");
    KRPC_CALLBACK_RETURN_ON_ERROR(krpc_encode_object(stream, value->items[i]));
  }
  return true;
}

inline krpc_error_t krpc_encode_list_object(
  pb_ostream_t * stream, const krpc_list_object_t * value) {
  krpc_schema_List message = krpc_schema_List_init_default;
  message.items.funcs.encode = &krpc_encode_callback_items_list_object;
  message.items.arg = (krpc_list_object_t*)value;
  KRPC_RETURN_ON_ERROR(krpc_encode_message_List(stream, &message));
  return KRPC_OK;
}

inline krpc_error_t krpc_encode_size_list_object(
  size_t * size, const krpc_list_object_t * value) {
  pb_ostream_t stream = PB_OSTREAM_SIZING;
  KRPC_RETURN_ON_ERROR(krpc_encode_list_object(&stream, value));
  *size = stream.bytes_written;
  return KRPC_OK;
}

inline bool krpc_encode_callback_list_object(
  pb_ostream_t * stream, const pb_field_t * field, void * const * arg) {
  if (!pb_encode_tag_for_field(stream, field))
    KRPC_CALLBACK_RETURN_ERROR("encoding tag for list_object");
  krpc_list_object_t * value = (krpc_list_object_t*)(*arg);
  size_t size;
  KRPC_CALLBACK_RETURN_ON_ERROR(krpc_encode_size_list_object(&size, value));
  if (!pb_encode_varint(stream, size))
    KRPC_CALLBACK_RETURN_ERROR("encoding size for list_object");
  KRPC_CALLBACK_RETURN_ON_ERROR(krpc_encode_list_object(stream, value));
  return true;
}

static bool krpc_decode_callback_item_list_object(
  pb_istream_t * stream, const pb_field_t * field, void ** arg) {
  typedef struct { size_t capacity; krpc_list_object_t * value; } State;
  State * state = (State*)(*arg);
  size_t i = state->value->size;
  state->value->size++;
  if (state->capacity > 0 && state->value->size > state->capacity) {
    state->value->items = (krpc_SpaceCenter_ControlSurface_t*)krpc_recalloc(state->value->items, state->capacity, KRPC_ALLOC_BLOCK_SIZE, sizeof(krpc_SpaceCenter_ControlSurface_t));
    state->capacity += KRPC_ALLOC_BLOCK_SIZE;
  }
  KRPC_CALLBACK_RETURN_ON_ERROR(krpc_decode_object(stream, &state->value->items[i]));
  return true;
}

inline krpc_error_t krpc_decode_list_object(
  pb_istream_t * stream, krpc_list_object_t * value) {
  typedef struct { size_t capacity; krpc_list_object_t * value; } State;
  State state = { 0, value };
  value->size = 0;
  if (value->items == NULL) {
    value->items = (krpc_SpaceCenter_ControlSurface_t*)krpc_calloc(KRPC_ALLOC_BLOCK_SIZE, sizeof(krpc_SpaceCenter_ControlSurface_t));
    state.capacity = KRPC_ALLOC_BLOCK_SIZE;
  }
  krpc_schema_List message = krpc_schema_List_init_default;
  message.items.funcs.decode = &krpc_decode_callback_item_list_object;
  message.items.arg = &state;
  KRPC_RETURN_ON_ERROR(krpc_decode_message_List(stream, &message));
  return KRPC_OK;
}

#endif  // KRPC_IMPL_TYPE_LIST_OBJECT

#ifndef KRPC_IMPL_TYPE_LIST_DOUBLE
#define KRPC_IMPL_TYPE_LIST_DOUBLE

static bool krpc_encode_callback_items_list_double(
  pb_ostream_t * stream, const pb_field_t * field, void * const * arg) {
  const krpc_list_double_t * value = (const krpc_list_double_t*)(*arg);
  size_t i = 0;
  for (; i < value->size; i++) {
    if (!pb_encode_tag_for_field(stream, field))
      KRPC_CALLBACK_RETURN_ERROR("encoding tag for list item");
    size_t size;
    KRPC_CALLBACK_RETURN_ON_ERROR(krpc_encode_size_double(&size, value->items[i]));
    if (!pb_encode_varint(stream, size))
      KRPC_CALLBACK_RETURN_ERROR("encoding size for list item");
    KRPC_CALLBACK_RETURN_ON_ERROR(krpc_encode_double(stream, value->items[i]));
  }
  return true;
}

inline krpc_error_t krpc_encode_list_double(
  pb_ostream_t * stream, const krpc_list_double_t * value) {
  krpc_schema_List message = krpc_schema_List_init_default;
  message.items.funcs.encode = &krpc_encode_callback_items_list_double;
  message.items.arg = (krpc_list_double_t*)value;
  KRPC_RETURN_ON_ERROR(krpc_encode_message_List(stream, &message));
  return KRPC_OK;
}

inline krpc_error_t krpc_encode_size_list_double(
  size_t * size, const krpc_list_double_t * value) {
  pb_ostream_t stream = PB_OSTREAM_SIZING;
  KRPC_RETURN_ON_ERROR(krpc_encode_list_double(&stream, value));
  *size = stream.bytes_written;
  return KRPC_OK;
}

inline bool krpc_encode_callback_list_double(
  pb_ostream_t * stream, const pb_field_t * field, void * const * arg) {
  if (!pb_encode_tag_for_field(stream, field))
    KRPC_CALLBACK_RETURN_ERROR("encoding tag for list_double");
  krpc_list_double_t * value = (krpc_list_double_t*)(*arg);
  size_t size;
  KRPC_CALLBACK_RETURN_ON_ERROR(krpc_encode_size_list_double(&size, value));
  if (!pb_encode_varint(stream, size))
    KRPC_CALLBACK_RETURN_ERROR("encoding size for list_double");
  KRPC_CALLBACK_RETURN_ON_ERROR(krpc_encode_list_double(stream, value));
  return true;
}

static bool krpc_decode_callback_item_list_double(
  pb_istream_t * stream, const pb_field_t * field, void ** arg) {
  typedef struct { size_t capacity; krpc_list_double_t * value; } State;
  State * state = (State*)(*arg);
  size_t i = state->value->size;
  state->value->size++;
  if (state->capacity > 0 && state->value->size > state->capacity) {
    state->value->items = (double*)krpc_recalloc(state->value->items, state->capacity, KRPC_ALLOC_BLOCK_SIZE, sizeof(double));
    state->capacity += KRPC_ALLOC_BLOCK_SIZE;
  }
  KRPC_CALLBACK_RETURN_ON_ERROR(krpc_decode_double(stream, &state->value->items[i]));
  return true;
}

inline krpc_error_t krpc_decode_list_double(
  pb_istream_t * stream, krpc_list_double_t * value) {
  typedef struct { size_t capacity; krpc_list_double_t * value; } State;
  State state = { 0, value };
  value->size = 0;
  if (value->items == NULL) {
    value->items = (double*)krpc_calloc(KRPC_ALLOC_BLOCK_SIZE, sizeof(double));
    state.capacity = KRPC_ALLOC_BLOCK_SIZE;
  }
  krpc_schema_List message = krpc_schema_List_init_default;
  message.items.funcs.decode = &krpc_decode_callback_item_list_double;
  message.items.arg = &state;
  KRPC_RETURN_ON_ERROR(krpc_decode_message_List(stream, &message));
  return KRPC_OK;
}

#endif  // KRPC_IMPL_TYPE_LIST_DOUBLE

#ifndef KRPC_IMPL_TYPE_TUPLE_FLOAT_FLOAT_FLOAT
#define KRPC_IMPL_TYPE_TUPLE_FLOAT_FLOAT_FLOAT

static bool krpc_encode_callback_items_tuple_float_float_float(
  pb_ostream_t * stream, const pb_field_t * field, void * const * arg) {
  const krpc_tuple_float_float_float_t * value = (const krpc_tuple_float_float_float_t*)(*arg);
  {
    if (!pb_encode_tag_for_field(stream, field))
      KRPC_CALLBACK_RETURN_ERROR("encoding tag for tuple item");
    size_t size;
    KRPC_CALLBACK_RETURN_ON_ERROR(krpc_encode_size_float(&size, value->e0));
    if (!pb_encode_varint(stream, size))
      KRPC_CALLBACK_RETURN_ERROR("encoding size for tuple item");
    KRPC_CALLBACK_RETURN_ON_ERROR(krpc_encode_float(stream, value->e0));
  }
  {
    if (!pb_encode_tag_for_field(stream, field))
      KRPC_CALLBACK_RETURN_ERROR("encoding tag for tuple item");
    size_t size;
    KRPC_CALLBACK_RETURN_ON_ERROR(krpc_encode_size_float(&size, value->e1));
    if (!pb_encode_varint(stream, size))
      KRPC_CALLBACK_RETURN_ERROR("encoding size for tuple item");
    KRPC_CALLBACK_RETURN_ON_ERROR(krpc_encode_float(stream, value->e1));
  }
  {
    if (!pb_encode_tag_for_field(stream, field))
      KRPC_CALLBACK_RETURN_ERROR("encoding tag for tuple item");
    size_t size;
    KRPC_CALLBACK_RETURN_ON_ERROR(krpc_encode_size_float(&size, value->e2));
    if (!pb_encode_varint(stream, size))
      KRPC_CALLBACK_RETURN_ERROR("encoding size for tuple item");
    KRPC_CALLBACK_RETURN_ON_ERROR(krpc_encode_float(stream, value->e2));
  }
  return true;
}

inline krpc_error_t krpc_encode_tuple_float_float_float(
  pb_ostream_t * stream, const krpc_tuple_float_float_float_t * value) {
  krpc_schema_Tuple message = krpc_schema_Tuple_init_default;
  message.items.funcs.encode = &krpc_encode_callback_items_tuple_float_float_float;
  message.items.arg = (krpc_tuple_float_float_float_t*)value;
  KRPC_RETURN_ON_ERROR(krpc_encode_message_Tuple(stream, &message));
  return KRPC_OK;
}

inline krpc_error_t krpc_encode_size_tuple_float_float_float(
  size_t * size, const krpc_tuple_float_float_float_t * value) {
  pb_ostream_t stream = PB_OSTREAM_SIZING;
  KRPC_RETURN_ON_ERROR(krpc_encode_tuple_float_float_float(&stream, value));
  *size = stream.bytes_written;
  return KRPC_OK;
}

inline bool krpc_encode_callback_tuple_float_float_float(
  pb_ostream_t * stream, const pb_field_t * field, void * const * arg) {
  if (!pb_encode_tag_for_field(stream, field))
    KRPC_CALLBACK_RETURN_ERROR("encoding tag for tuple_float_float_float");
  krpc_tuple_float_float_float_t * value = (krpc_tuple_float_float_float_t*)(*arg);
  size_t size;
  KRPC_CALLBACK_RETURN_ON_ERROR(krpc_encode_size_tuple_float_float_float(&size, value));
  if (!pb_encode_varint(stream, size))
    KRPC_CALLBACK_RETURN_ERROR("encoding size for tuple_float_float_float");
  KRPC_CALLBACK_RETURN_ON_ERROR(krpc_encode_tuple_float_float_float(stream, value));
  return true;
}

static bool krpc_decode_callback_item_tuple_float_float_float(
  pb_istream_t * stream, const pb_field_t * field, void ** arg) {
  typedef struct {size_t pos; krpc_tuple_float_float_float_t * value;} State;
  State * state = (State*)(*arg);
  krpc_tuple_float_float_float_t * value = state->value;
  switch (state->pos) {
  case 0:
    KRPC_CALLBACK_RETURN_ON_ERROR(krpc_decode_float(stream, &value->e0));
    break;
  case 1:
    KRPC_CALLBACK_RETURN_ON_ERROR(krpc_decode_float(stream, &value->e1));
    break;
  case 2:
    KRPC_CALLBACK_RETURN_ON_ERROR(krpc_decode_float(stream, &value->e2));
    break;
  default:
    KRPC_CALLBACK_RETURN_ERROR("unexpected tuple item");
  }
  state->pos++;
  return true;
}

inline krpc_error_t krpc_decode_tuple_float_float_float(
  pb_istream_t * stream, krpc_tuple_float_float_float_t * value) {
  krpc_schema_Tuple message = krpc_schema_Tuple_init_default;
  message.items.funcs.decode = &krpc_decode_callback_item_tuple_float_float_float;
  typedef struct { size_t pos; krpc_tuple_float_float_float_t * value; } State;
  State state = { 0, value };
  message.items.arg = &state;
  KRPC_RETURN_ON_ERROR(krpc_decode_message_Tuple(stream, &message));
  return KRPC_OK;
}

#endif  // KRPC_IMPL_TYPE_TUPLE_FLOAT_FLOAT_FLOAT

#ifndef KRPC_IMPL_TYPE_LIST_OBJECT
#define KRPC_IMPL_TYPE_LIST_OBJECT

static bool krpc_encode_callback_items_list_object(
  pb_ostream_t * stream, const pb_field_t * field, void * const * arg) {
  const krpc_list_object_t * value = (const krpc_list_object_t*)(*arg);
  size_t i = 0;
  for (; i < value->size; i++) {
    if (!pb_encode_tag_for_field(stream, field))
      KRPC_CALLBACK_RETURN_ERROR("encoding tag for list item");
    size_t size;
    KRPC_CALLBACK_RETURN_ON_ERROR(krpc_encode_size_object(&size, value->items[i]));
    if (!pb_encode_varint(stream, size))
      KRPC_CALLBACK_RETURN_ERROR("encoding size for list item");
    KRPC_CALLBACK_RETURN_ON_ERROR(krpc_encode_object(stream, value->items[i]));
  }
  return true;
}

inline krpc_error_t krpc_encode_list_object(
  pb_ostream_t * stream, const krpc_list_object_t * value) {
  krpc_schema_List message = krpc_schema_List_init_default;
  message.items.funcs.encode = &krpc_encode_callback_items_list_object;
  message.items.arg = (krpc_list_object_t*)value;
  KRPC_RETURN_ON_ERROR(krpc_encode_message_List(stream, &message));
  return KRPC_OK;
}

inline krpc_error_t krpc_encode_size_list_object(
  size_t * size, const krpc_list_object_t * value) {
  pb_ostream_t stream = PB_OSTREAM_SIZING;
  KRPC_RETURN_ON_ERROR(krpc_encode_list_object(&stream, value));
  *size = stream.bytes_written;
  return KRPC_OK;
}

inline bool krpc_encode_callback_list_object(
  pb_ostream_t * stream, const pb_field_t * field, void * const * arg) {
  if (!pb_encode_tag_for_field(stream, field))
    KRPC_CALLBACK_RETURN_ERROR("encoding tag for list_object");
  krpc_list_object_t * value = (krpc_list_object_t*)(*arg);
  size_t size;
  KRPC_CALLBACK_RETURN_ON_ERROR(krpc_encode_size_list_object(&size, value));
  if (!pb_encode_varint(stream, size))
    KRPC_CALLBACK_RETURN_ERROR("encoding size for list_object");
  KRPC_CALLBACK_RETURN_ON_ERROR(krpc_encode_list_object(stream, value));
  return true;
}

static bool krpc_decode_callback_item_list_object(
  pb_istream_t * stream, const pb_field_t * field, void ** arg) {
  typedef struct { size_t capacity; krpc_list_object_t * value; } State;
  State * state = (State*)(*arg);
  size_t i = state->value->size;
  state->value->size++;
  if (state->capacity > 0 && state->value->size > state->capacity) {
    state->value->items = (krpc_SpaceCenter_Part_t*)krpc_recalloc(state->value->items, state->capacity, KRPC_ALLOC_BLOCK_SIZE, sizeof(krpc_SpaceCenter_Part_t));
    state->capacity += KRPC_ALLOC_BLOCK_SIZE;
  }
  KRPC_CALLBACK_RETURN_ON_ERROR(krpc_decode_object(stream, &state->value->items[i]));
  return true;
}

inline krpc_error_t krpc_decode_list_object(
  pb_istream_t * stream, krpc_list_object_t * value) {
  typedef struct { size_t capacity; krpc_list_object_t * value; } State;
  State state = { 0, value };
  value->size = 0;
  if (value->items == NULL) {
    value->items = (krpc_SpaceCenter_Part_t*)krpc_calloc(KRPC_ALLOC_BLOCK_SIZE, sizeof(krpc_SpaceCenter_Part_t));
    state.capacity = KRPC_ALLOC_BLOCK_SIZE;
  }
  krpc_schema_List message = krpc_schema_List_init_default;
  message.items.funcs.decode = &krpc_decode_callback_item_list_object;
  message.items.arg = &state;
  KRPC_RETURN_ON_ERROR(krpc_decode_message_List(stream, &message));
  return KRPC_OK;
}

#endif  // KRPC_IMPL_TYPE_LIST_OBJECT

#ifndef KRPC_IMPL_TYPE_TUPLE_DOUBLE_DOUBLE_DOUBLE_DOUBLE
#define KRPC_IMPL_TYPE_TUPLE_DOUBLE_DOUBLE_DOUBLE_DOUBLE

static bool krpc_encode_callback_items_tuple_double_double_double_double(
  pb_ostream_t * stream, const pb_field_t * field, void * const * arg) {
  const krpc_tuple_double_double_double_double_t * value = (const krpc_tuple_double_double_double_double_t*)(*arg);
  {
    if (!pb_encode_tag_for_field(stream, field))
      KRPC_CALLBACK_RETURN_ERROR("encoding tag for tuple item");
    size_t size;
    KRPC_CALLBACK_RETURN_ON_ERROR(krpc_encode_size_double(&size, value->e0));
    if (!pb_encode_varint(stream, size))
      KRPC_CALLBACK_RETURN_ERROR("encoding size for tuple item");
    KRPC_CALLBACK_RETURN_ON_ERROR(krpc_encode_double(stream, value->e0));
  }
  {
    if (!pb_encode_tag_for_field(stream, field))
      KRPC_CALLBACK_RETURN_ERROR("encoding tag for tuple item");
    size_t size;
    KRPC_CALLBACK_RETURN_ON_ERROR(krpc_encode_size_double(&size, value->e1));
    if (!pb_encode_varint(stream, size))
      KRPC_CALLBACK_RETURN_ERROR("encoding size for tuple item");
    KRPC_CALLBACK_RETURN_ON_ERROR(krpc_encode_double(stream, value->e1));
  }
  {
    if (!pb_encode_tag_for_field(stream, field))
      KRPC_CALLBACK_RETURN_ERROR("encoding tag for tuple item");
    size_t size;
    KRPC_CALLBACK_RETURN_ON_ERROR(krpc_encode_size_double(&size, value->e2));
    if (!pb_encode_varint(stream, size))
      KRPC_CALLBACK_RETURN_ERROR("encoding size for tuple item");
    KRPC_CALLBACK_RETURN_ON_ERROR(krpc_encode_double(stream, value->e2));
  }
  {
    if (!pb_encode_tag_for_field(stream, field))
      KRPC_CALLBACK_RETURN_ERROR("encoding tag for tuple item");
    size_t size;
    KRPC_CALLBACK_RETURN_ON_ERROR(krpc_encode_size_double(&size, value->e3));
    if (!pb_encode_varint(stream, size))
      KRPC_CALLBACK_RETURN_ERROR("encoding size for tuple item");
    KRPC_CALLBACK_RETURN_ON_ERROR(krpc_encode_double(stream, value->e3));
  }
  return true;
}

inline krpc_error_t krpc_encode_tuple_double_double_double_double(
  pb_ostream_t * stream, const krpc_tuple_double_double_double_double_t * value) {
  krpc_schema_Tuple message = krpc_schema_Tuple_init_default;
  message.items.funcs.encode = &krpc_encode_callback_items_tuple_double_double_double_double;
  message.items.arg = (krpc_tuple_double_double_double_double_t*)value;
  KRPC_RETURN_ON_ERROR(krpc_encode_message_Tuple(stream, &message));
  return KRPC_OK;
}

inline krpc_error_t krpc_encode_size_tuple_double_double_double_double(
  size_t * size, const krpc_tuple_double_double_double_double_t * value) {
  pb_ostream_t stream = PB_OSTREAM_SIZING;
  KRPC_RETURN_ON_ERROR(krpc_encode_tuple_double_double_double_double(&stream, value));
  *size = stream.bytes_written;
  return KRPC_OK;
}

inline bool krpc_encode_callback_tuple_double_double_double_double(
  pb_ostream_t * stream, const pb_field_t * field, void * const * arg) {
  if (!pb_encode_tag_for_field(stream, field))
    KRPC_CALLBACK_RETURN_ERROR("encoding tag for tuple_double_double_double_double");
  krpc_tuple_double_double_double_double_t * value = (krpc_tuple_double_double_double_double_t*)(*arg);
  size_t size;
  KRPC_CALLBACK_RETURN_ON_ERROR(krpc_encode_size_tuple_double_double_double_double(&size, value));
  if (!pb_encode_varint(stream, size))
    KRPC_CALLBACK_RETURN_ERROR("encoding size for tuple_double_double_double_double");
  KRPC_CALLBACK_RETURN_ON_ERROR(krpc_encode_tuple_double_double_double_double(stream, value));
  return true;
}

static bool krpc_decode_callback_item_tuple_double_double_double_double(
  pb_istream_t * stream, const pb_field_t * field, void ** arg) {
  typedef struct {size_t pos; krpc_tuple_double_double_double_double_t * value;} State;
  State * state = (State*)(*arg);
  krpc_tuple_double_double_double_double_t * value = state->value;
  switch (state->pos) {
  case 0:
    KRPC_CALLBACK_RETURN_ON_ERROR(krpc_decode_double(stream, &value->e0));
    break;
  case 1:
    KRPC_CALLBACK_RETURN_ON_ERROR(krpc_decode_double(stream, &value->e1));
    break;
  case 2:
    KRPC_CALLBACK_RETURN_ON_ERROR(krpc_decode_double(stream, &value->e2));
    break;
  case 3:
    KRPC_CALLBACK_RETURN_ON_ERROR(krpc_decode_double(stream, &value->e3));
    break;
  default:
    KRPC_CALLBACK_RETURN_ERROR("unexpected tuple item");
  }
  state->pos++;
  return true;
}

inline krpc_error_t krpc_decode_tuple_double_double_double_double(
  pb_istream_t * stream, krpc_tuple_double_double_double_double_t * value) {
  krpc_schema_Tuple message = krpc_schema_Tuple_init_default;
  message.items.funcs.decode = &krpc_decode_callback_item_tuple_double_double_double_double;
  typedef struct { size_t pos; krpc_tuple_double_double_double_double_t * value; } State;
  State state = { 0, value };
  message.items.arg = &state;
  KRPC_RETURN_ON_ERROR(krpc_decode_message_Tuple(stream, &message));
  return KRPC_OK;
}

#endif  // KRPC_IMPL_TYPE_TUPLE_DOUBLE_DOUBLE_DOUBLE_DOUBLE

#ifndef KRPC_IMPL_TYPE_LIST_OBJECT
#define KRPC_IMPL_TYPE_LIST_OBJECT

static bool krpc_encode_callback_items_list_object(
  pb_ostream_t * stream, const pb_field_t * field, void * const * arg) {
  const krpc_list_object_t * value = (const krpc_list_object_t*)(*arg);
  size_t i = 0;
  for (; i < value->size; i++) {
    if (!pb_encode_tag_for_field(stream, field))
      KRPC_CALLBACK_RETURN_ERROR("encoding tag for list item");
    size_t size;
    KRPC_CALLBACK_RETURN_ON_ERROR(krpc_encode_size_object(&size, value->items[i]));
    if (!pb_encode_varint(stream, size))
      KRPC_CALLBACK_RETURN_ERROR("encoding size for list item");
    KRPC_CALLBACK_RETURN_ON_ERROR(krpc_encode_object(stream, value->items[i]));
  }
  return true;
}

inline krpc_error_t krpc_encode_list_object(
  pb_ostream_t * stream, const krpc_list_object_t * value) {
  krpc_schema_List message = krpc_schema_List_init_default;
  message.items.funcs.encode = &krpc_encode_callback_items_list_object;
  message.items.arg = (krpc_list_object_t*)value;
  KRPC_RETURN_ON_ERROR(krpc_encode_message_List(stream, &message));
  return KRPC_OK;
}

inline krpc_error_t krpc_encode_size_list_object(
  size_t * size, const krpc_list_object_t * value) {
  pb_ostream_t stream = PB_OSTREAM_SIZING;
  KRPC_RETURN_ON_ERROR(krpc_encode_list_object(&stream, value));
  *size = stream.bytes_written;
  return KRPC_OK;
}

inline bool krpc_encode_callback_list_object(
  pb_ostream_t * stream, const pb_field_t * field, void * const * arg) {
  if (!pb_encode_tag_for_field(stream, field))
    KRPC_CALLBACK_RETURN_ERROR("encoding tag for list_object");
  krpc_list_object_t * value = (krpc_list_object_t*)(*arg);
  size_t size;
  KRPC_CALLBACK_RETURN_ON_ERROR(krpc_encode_size_list_object(&size, value));
  if (!pb_encode_varint(stream, size))
    KRPC_CALLBACK_RETURN_ERROR("encoding size for list_object");
  KRPC_CALLBACK_RETURN_ON_ERROR(krpc_encode_list_object(stream, value));
  return true;
}

static bool krpc_decode_callback_item_list_object(
  pb_istream_t * stream, const pb_field_t * field, void ** arg) {
  typedef struct { size_t capacity; krpc_list_object_t * value; } State;
  State * state = (State*)(*arg);
  size_t i = state->value->size;
  state->value->size++;
  if (state->capacity > 0 && state->value->size > state->capacity) {
    state->value->items = (krpc_SpaceCenter_CargoBay_t*)krpc_recalloc(state->value->items, state->capacity, KRPC_ALLOC_BLOCK_SIZE, sizeof(krpc_SpaceCenter_CargoBay_t));
    state->capacity += KRPC_ALLOC_BLOCK_SIZE;
  }
  KRPC_CALLBACK_RETURN_ON_ERROR(krpc_decode_object(stream, &state->value->items[i]));
  return true;
}

inline krpc_error_t krpc_decode_list_object(
  pb_istream_t * stream, krpc_list_object_t * value) {
  typedef struct { size_t capacity; krpc_list_object_t * value; } State;
  State state = { 0, value };
  value->size = 0;
  if (value->items == NULL) {
    value->items = (krpc_SpaceCenter_CargoBay_t*)krpc_calloc(KRPC_ALLOC_BLOCK_SIZE, sizeof(krpc_SpaceCenter_CargoBay_t));
    state.capacity = KRPC_ALLOC_BLOCK_SIZE;
  }
  krpc_schema_List message = krpc_schema_List_init_default;
  message.items.funcs.decode = &krpc_decode_callback_item_list_object;
  message.items.arg = &state;
  KRPC_RETURN_ON_ERROR(krpc_decode_message_List(stream, &message));
  return KRPC_OK;
}

#endif  // KRPC_IMPL_TYPE_LIST_OBJECT

#ifndef KRPC_IMPL_TYPE_LIST_OBJECT
#define KRPC_IMPL_TYPE_LIST_OBJECT

static bool krpc_encode_callback_items_list_object(
  pb_ostream_t * stream, const pb_field_t * field, void * const * arg) {
  const krpc_list_object_t * value = (const krpc_list_object_t*)(*arg);
  size_t i = 0;
  for (; i < value->size; i++) {
    if (!pb_encode_tag_for_field(stream, field))
      KRPC_CALLBACK_RETURN_ERROR("encoding tag for list item");
    size_t size;
    KRPC_CALLBACK_RETURN_ON_ERROR(krpc_encode_size_object(&size, value->items[i]));
    if (!pb_encode_varint(stream, size))
      KRPC_CALLBACK_RETURN_ERROR("encoding size for list item");
    KRPC_CALLBACK_RETURN_ON_ERROR(krpc_encode_object(stream, value->items[i]));
  }
  return true;
}

inline krpc_error_t krpc_encode_list_object(
  pb_ostream_t * stream, const krpc_list_object_t * value) {
  krpc_schema_List message = krpc_schema_List_init_default;
  message.items.funcs.encode = &krpc_encode_callback_items_list_object;
  message.items.arg = (krpc_list_object_t*)value;
  KRPC_RETURN_ON_ERROR(krpc_encode_message_List(stream, &message));
  return KRPC_OK;
}

inline krpc_error_t krpc_encode_size_list_object(
  size_t * size, const krpc_list_object_t * value) {
  pb_ostream_t stream = PB_OSTREAM_SIZING;
  KRPC_RETURN_ON_ERROR(krpc_encode_list_object(&stream, value));
  *size = stream.bytes_written;
  return KRPC_OK;
}

inline bool krpc_encode_callback_list_object(
  pb_ostream_t * stream, const pb_field_t * field, void * const * arg) {
  if (!pb_encode_tag_for_field(stream, field))
    KRPC_CALLBACK_RETURN_ERROR("encoding tag for list_object");
  krpc_list_object_t * value = (krpc_list_object_t*)(*arg);
  size_t size;
  KRPC_CALLBACK_RETURN_ON_ERROR(krpc_encode_size_list_object(&size, value));
  if (!pb_encode_varint(stream, size))
    KRPC_CALLBACK_RETURN_ERROR("encoding size for list_object");
  KRPC_CALLBACK_RETURN_ON_ERROR(krpc_encode_list_object(stream, value));
  return true;
}

static bool krpc_decode_callback_item_list_object(
  pb_istream_t * stream, const pb_field_t * field, void ** arg) {
  typedef struct { size_t capacity; krpc_list_object_t * value; } State;
  State * state = (State*)(*arg);
  size_t i = state->value->size;
  state->value->size++;
  if (state->capacity > 0 && state->value->size > state->capacity) {
    state->value->items = (krpc_SpaceCenter_Contract_t*)krpc_recalloc(state->value->items, state->capacity, KRPC_ALLOC_BLOCK_SIZE, sizeof(krpc_SpaceCenter_Contract_t));
    state->capacity += KRPC_ALLOC_BLOCK_SIZE;
  }
  KRPC_CALLBACK_RETURN_ON_ERROR(krpc_decode_object(stream, &state->value->items[i]));
  return true;
}

inline krpc_error_t krpc_decode_list_object(
  pb_istream_t * stream, krpc_list_object_t * value) {
  typedef struct { size_t capacity; krpc_list_object_t * value; } State;
  State state = { 0, value };
  value->size = 0;
  if (value->items == NULL) {
    value->items = (krpc_SpaceCenter_Contract_t*)krpc_calloc(KRPC_ALLOC_BLOCK_SIZE, sizeof(krpc_SpaceCenter_Contract_t));
    state.capacity = KRPC_ALLOC_BLOCK_SIZE;
  }
  krpc_schema_List message = krpc_schema_List_init_default;
  message.items.funcs.decode = &krpc_decode_callback_item_list_object;
  message.items.arg = &state;
  KRPC_RETURN_ON_ERROR(krpc_decode_message_List(stream, &message));
  return KRPC_OK;
}

#endif  // KRPC_IMPL_TYPE_LIST_OBJECT

#ifndef KRPC_IMPL_TYPE_LIST_OBJECT
#define KRPC_IMPL_TYPE_LIST_OBJECT

static bool krpc_encode_callback_items_list_object(
  pb_ostream_t * stream, const pb_field_t * field, void * const * arg) {
  const krpc_list_object_t * value = (const krpc_list_object_t*)(*arg);
  size_t i = 0;
  for (; i < value->size; i++) {
    if (!pb_encode_tag_for_field(stream, field))
      KRPC_CALLBACK_RETURN_ERROR("encoding tag for list item");
    size_t size;
    KRPC_CALLBACK_RETURN_ON_ERROR(krpc_encode_size_object(&size, value->items[i]));
    if (!pb_encode_varint(stream, size))
      KRPC_CALLBACK_RETURN_ERROR("encoding size for list item");
    KRPC_CALLBACK_RETURN_ON_ERROR(krpc_encode_object(stream, value->items[i]));
  }
  return true;
}

inline krpc_error_t krpc_encode_list_object(
  pb_ostream_t * stream, const krpc_list_object_t * value) {
  krpc_schema_List message = krpc_schema_List_init_default;
  message.items.funcs.encode = &krpc_encode_callback_items_list_object;
  message.items.arg = (krpc_list_object_t*)value;
  KRPC_RETURN_ON_ERROR(krpc_encode_message_List(stream, &message));
  return KRPC_OK;
}

inline krpc_error_t krpc_encode_size_list_object(
  size_t * size, const krpc_list_object_t * value) {
  pb_ostream_t stream = PB_OSTREAM_SIZING;
  KRPC_RETURN_ON_ERROR(krpc_encode_list_object(&stream, value));
  *size = stream.bytes_written;
  return KRPC_OK;
}

inline bool krpc_encode_callback_list_object(
  pb_ostream_t * stream, const pb_field_t * field, void * const * arg) {
  if (!pb_encode_tag_for_field(stream, field))
    KRPC_CALLBACK_RETURN_ERROR("encoding tag for list_object");
  krpc_list_object_t * value = (krpc_list_object_t*)(*arg);
  size_t size;
  KRPC_CALLBACK_RETURN_ON_ERROR(krpc_encode_size_list_object(&size, value));
  if (!pb_encode_varint(stream, size))
    KRPC_CALLBACK_RETURN_ERROR("encoding size for list_object");
  KRPC_CALLBACK_RETURN_ON_ERROR(krpc_encode_list_object(stream, value));
  return true;
}

static bool krpc_decode_callback_item_list_object(
  pb_istream_t * stream, const pb_field_t * field, void ** arg) {
  typedef struct { size_t capacity; krpc_list_object_t * value; } State;
  State * state = (State*)(*arg);
  size_t i = state->value->size;
  state->value->size++;
  if (state->capacity > 0 && state->value->size > state->capacity) {
    state->value->items = (krpc_SpaceCenter_RCS_t*)krpc_recalloc(state->value->items, state->capacity, KRPC_ALLOC_BLOCK_SIZE, sizeof(krpc_SpaceCenter_RCS_t));
    state->capacity += KRPC_ALLOC_BLOCK_SIZE;
  }
  KRPC_CALLBACK_RETURN_ON_ERROR(krpc_decode_object(stream, &state->value->items[i]));
  return true;
}

inline krpc_error_t krpc_decode_list_object(
  pb_istream_t * stream, krpc_list_object_t * value) {
  typedef struct { size_t capacity; krpc_list_object_t * value; } State;
  State state = { 0, value };
  value->size = 0;
  if (value->items == NULL) {
    value->items = (krpc_SpaceCenter_RCS_t*)krpc_calloc(KRPC_ALLOC_BLOCK_SIZE, sizeof(krpc_SpaceCenter_RCS_t));
    state.capacity = KRPC_ALLOC_BLOCK_SIZE;
  }
  krpc_schema_List message = krpc_schema_List_init_default;
  message.items.funcs.decode = &krpc_decode_callback_item_list_object;
  message.items.arg = &state;
  KRPC_RETURN_ON_ERROR(krpc_decode_message_List(stream, &message));
  return KRPC_OK;
}

#endif  // KRPC_IMPL_TYPE_LIST_OBJECT

#ifndef KRPC_IMPL_TYPE_LIST_OBJECT
#define KRPC_IMPL_TYPE_LIST_OBJECT

static bool krpc_encode_callback_items_list_object(
  pb_ostream_t * stream, const pb_field_t * field, void * const * arg) {
  const krpc_list_object_t * value = (const krpc_list_object_t*)(*arg);
  size_t i = 0;
  for (; i < value->size; i++) {
    if (!pb_encode_tag_for_field(stream, field))
      KRPC_CALLBACK_RETURN_ERROR("encoding tag for list item");
    size_t size;
    KRPC_CALLBACK_RETURN_ON_ERROR(krpc_encode_size_object(&size, value->items[i]));
    if (!pb_encode_varint(stream, size))
      KRPC_CALLBACK_RETURN_ERROR("encoding size for list item");
    KRPC_CALLBACK_RETURN_ON_ERROR(krpc_encode_object(stream, value->items[i]));
  }
  return true;
}

inline krpc_error_t krpc_encode_list_object(
  pb_ostream_t * stream, const krpc_list_object_t * value) {
  krpc_schema_List message = krpc_schema_List_init_default;
  message.items.funcs.encode = &krpc_encode_callback_items_list_object;
  message.items.arg = (krpc_list_object_t*)value;
  KRPC_RETURN_ON_ERROR(krpc_encode_message_List(stream, &message));
  return KRPC_OK;
}

inline krpc_error_t krpc_encode_size_list_object(
  size_t * size, const krpc_list_object_t * value) {
  pb_ostream_t stream = PB_OSTREAM_SIZING;
  KRPC_RETURN_ON_ERROR(krpc_encode_list_object(&stream, value));
  *size = stream.bytes_written;
  return KRPC_OK;
}

inline bool krpc_encode_callback_list_object(
  pb_ostream_t * stream, const pb_field_t * field, void * const * arg) {
  if (!pb_encode_tag_for_field(stream, field))
    KRPC_CALLBACK_RETURN_ERROR("encoding tag for list_object");
  krpc_list_object_t * value = (krpc_list_object_t*)(*arg);
  size_t size;
  KRPC_CALLBACK_RETURN_ON_ERROR(krpc_encode_size_list_object(&size, value));
  if (!pb_encode_varint(stream, size))
    KRPC_CALLBACK_RETURN_ERROR("encoding size for list_object");
  KRPC_CALLBACK_RETURN_ON_ERROR(krpc_encode_list_object(stream, value));
  return true;
}

static bool krpc_decode_callback_item_list_object(
  pb_istream_t * stream, const pb_field_t * field, void ** arg) {
  typedef struct { size_t capacity; krpc_list_object_t * value; } State;
  State * state = (State*)(*arg);
  size_t i = state->value->size;
  state->value->size++;
  if (state->capacity > 0 && state->value->size > state->capacity) {
    state->value->items = (krpc_SpaceCenter_SolarPanel_t*)krpc_recalloc(state->value->items, state->capacity, KRPC_ALLOC_BLOCK_SIZE, sizeof(krpc_SpaceCenter_SolarPanel_t));
    state->capacity += KRPC_ALLOC_BLOCK_SIZE;
  }
  KRPC_CALLBACK_RETURN_ON_ERROR(krpc_decode_object(stream, &state->value->items[i]));
  return true;
}

inline krpc_error_t krpc_decode_list_object(
  pb_istream_t * stream, krpc_list_object_t * value) {
  typedef struct { size_t capacity; krpc_list_object_t * value; } State;
  State state = { 0, value };
  value->size = 0;
  if (value->items == NULL) {
    value->items = (krpc_SpaceCenter_SolarPanel_t*)krpc_calloc(KRPC_ALLOC_BLOCK_SIZE, sizeof(krpc_SpaceCenter_SolarPanel_t));
    state.capacity = KRPC_ALLOC_BLOCK_SIZE;
  }
  krpc_schema_List message = krpc_schema_List_init_default;
  message.items.funcs.decode = &krpc_decode_callback_item_list_object;
  message.items.arg = &state;
  KRPC_RETURN_ON_ERROR(krpc_decode_message_List(stream, &message));
  return KRPC_OK;
}

#endif  // KRPC_IMPL_TYPE_LIST_OBJECT

#ifndef KRPC_IMPL_TYPE_LIST_OBJECT
#define KRPC_IMPL_TYPE_LIST_OBJECT

static bool krpc_encode_callback_items_list_object(
  pb_ostream_t * stream, const pb_field_t * field, void * const * arg) {
  const krpc_list_object_t * value = (const krpc_list_object_t*)(*arg);
  size_t i = 0;
  for (; i < value->size; i++) {
    if (!pb_encode_tag_for_field(stream, field))
      KRPC_CALLBACK_RETURN_ERROR("encoding tag for list item");
    size_t size;
    KRPC_CALLBACK_RETURN_ON_ERROR(krpc_encode_size_object(&size, value->items[i]));
    if (!pb_encode_varint(stream, size))
      KRPC_CALLBACK_RETURN_ERROR("encoding size for list item");
    KRPC_CALLBACK_RETURN_ON_ERROR(krpc_encode_object(stream, value->items[i]));
  }
  return true;
}

inline krpc_error_t krpc_encode_list_object(
  pb_ostream_t * stream, const krpc_list_object_t * value) {
  krpc_schema_List message = krpc_schema_List_init_default;
  message.items.funcs.encode = &krpc_encode_callback_items_list_object;
  message.items.arg = (krpc_list_object_t*)value;
  KRPC_RETURN_ON_ERROR(krpc_encode_message_List(stream, &message));
  return KRPC_OK;
}

inline krpc_error_t krpc_encode_size_list_object(
  size_t * size, const krpc_list_object_t * value) {
  pb_ostream_t stream = PB_OSTREAM_SIZING;
  KRPC_RETURN_ON_ERROR(krpc_encode_list_object(&stream, value));
  *size = stream.bytes_written;
  return KRPC_OK;
}

inline bool krpc_encode_callback_list_object(
  pb_ostream_t * stream, const pb_field_t * field, void * const * arg) {
  if (!pb_encode_tag_for_field(stream, field))
    KRPC_CALLBACK_RETURN_ERROR("encoding tag for list_object");
  krpc_list_object_t * value = (krpc_list_object_t*)(*arg);
  size_t size;
  KRPC_CALLBACK_RETURN_ON_ERROR(krpc_encode_size_list_object(&size, value));
  if (!pb_encode_varint(stream, size))
    KRPC_CALLBACK_RETURN_ERROR("encoding size for list_object");
  KRPC_CALLBACK_RETURN_ON_ERROR(krpc_encode_list_object(stream, value));
  return true;
}

static bool krpc_decode_callback_item_list_object(
  pb_istream_t * stream, const pb_field_t * field, void ** arg) {
  typedef struct { size_t capacity; krpc_list_object_t * value; } State;
  State * state = (State*)(*arg);
  size_t i = state->value->size;
  state->value->size++;
  if (state->capacity > 0 && state->value->size > state->capacity) {
    state->value->items = (krpc_SpaceCenter_Wheel_t*)krpc_recalloc(state->value->items, state->capacity, KRPC_ALLOC_BLOCK_SIZE, sizeof(krpc_SpaceCenter_Wheel_t));
    state->capacity += KRPC_ALLOC_BLOCK_SIZE;
  }
  KRPC_CALLBACK_RETURN_ON_ERROR(krpc_decode_object(stream, &state->value->items[i]));
  return true;
}

inline krpc_error_t krpc_decode_list_object(
  pb_istream_t * stream, krpc_list_object_t * value) {
  typedef struct { size_t capacity; krpc_list_object_t * value; } State;
  State state = { 0, value };
  value->size = 0;
  if (value->items == NULL) {
    value->items = (krpc_SpaceCenter_Wheel_t*)krpc_calloc(KRPC_ALLOC_BLOCK_SIZE, sizeof(krpc_SpaceCenter_Wheel_t));
    state.capacity = KRPC_ALLOC_BLOCK_SIZE;
  }
  krpc_schema_List message = krpc_schema_List_init_default;
  message.items.funcs.decode = &krpc_decode_callback_item_list_object;
  message.items.arg = &state;
  KRPC_RETURN_ON_ERROR(krpc_decode_message_List(stream, &message));
  return KRPC_OK;
}

#endif  // KRPC_IMPL_TYPE_LIST_OBJECT

#ifndef KRPC_IMPL_TYPE_LIST_OBJECT
#define KRPC_IMPL_TYPE_LIST_OBJECT

static bool krpc_encode_callback_items_list_object(
  pb_ostream_t * stream, const pb_field_t * field, void * const * arg) {
  const krpc_list_object_t * value = (const krpc_list_object_t*)(*arg);
  size_t i = 0;
  for (; i < value->size; i++) {
    if (!pb_encode_tag_for_field(stream, field))
      KRPC_CALLBACK_RETURN_ERROR("encoding tag for list item");
    size_t size;
    KRPC_CALLBACK_RETURN_ON_ERROR(krpc_encode_size_object(&size, value->items[i]));
    if (!pb_encode_varint(stream, size))
      KRPC_CALLBACK_RETURN_ERROR("encoding size for list item");
    KRPC_CALLBACK_RETURN_ON_ERROR(krpc_encode_object(stream, value->items[i]));
  }
  return true;
}

inline krpc_error_t krpc_encode_list_object(
  pb_ostream_t * stream, const krpc_list_object_t * value) {
  krpc_schema_List message = krpc_schema_List_init_default;
  message.items.funcs.encode = &krpc_encode_callback_items_list_object;
  message.items.arg = (krpc_list_object_t*)value;
  KRPC_RETURN_ON_ERROR(krpc_encode_message_List(stream, &message));
  return KRPC_OK;
}

inline krpc_error_t krpc_encode_size_list_object(
  size_t * size, const krpc_list_object_t * value) {
  pb_ostream_t stream = PB_OSTREAM_SIZING;
  KRPC_RETURN_ON_ERROR(krpc_encode_list_object(&stream, value));
  *size = stream.bytes_written;
  return KRPC_OK;
}

inline bool krpc_encode_callback_list_object(
  pb_ostream_t * stream, const pb_field_t * field, void * const * arg) {
  if (!pb_encode_tag_for_field(stream, field))
    KRPC_CALLBACK_RETURN_ERROR("encoding tag for list_object");
  krpc_list_object_t * value = (krpc_list_object_t*)(*arg);
  size_t size;
  KRPC_CALLBACK_RETURN_ON_ERROR(krpc_encode_size_list_object(&size, value));
  if (!pb_encode_varint(stream, size))
    KRPC_CALLBACK_RETURN_ERROR("encoding size for list_object");
  KRPC_CALLBACK_RETURN_ON_ERROR(krpc_encode_list_object(stream, value));
  return true;
}

static bool krpc_decode_callback_item_list_object(
  pb_istream_t * stream, const pb_field_t * field, void ** arg) {
  typedef struct { size_t capacity; krpc_list_object_t * value; } State;
  State * state = (State*)(*arg);
  size_t i = state->value->size;
  state->value->size++;
  if (state->capacity > 0 && state->value->size > state->capacity) {
    state->value->items = (krpc_SpaceCenter_DockingPort_t*)krpc_recalloc(state->value->items, state->capacity, KRPC_ALLOC_BLOCK_SIZE, sizeof(krpc_SpaceCenter_DockingPort_t));
    state->capacity += KRPC_ALLOC_BLOCK_SIZE;
  }
  KRPC_CALLBACK_RETURN_ON_ERROR(krpc_decode_object(stream, &state->value->items[i]));
  return true;
}

inline krpc_error_t krpc_decode_list_object(
  pb_istream_t * stream, krpc_list_object_t * value) {
  typedef struct { size_t capacity; krpc_list_object_t * value; } State;
  State state = { 0, value };
  value->size = 0;
  if (value->items == NULL) {
    value->items = (krpc_SpaceCenter_DockingPort_t*)krpc_calloc(KRPC_ALLOC_BLOCK_SIZE, sizeof(krpc_SpaceCenter_DockingPort_t));
    state.capacity = KRPC_ALLOC_BLOCK_SIZE;
  }
  krpc_schema_List message = krpc_schema_List_init_default;
  message.items.funcs.decode = &krpc_decode_callback_item_list_object;
  message.items.arg = &state;
  KRPC_RETURN_ON_ERROR(krpc_decode_message_List(stream, &message));
  return KRPC_OK;
}

#endif  // KRPC_IMPL_TYPE_LIST_OBJECT

#ifndef KRPC_IMPL_TYPE_LIST_OBJECT
#define KRPC_IMPL_TYPE_LIST_OBJECT

static bool krpc_encode_callback_items_list_object(
  pb_ostream_t * stream, const pb_field_t * field, void * const * arg) {
  const krpc_list_object_t * value = (const krpc_list_object_t*)(*arg);
  size_t i = 0;
  for (; i < value->size; i++) {
    if (!pb_encode_tag_for_field(stream, field))
      KRPC_CALLBACK_RETURN_ERROR("encoding tag for list item");
    size_t size;
    KRPC_CALLBACK_RETURN_ON_ERROR(krpc_encode_size_object(&size, value->items[i]));
    if (!pb_encode_varint(stream, size))
      KRPC_CALLBACK_RETURN_ERROR("encoding size for list item");
    KRPC_CALLBACK_RETURN_ON_ERROR(krpc_encode_object(stream, value->items[i]));
  }
  return true;
}

inline krpc_error_t krpc_encode_list_object(
  pb_ostream_t * stream, const krpc_list_object_t * value) {
  krpc_schema_List message = krpc_schema_List_init_default;
  message.items.funcs.encode = &krpc_encode_callback_items_list_object;
  message.items.arg = (krpc_list_object_t*)value;
  KRPC_RETURN_ON_ERROR(krpc_encode_message_List(stream, &message));
  return KRPC_OK;
}

inline krpc_error_t krpc_encode_size_list_object(
  size_t * size, const krpc_list_object_t * value) {
  pb_ostream_t stream = PB_OSTREAM_SIZING;
  KRPC_RETURN_ON_ERROR(krpc_encode_list_object(&stream, value));
  *size = stream.bytes_written;
  return KRPC_OK;
}

inline bool krpc_encode_callback_list_object(
  pb_ostream_t * stream, const pb_field_t * field, void * const * arg) {
  if (!pb_encode_tag_for_field(stream, field))
    KRPC_CALLBACK_RETURN_ERROR("encoding tag for list_object");
  krpc_list_object_t * value = (krpc_list_object_t*)(*arg);
  size_t size;
  KRPC_CALLBACK_RETURN_ON_ERROR(krpc_encode_size_list_object(&size, value));
  if (!pb_encode_varint(stream, size))
    KRPC_CALLBACK_RETURN_ERROR("encoding size for list_object");
  KRPC_CALLBACK_RETURN_ON_ERROR(krpc_encode_list_object(stream, value));
  return true;
}

static bool krpc_decode_callback_item_list_object(
  pb_istream_t * stream, const pb_field_t * field, void ** arg) {
  typedef struct { size_t capacity; krpc_list_object_t * value; } State;
  State * state = (State*)(*arg);
  size_t i = state->value->size;
  state->value->size++;
  if (state->capacity > 0 && state->value->size > state->capacity) {
    state->value->items = (krpc_SpaceCenter_Parachute_t*)krpc_recalloc(state->value->items, state->capacity, KRPC_ALLOC_BLOCK_SIZE, sizeof(krpc_SpaceCenter_Parachute_t));
    state->capacity += KRPC_ALLOC_BLOCK_SIZE;
  }
  KRPC_CALLBACK_RETURN_ON_ERROR(krpc_decode_object(stream, &state->value->items[i]));
  return true;
}

inline krpc_error_t krpc_decode_list_object(
  pb_istream_t * stream, krpc_list_object_t * value) {
  typedef struct { size_t capacity; krpc_list_object_t * value; } State;
  State state = { 0, value };
  value->size = 0;
  if (value->items == NULL) {
    value->items = (krpc_SpaceCenter_Parachute_t*)krpc_calloc(KRPC_ALLOC_BLOCK_SIZE, sizeof(krpc_SpaceCenter_Parachute_t));
    state.capacity = KRPC_ALLOC_BLOCK_SIZE;
  }
  krpc_schema_List message = krpc_schema_List_init_default;
  message.items.funcs.decode = &krpc_decode_callback_item_list_object;
  message.items.arg = &state;
  KRPC_RETURN_ON_ERROR(krpc_decode_message_List(stream, &message));
  return KRPC_OK;
}

#endif  // KRPC_IMPL_TYPE_LIST_OBJECT

#ifndef KRPC_IMPL_TYPE_LIST_OBJECT
#define KRPC_IMPL_TYPE_LIST_OBJECT

static bool krpc_encode_callback_items_list_object(
  pb_ostream_t * stream, const pb_field_t * field, void * const * arg) {
  const krpc_list_object_t * value = (const krpc_list_object_t*)(*arg);
  size_t i = 0;
  for (; i < value->size; i++) {
    if (!pb_encode_tag_for_field(stream, field))
      KRPC_CALLBACK_RETURN_ERROR("encoding tag for list item");
    size_t size;
    KRPC_CALLBACK_RETURN_ON_ERROR(krpc_encode_size_object(&size, value->items[i]));
    if (!pb_encode_varint(stream, size))
      KRPC_CALLBACK_RETURN_ERROR("encoding size for list item");
    KRPC_CALLBACK_RETURN_ON_ERROR(krpc_encode_object(stream, value->items[i]));
  }
  return true;
}

inline krpc_error_t krpc_encode_list_object(
  pb_ostream_t * stream, const krpc_list_object_t * value) {
  krpc_schema_List message = krpc_schema_List_init_default;
  message.items.funcs.encode = &krpc_encode_callback_items_list_object;
  message.items.arg = (krpc_list_object_t*)value;
  KRPC_RETURN_ON_ERROR(krpc_encode_message_List(stream, &message));
  return KRPC_OK;
}

inline krpc_error_t krpc_encode_size_list_object(
  size_t * size, const krpc_list_object_t * value) {
  pb_ostream_t stream = PB_OSTREAM_SIZING;
  KRPC_RETURN_ON_ERROR(krpc_encode_list_object(&stream, value));
  *size = stream.bytes_written;
  return KRPC_OK;
}

inline bool krpc_encode_callback_list_object(
  pb_ostream_t * stream, const pb_field_t * field, void * const * arg) {
  if (!pb_encode_tag_for_field(stream, field))
    KRPC_CALLBACK_RETURN_ERROR("encoding tag for list_object");
  krpc_list_object_t * value = (krpc_list_object_t*)(*arg);
  size_t size;
  KRPC_CALLBACK_RETURN_ON_ERROR(krpc_encode_size_list_object(&size, value));
  if (!pb_encode_varint(stream, size))
    KRPC_CALLBACK_RETURN_ERROR("encoding size for list_object");
  KRPC_CALLBACK_RETURN_ON_ERROR(krpc_encode_list_object(stream, value));
  return true;
}

static bool krpc_decode_callback_item_list_object(
  pb_istream_t * stream, const pb_field_t * field, void ** arg) {
  typedef struct { size_t capacity; krpc_list_object_t * value; } State;
  State * state = (State*)(*arg);
  size_t i = state->value->size;
  state->value->size++;
  if (state->capacity > 0 && state->value->size > state->capacity) {
    state->value->items = (krpc_SpaceCenter_Resource_t*)krpc_recalloc(state->value->items, state->capacity, KRPC_ALLOC_BLOCK_SIZE, sizeof(krpc_SpaceCenter_Resource_t));
    state->capacity += KRPC_ALLOC_BLOCK_SIZE;
  }
  KRPC_CALLBACK_RETURN_ON_ERROR(krpc_decode_object(stream, &state->value->items[i]));
  return true;
}

inline krpc_error_t krpc_decode_list_object(
  pb_istream_t * stream, krpc_list_object_t * value) {
  typedef struct { size_t capacity; krpc_list_object_t * value; } State;
  State state = { 0, value };
  value->size = 0;
  if (value->items == NULL) {
    value->items = (krpc_SpaceCenter_Resource_t*)krpc_calloc(KRPC_ALLOC_BLOCK_SIZE, sizeof(krpc_SpaceCenter_Resource_t));
    state.capacity = KRPC_ALLOC_BLOCK_SIZE;
  }
  krpc_schema_List message = krpc_schema_List_init_default;
  message.items.funcs.decode = &krpc_decode_callback_item_list_object;
  message.items.arg = &state;
  KRPC_RETURN_ON_ERROR(krpc_decode_message_List(stream, &message));
  return KRPC_OK;
}

#endif  // KRPC_IMPL_TYPE_LIST_OBJECT

#ifndef KRPC_IMPL_TYPE_DICTIONARY_STRING_STRING
#define KRPC_IMPL_TYPE_DICTIONARY_STRING_STRING

static bool krpc_encode_callback_key_dictionary_string_string(
  pb_ostream_t * stream, const pb_field_t * field, void * const * arg) {
  if (!pb_encode_tag_for_field(stream, field))
    KRPC_CALLBACK_RETURN_ERROR("encoding tag for dictionary entry key");
  const char * * key = (const char **)(*arg);
  size_t size = 0;
  KRPC_CALLBACK_RETURN_ON_ERROR(krpc_encode_size_string(&size, *key));
  if (!pb_encode_varint(stream, size))
    KRPC_CALLBACK_RETURN_ERROR("encoding size for dictionary entry key");
  KRPC_CALLBACK_RETURN_ON_ERROR(krpc_encode_string(stream, *key));
  return true;
}

static bool krpc_encode_callback_value_dictionary_string_string(
  pb_ostream_t * stream, const pb_field_t * field, void * const * arg) {
  if (!pb_encode_tag_for_field(stream, field))
    KRPC_CALLBACK_RETURN_ERROR("encoding tag for dictionary entry value");
  const char * * value = (const char **)(*arg);
  size_t size = 0;
  KRPC_CALLBACK_RETURN_ON_ERROR(krpc_encode_size_string(&size, *value));
  if (!pb_encode_varint(stream, size))
    KRPC_CALLBACK_RETURN_ERROR("encoding size for dictionary entry value");
  KRPC_CALLBACK_RETURN_ON_ERROR(krpc_encode_string(stream, *value));
  return true;
}

static bool krpc_encode_callback_entry_dictionary_string_string(
  pb_ostream_t * stream, const pb_field_t * field, void * const * arg) {
  const krpc_dictionary_string_string_t * value = (const krpc_dictionary_string_string_t*)(*arg);
  krpc_schema_DictionaryEntry entry = krpc_schema_DictionaryEntry_init_default;
  entry.key.funcs.encode = &krpc_encode_callback_key_dictionary_string_string;
  entry.value.funcs.encode = &krpc_encode_callback_value_dictionary_string_string;
  size_t i = 0;
  for (; i < value->size; i++) {
    entry.key.arg = &value->entries[i].key;
    entry.value.arg = &value->entries[i].value;
    if (!pb_encode_tag_for_field(stream, field))
      KRPC_CALLBACK_RETURN_ERROR("encoding tag for dictionary entry");
    size_t size;
    KRPC_CALLBACK_RETURN_ON_ERROR(krpc_encode_size_message_DictionaryEntry(&size, &entry));
    if (!pb_encode_varint(stream, size))
      KRPC_CALLBACK_RETURN_ERROR("encoding size for dictionary item");
    KRPC_CALLBACK_RETURN_ON_ERROR(krpc_encode_message_DictionaryEntry(stream, &entry));
  }
  return true;
}

inline krpc_error_t krpc_encode_dictionary_string_string(
  pb_ostream_t * stream, const krpc_dictionary_string_string_t * value) {
  krpc_schema_Dictionary message = krpc_schema_Dictionary_init_default;
  message.entries.funcs.encode = &krpc_encode_callback_entry_dictionary_string_string;
  message.entries.arg = (krpc_dictionary_string_string_t*)value;
  KRPC_RETURN_ON_ERROR(krpc_encode_message_Dictionary(stream, &message));
  return KRPC_OK;
}

inline krpc_error_t krpc_encode_size_dictionary_string_string(
  size_t * size, const krpc_dictionary_string_string_t * value) {
  pb_ostream_t stream = PB_OSTREAM_SIZING;
  KRPC_RETURN_ON_ERROR(krpc_encode_dictionary_string_string(&stream, value));
  *size = stream.bytes_written;
  return KRPC_OK;
}

inline bool krpc_encode_callback_dictionary_string_string(
  pb_ostream_t * stream, const pb_field_t * field, void * const * arg) {
  if (!pb_encode_tag_for_field(stream, field))
    KRPC_CALLBACK_RETURN_ERROR("encoding tag for dictionary_string_string");
  krpc_dictionary_string_string_t * value = (krpc_dictionary_string_string_t*)(*arg);
  size_t size;
  KRPC_CALLBACK_RETURN_ON_ERROR(krpc_encode_size_dictionary_string_string(&size, value));
  if (!pb_encode_varint(stream, size))
    KRPC_CALLBACK_RETURN_ERROR("encoding size for dictionary_string_string");
  KRPC_CALLBACK_RETURN_ON_ERROR(krpc_encode_dictionary_string_string(stream, value));
  return true;
}

static bool krpc_decode_callback_key_dictionary_string_string(
  pb_istream_t * stream, const pb_field_t * field, void ** arg) {
  char * * key = (char **)(*arg);
  KRPC_CALLBACK_RETURN_ON_ERROR(krpc_decode_string(stream, key));
  return true;
}

static bool krpc_decode_callback_value_dictionary_string_string(
  pb_istream_t * stream, const pb_field_t * field, void ** arg) {
  char * * value = (char **)(*arg);
  KRPC_CALLBACK_RETURN_ON_ERROR(krpc_decode_string(stream, value));
  return true;
}

static bool krpc_decode_callback_entry_dictionary_string_string(
  pb_istream_t * stream, const pb_field_t * field, void ** arg) {
  typedef struct { size_t capacity; krpc_dictionary_string_string_t * value; } State;
  State * state = (State*)(*arg);
  krpc_dictionary_string_string_t * value = state->value;
  size_t i = value->size;
  value->size++;
  if (state->capacity > 0 && state->value->size > state->capacity) {
    state->value->entries = (krpc_dictionary_entry_string_string_t*)krpc_recalloc(state->value->entries, state->capacity, KRPC_ALLOC_BLOCK_SIZE, sizeof(krpc_dictionary_entry_string_string_t));
    state->capacity += KRPC_ALLOC_BLOCK_SIZE;
  }
  krpc_schema_DictionaryEntry message = krpc_schema_DictionaryEntry_init_default;
  message.key.funcs.decode = &krpc_decode_callback_key_dictionary_string_string;
  message.key.arg = &value->entries[i].key;
  message.value.funcs.decode = &krpc_decode_callback_value_dictionary_string_string;
  message.value.arg = &value->entries[i].value;
  KRPC_CALLBACK_RETURN_ON_ERROR(krpc_decode_message_DictionaryEntry(stream, &message));
  return true;
}

inline krpc_error_t krpc_decode_dictionary_string_string(
  pb_istream_t * stream, krpc_dictionary_string_string_t * value) {
  typedef struct { size_t capacity; krpc_dictionary_string_string_t * value; } State;
  State state = { 0, value };
  value->size = 0;
  if (value->entries == NULL) {
    value->entries = (krpc_dictionary_entry_string_string_t*)krpc_calloc(KRPC_ALLOC_BLOCK_SIZE, sizeof(krpc_dictionary_entry_string_string_t));
    state.capacity = KRPC_ALLOC_BLOCK_SIZE;
  }
  krpc_schema_Dictionary message = krpc_schema_Dictionary_init_default;
  message.entries.funcs.decode = &krpc_decode_callback_entry_dictionary_string_string;
  message.entries.arg = &state;
  KRPC_RETURN_ON_ERROR(krpc_decode_message_Dictionary(stream, &message));
  return KRPC_OK;
}

#endif  // KRPC_IMPL_TYPE_DICTIONARY_STRING_STRING

#ifndef KRPC_IMPL_TYPE_LIST_OBJECT
#define KRPC_IMPL_TYPE_LIST_OBJECT

static bool krpc_encode_callback_items_list_object(
  pb_ostream_t * stream, const pb_field_t * field, void * const * arg) {
  const krpc_list_object_t * value = (const krpc_list_object_t*)(*arg);
  size_t i = 0;
  for (; i < value->size; i++) {
    if (!pb_encode_tag_for_field(stream, field))
      KRPC_CALLBACK_RETURN_ERROR("encoding tag for list item");
    size_t size;
    KRPC_CALLBACK_RETURN_ON_ERROR(krpc_encode_size_object(&size, value->items[i]));
    if (!pb_encode_varint(stream, size))
      KRPC_CALLBACK_RETURN_ERROR("encoding size for list item");
    KRPC_CALLBACK_RETURN_ON_ERROR(krpc_encode_object(stream, value->items[i]));
  }
  return true;
}

inline krpc_error_t krpc_encode_list_object(
  pb_ostream_t * stream, const krpc_list_object_t * value) {
  krpc_schema_List message = krpc_schema_List_init_default;
  message.items.funcs.encode = &krpc_encode_callback_items_list_object;
  message.items.arg = (krpc_list_object_t*)value;
  KRPC_RETURN_ON_ERROR(krpc_encode_message_List(stream, &message));
  return KRPC_OK;
}

inline krpc_error_t krpc_encode_size_list_object(
  size_t * size, const krpc_list_object_t * value) {
  pb_ostream_t stream = PB_OSTREAM_SIZING;
  KRPC_RETURN_ON_ERROR(krpc_encode_list_object(&stream, value));
  *size = stream.bytes_written;
  return KRPC_OK;
}

inline bool krpc_encode_callback_list_object(
  pb_ostream_t * stream, const pb_field_t * field, void * const * arg) {
  if (!pb_encode_tag_for_field(stream, field))
    KRPC_CALLBACK_RETURN_ERROR("encoding tag for list_object");
  krpc_list_object_t * value = (krpc_list_object_t*)(*arg);
  size_t size;
  KRPC_CALLBACK_RETURN_ON_ERROR(krpc_encode_size_list_object(&size, value));
  if (!pb_encode_varint(stream, size))
    KRPC_CALLBACK_RETURN_ERROR("encoding size for list_object");
  KRPC_CALLBACK_RETURN_ON_ERROR(krpc_encode_list_object(stream, value));
  return true;
}

static bool krpc_decode_callback_item_list_object(
  pb_istream_t * stream, const pb_field_t * field, void ** arg) {
  typedef struct { size_t capacity; krpc_list_object_t * value; } State;
  State * state = (State*)(*arg);
  size_t i = state->value->size;
  state->value->size++;
  if (state->capacity > 0 && state->value->size > state->capacity) {
    state->value->items = (krpc_SpaceCenter_Node_t*)krpc_recalloc(state->value->items, state->capacity, KRPC_ALLOC_BLOCK_SIZE, sizeof(krpc_SpaceCenter_Node_t));
    state->capacity += KRPC_ALLOC_BLOCK_SIZE;
  }
  KRPC_CALLBACK_RETURN_ON_ERROR(krpc_decode_object(stream, &state->value->items[i]));
  return true;
}

inline krpc_error_t krpc_decode_list_object(
  pb_istream_t * stream, krpc_list_object_t * value) {
  typedef struct { size_t capacity; krpc_list_object_t * value; } State;
  State state = { 0, value };
  value->size = 0;
  if (value->items == NULL) {
    value->items = (krpc_SpaceCenter_Node_t*)krpc_calloc(KRPC_ALLOC_BLOCK_SIZE, sizeof(krpc_SpaceCenter_Node_t));
    state.capacity = KRPC_ALLOC_BLOCK_SIZE;
  }
  krpc_schema_List message = krpc_schema_List_init_default;
  message.items.funcs.decode = &krpc_decode_callback_item_list_object;
  message.items.arg = &state;
  KRPC_RETURN_ON_ERROR(krpc_decode_message_List(stream, &message));
  return KRPC_OK;
}

#endif  // KRPC_IMPL_TYPE_LIST_OBJECT

#ifndef KRPC_IMPL_TYPE_LIST_OBJECT
#define KRPC_IMPL_TYPE_LIST_OBJECT

static bool krpc_encode_callback_items_list_object(
  pb_ostream_t * stream, const pb_field_t * field, void * const * arg) {
  const krpc_list_object_t * value = (const krpc_list_object_t*)(*arg);
  size_t i = 0;
  for (; i < value->size; i++) {
    if (!pb_encode_tag_for_field(stream, field))
      KRPC_CALLBACK_RETURN_ERROR("encoding tag for list item");
    size_t size;
    KRPC_CALLBACK_RETURN_ON_ERROR(krpc_encode_size_object(&size, value->items[i]));
    if (!pb_encode_varint(stream, size))
      KRPC_CALLBACK_RETURN_ERROR("encoding size for list item");
    KRPC_CALLBACK_RETURN_ON_ERROR(krpc_encode_object(stream, value->items[i]));
  }
  return true;
}

inline krpc_error_t krpc_encode_list_object(
  pb_ostream_t * stream, const krpc_list_object_t * value) {
  krpc_schema_List message = krpc_schema_List_init_default;
  message.items.funcs.encode = &krpc_encode_callback_items_list_object;
  message.items.arg = (krpc_list_object_t*)value;
  KRPC_RETURN_ON_ERROR(krpc_encode_message_List(stream, &message));
  return KRPC_OK;
}

inline krpc_error_t krpc_encode_size_list_object(
  size_t * size, const krpc_list_object_t * value) {
  pb_ostream_t stream = PB_OSTREAM_SIZING;
  KRPC_RETURN_ON_ERROR(krpc_encode_list_object(&stream, value));
  *size = stream.bytes_written;
  return KRPC_OK;
}

inline bool krpc_encode_callback_list_object(
  pb_ostream_t * stream, const pb_field_t * field, void * const * arg) {
  if (!pb_encode_tag_for_field(stream, field))
    KRPC_CALLBACK_RETURN_ERROR("encoding tag for list_object");
  krpc_list_object_t * value = (krpc_list_object_t*)(*arg);
  size_t size;
  KRPC_CALLBACK_RETURN_ON_ERROR(krpc_encode_size_list_object(&size, value));
  if (!pb_encode_varint(stream, size))
    KRPC_CALLBACK_RETURN_ERROR("encoding size for list_object");
  KRPC_CALLBACK_RETURN_ON_ERROR(krpc_encode_list_object(stream, value));
  return true;
}

static bool krpc_decode_callback_item_list_object(
  pb_istream_t * stream, const pb_field_t * field, void ** arg) {
  typedef struct { size_t capacity; krpc_list_object_t * value; } State;
  State * state = (State*)(*arg);
  size_t i = state->value->size;
  state->value->size++;
  if (state->capacity > 0 && state->value->size > state->capacity) {
    state->value->items = (krpc_SpaceCenter_ReactionWheel_t*)krpc_recalloc(state->value->items, state->capacity, KRPC_ALLOC_BLOCK_SIZE, sizeof(krpc_SpaceCenter_ReactionWheel_t));
    state->capacity += KRPC_ALLOC_BLOCK_SIZE;
  }
  KRPC_CALLBACK_RETURN_ON_ERROR(krpc_decode_object(stream, &state->value->items[i]));
  return true;
}

inline krpc_error_t krpc_decode_list_object(
  pb_istream_t * stream, krpc_list_object_t * value) {
  typedef struct { size_t capacity; krpc_list_object_t * value; } State;
  State state = { 0, value };
  value->size = 0;
  if (value->items == NULL) {
    value->items = (krpc_SpaceCenter_ReactionWheel_t*)krpc_calloc(KRPC_ALLOC_BLOCK_SIZE, sizeof(krpc_SpaceCenter_ReactionWheel_t));
    state.capacity = KRPC_ALLOC_BLOCK_SIZE;
  }
  krpc_schema_List message = krpc_schema_List_init_default;
  message.items.funcs.decode = &krpc_decode_callback_item_list_object;
  message.items.arg = &state;
  KRPC_RETURN_ON_ERROR(krpc_decode_message_List(stream, &message));
  return KRPC_OK;
}

#endif  // KRPC_IMPL_TYPE_LIST_OBJECT

#ifndef KRPC_IMPL_TYPE_LIST_OBJECT
#define KRPC_IMPL_TYPE_LIST_OBJECT

static bool krpc_encode_callback_items_list_object(
  pb_ostream_t * stream, const pb_field_t * field, void * const * arg) {
  const krpc_list_object_t * value = (const krpc_list_object_t*)(*arg);
  size_t i = 0;
  for (; i < value->size; i++) {
    if (!pb_encode_tag_for_field(stream, field))
      KRPC_CALLBACK_RETURN_ERROR("encoding tag for list item");
    size_t size;
    KRPC_CALLBACK_RETURN_ON_ERROR(krpc_encode_size_object(&size, value->items[i]));
    if (!pb_encode_varint(stream, size))
      KRPC_CALLBACK_RETURN_ERROR("encoding size for list item");
    KRPC_CALLBACK_RETURN_ON_ERROR(krpc_encode_object(stream, value->items[i]));
  }
  return true;
}

inline krpc_error_t krpc_encode_list_object(
  pb_ostream_t * stream, const krpc_list_object_t * value) {
  krpc_schema_List message = krpc_schema_List_init_default;
  message.items.funcs.encode = &krpc_encode_callback_items_list_object;
  message.items.arg = (krpc_list_object_t*)value;
  KRPC_RETURN_ON_ERROR(krpc_encode_message_List(stream, &message));
  return KRPC_OK;
}

inline krpc_error_t krpc_encode_size_list_object(
  size_t * size, const krpc_list_object_t * value) {
  pb_ostream_t stream = PB_OSTREAM_SIZING;
  KRPC_RETURN_ON_ERROR(krpc_encode_list_object(&stream, value));
  *size = stream.bytes_written;
  return KRPC_OK;
}

inline bool krpc_encode_callback_list_object(
  pb_ostream_t * stream, const pb_field_t * field, void * const * arg) {
  if (!pb_encode_tag_for_field(stream, field))
    KRPC_CALLBACK_RETURN_ERROR("encoding tag for list_object");
  krpc_list_object_t * value = (krpc_list_object_t*)(*arg);
  size_t size;
  KRPC_CALLBACK_RETURN_ON_ERROR(krpc_encode_size_list_object(&size, value));
  if (!pb_encode_varint(stream, size))
    KRPC_CALLBACK_RETURN_ERROR("encoding size for list_object");
  KRPC_CALLBACK_RETURN_ON_ERROR(krpc_encode_list_object(stream, value));
  return true;
}

static bool krpc_decode_callback_item_list_object(
  pb_istream_t * stream, const pb_field_t * field, void ** arg) {
  typedef struct { size_t capacity; krpc_list_object_t * value; } State;
  State * state = (State*)(*arg);
  size_t i = state->value->size;
  state->value->size++;
  if (state->capacity > 0 && state->value->size > state->capacity) {
    state->value->items = (krpc_SpaceCenter_Radiator_t*)krpc_recalloc(state->value->items, state->capacity, KRPC_ALLOC_BLOCK_SIZE, sizeof(krpc_SpaceCenter_Radiator_t));
    state->capacity += KRPC_ALLOC_BLOCK_SIZE;
  }
  KRPC_CALLBACK_RETURN_ON_ERROR(krpc_decode_object(stream, &state->value->items[i]));
  return true;
}

inline krpc_error_t krpc_decode_list_object(
  pb_istream_t * stream, krpc_list_object_t * value) {
  typedef struct { size_t capacity; krpc_list_object_t * value; } State;
  State state = { 0, value };
  value->size = 0;
  if (value->items == NULL) {
    value->items = (krpc_SpaceCenter_Radiator_t*)krpc_calloc(KRPC_ALLOC_BLOCK_SIZE, sizeof(krpc_SpaceCenter_Radiator_t));
    state.capacity = KRPC_ALLOC_BLOCK_SIZE;
  }
  krpc_schema_List message = krpc_schema_List_init_default;
  message.items.funcs.decode = &krpc_decode_callback_item_list_object;
  message.items.arg = &state;
  KRPC_RETURN_ON_ERROR(krpc_decode_message_List(stream, &message));
  return KRPC_OK;
}

#endif  // KRPC_IMPL_TYPE_LIST_OBJECT

#ifndef KRPC_IMPL_TYPE_LIST_LIST_DOUBLE
#define KRPC_IMPL_TYPE_LIST_LIST_DOUBLE

static bool krpc_encode_callback_items_list_list_double(
  pb_ostream_t * stream, const pb_field_t * field, void * const * arg) {
  const krpc_list_list_double_t * value = (const krpc_list_list_double_t*)(*arg);
  size_t i = 0;
  for (; i < value->size; i++) {
    if (!pb_encode_tag_for_field(stream, field))
      KRPC_CALLBACK_RETURN_ERROR("encoding tag for list item");
    size_t size;
    KRPC_CALLBACK_RETURN_ON_ERROR(krpc_encode_size_list_double(&size, &value->items[i]));
    if (!pb_encode_varint(stream, size))
      KRPC_CALLBACK_RETURN_ERROR("encoding size for list item");
    KRPC_CALLBACK_RETURN_ON_ERROR(krpc_encode_list_double(stream, &value->items[i]));
  }
  return true;
}

inline krpc_error_t krpc_encode_list_list_double(
  pb_ostream_t * stream, const krpc_list_list_double_t * value) {
  krpc_schema_List message = krpc_schema_List_init_default;
  message.items.funcs.encode = &krpc_encode_callback_items_list_list_double;
  message.items.arg = (krpc_list_list_double_t*)value;
  KRPC_RETURN_ON_ERROR(krpc_encode_message_List(stream, &message));
  return KRPC_OK;
}

inline krpc_error_t krpc_encode_size_list_list_double(
  size_t * size, const krpc_list_list_double_t * value) {
  pb_ostream_t stream = PB_OSTREAM_SIZING;
  KRPC_RETURN_ON_ERROR(krpc_encode_list_list_double(&stream, value));
  *size = stream.bytes_written;
  return KRPC_OK;
}

inline bool krpc_encode_callback_list_list_double(
  pb_ostream_t * stream, const pb_field_t * field, void * const * arg) {
  if (!pb_encode_tag_for_field(stream, field))
    KRPC_CALLBACK_RETURN_ERROR("encoding tag for list_list_double");
  krpc_list_list_double_t * value = (krpc_list_list_double_t*)(*arg);
  size_t size;
  KRPC_CALLBACK_RETURN_ON_ERROR(krpc_encode_size_list_list_double(&size, value));
  if (!pb_encode_varint(stream, size))
    KRPC_CALLBACK_RETURN_ERROR("encoding size for list_list_double");
  KRPC_CALLBACK_RETURN_ON_ERROR(krpc_encode_list_list_double(stream, value));
  return true;
}

static bool krpc_decode_callback_item_list_list_double(
  pb_istream_t * stream, const pb_field_t * field, void ** arg) {
  typedef struct { size_t capacity; krpc_list_list_double_t * value; } State;
  State * state = (State*)(*arg);
  size_t i = state->value->size;
  state->value->size++;
  if (state->capacity > 0 && state->value->size > state->capacity) {
    state->value->items = (krpc_list_double_t*)krpc_recalloc(state->value->items, state->capacity, KRPC_ALLOC_BLOCK_SIZE, sizeof(krpc_list_double_t));
    state->capacity += KRPC_ALLOC_BLOCK_SIZE;
  }
  KRPC_CALLBACK_RETURN_ON_ERROR(krpc_decode_list_double(stream, &state->value->items[i]));
  return true;
}

inline krpc_error_t krpc_decode_list_list_double(
  pb_istream_t * stream, krpc_list_list_double_t * value) {
  typedef struct { size_t capacity; krpc_list_list_double_t * value; } State;
  State state = { 0, value };
  value->size = 0;
  if (value->items == NULL) {
    value->items = (krpc_list_double_t*)krpc_calloc(KRPC_ALLOC_BLOCK_SIZE, sizeof(krpc_list_double_t));
    state.capacity = KRPC_ALLOC_BLOCK_SIZE;
  }
  krpc_schema_List message = krpc_schema_List_init_default;
  message.items.funcs.decode = &krpc_decode_callback_item_list_list_double;
  message.items.arg = &state;
  KRPC_RETURN_ON_ERROR(krpc_decode_message_List(stream, &message));
  return KRPC_OK;
}

#endif  // KRPC_IMPL_TYPE_LIST_LIST_DOUBLE

#ifndef KRPC_IMPL_TYPE_DICTIONARY_STRING_OBJECT
#define KRPC_IMPL_TYPE_DICTIONARY_STRING_OBJECT

static bool krpc_encode_callback_key_dictionary_string_object(
  pb_ostream_t * stream, const pb_field_t * field, void * const * arg) {
  if (!pb_encode_tag_for_field(stream, field))
    KRPC_CALLBACK_RETURN_ERROR("encoding tag for dictionary entry key");
  const char * * key = (const char **)(*arg);
  size_t size = 0;
  KRPC_CALLBACK_RETURN_ON_ERROR(krpc_encode_size_string(&size, *key));
  if (!pb_encode_varint(stream, size))
    KRPC_CALLBACK_RETURN_ERROR("encoding size for dictionary entry key");
  KRPC_CALLBACK_RETURN_ON_ERROR(krpc_encode_string(stream, *key));
  return true;
}

static bool krpc_encode_callback_value_dictionary_string_object(
  pb_ostream_t * stream, const pb_field_t * field, void * const * arg) {
  if (!pb_encode_tag_for_field(stream, field))
    KRPC_CALLBACK_RETURN_ERROR("encoding tag for dictionary entry value");
  const krpc_SpaceCenter_CelestialBody_t * value = (const krpc_SpaceCenter_CelestialBody_t*)(*arg);
  size_t size = 0;
  KRPC_CALLBACK_RETURN_ON_ERROR(krpc_encode_size_object(&size, *value));
  if (!pb_encode_varint(stream, size))
    KRPC_CALLBACK_RETURN_ERROR("encoding size for dictionary entry value");
  KRPC_CALLBACK_RETURN_ON_ERROR(krpc_encode_object(stream, *value));
  return true;
}

static bool krpc_encode_callback_entry_dictionary_string_object(
  pb_ostream_t * stream, const pb_field_t * field, void * const * arg) {
  const krpc_dictionary_string_object_t * value = (const krpc_dictionary_string_object_t*)(*arg);
  krpc_schema_DictionaryEntry entry = krpc_schema_DictionaryEntry_init_default;
  entry.key.funcs.encode = &krpc_encode_callback_key_dictionary_string_object;
  entry.value.funcs.encode = &krpc_encode_callback_value_dictionary_string_object;
  size_t i = 0;
  for (; i < value->size; i++) {
    entry.key.arg = &value->entries[i].key;
    entry.value.arg = &value->entries[i].value;
    if (!pb_encode_tag_for_field(stream, field))
      KRPC_CALLBACK_RETURN_ERROR("encoding tag for dictionary entry");
    size_t size;
    KRPC_CALLBACK_RETURN_ON_ERROR(krpc_encode_size_message_DictionaryEntry(&size, &entry));
    if (!pb_encode_varint(stream, size))
      KRPC_CALLBACK_RETURN_ERROR("encoding size for dictionary item");
    KRPC_CALLBACK_RETURN_ON_ERROR(krpc_encode_message_DictionaryEntry(stream, &entry));
  }
  return true;
}

inline krpc_error_t krpc_encode_dictionary_string_object(
  pb_ostream_t * stream, const krpc_dictionary_string_object_t * value) {
  krpc_schema_Dictionary message = krpc_schema_Dictionary_init_default;
  message.entries.funcs.encode = &krpc_encode_callback_entry_dictionary_string_object;
  message.entries.arg = (krpc_dictionary_string_object_t*)value;
  KRPC_RETURN_ON_ERROR(krpc_encode_message_Dictionary(stream, &message));
  return KRPC_OK;
}

inline krpc_error_t krpc_encode_size_dictionary_string_object(
  size_t * size, const krpc_dictionary_string_object_t * value) {
  pb_ostream_t stream = PB_OSTREAM_SIZING;
  KRPC_RETURN_ON_ERROR(krpc_encode_dictionary_string_object(&stream, value));
  *size = stream.bytes_written;
  return KRPC_OK;
}

inline bool krpc_encode_callback_dictionary_string_object(
  pb_ostream_t * stream, const pb_field_t * field, void * const * arg) {
  if (!pb_encode_tag_for_field(stream, field))
    KRPC_CALLBACK_RETURN_ERROR("encoding tag for dictionary_string_object");
  krpc_dictionary_string_object_t * value = (krpc_dictionary_string_object_t*)(*arg);
  size_t size;
  KRPC_CALLBACK_RETURN_ON_ERROR(krpc_encode_size_dictionary_string_object(&size, value));
  if (!pb_encode_varint(stream, size))
    KRPC_CALLBACK_RETURN_ERROR("encoding size for dictionary_string_object");
  KRPC_CALLBACK_RETURN_ON_ERROR(krpc_encode_dictionary_string_object(stream, value));
  return true;
}

static bool krpc_decode_callback_key_dictionary_string_object(
  pb_istream_t * stream, const pb_field_t * field, void ** arg) {
  char * * key = (char **)(*arg);
  KRPC_CALLBACK_RETURN_ON_ERROR(krpc_decode_string(stream, key));
  return true;
}

static bool krpc_decode_callback_value_dictionary_string_object(
  pb_istream_t * stream, const pb_field_t * field, void ** arg) {
  krpc_SpaceCenter_CelestialBody_t * value = (krpc_SpaceCenter_CelestialBody_t*)(*arg);
  KRPC_CALLBACK_RETURN_ON_ERROR(krpc_decode_object(stream, value));
  return true;
}

static bool krpc_decode_callback_entry_dictionary_string_object(
  pb_istream_t * stream, const pb_field_t * field, void ** arg) {
  typedef struct { size_t capacity; krpc_dictionary_string_object_t * value; } State;
  State * state = (State*)(*arg);
  krpc_dictionary_string_object_t * value = state->value;
  size_t i = value->size;
  value->size++;
  if (state->capacity > 0 && state->value->size > state->capacity) {
    state->value->entries = (krpc_dictionary_entry_string_object_t*)krpc_recalloc(state->value->entries, state->capacity, KRPC_ALLOC_BLOCK_SIZE, sizeof(krpc_dictionary_entry_string_object_t));
    state->capacity += KRPC_ALLOC_BLOCK_SIZE;
  }
  krpc_schema_DictionaryEntry message = krpc_schema_DictionaryEntry_init_default;
  message.key.funcs.decode = &krpc_decode_callback_key_dictionary_string_object;
  message.key.arg = &value->entries[i].key;
  message.value.funcs.decode = &krpc_decode_callback_value_dictionary_string_object;
  message.value.arg = &value->entries[i].value;
  KRPC_CALLBACK_RETURN_ON_ERROR(krpc_decode_message_DictionaryEntry(stream, &message));
  return true;
}

inline krpc_error_t krpc_decode_dictionary_string_object(
  pb_istream_t * stream, krpc_dictionary_string_object_t * value) {
  typedef struct { size_t capacity; krpc_dictionary_string_object_t * value; } State;
  State state = { 0, value };
  value->size = 0;
  if (value->entries == NULL) {
    value->entries = (krpc_dictionary_entry_string_object_t*)krpc_calloc(KRPC_ALLOC_BLOCK_SIZE, sizeof(krpc_dictionary_entry_string_object_t));
    state.capacity = KRPC_ALLOC_BLOCK_SIZE;
  }
  krpc_schema_Dictionary message = krpc_schema_Dictionary_init_default;
  message.entries.funcs.decode = &krpc_decode_callback_entry_dictionary_string_object;
  message.entries.arg = &state;
  KRPC_RETURN_ON_ERROR(krpc_decode_message_Dictionary(stream, &message));
  return KRPC_OK;
}

#endif  // KRPC_IMPL_TYPE_DICTIONARY_STRING_OBJECT

#ifndef KRPC_IMPL_TYPE_LIST_OBJECT
#define KRPC_IMPL_TYPE_LIST_OBJECT

static bool krpc_encode_callback_items_list_object(
  pb_ostream_t * stream, const pb_field_t * field, void * const * arg) {
  const krpc_list_object_t * value = (const krpc_list_object_t*)(*arg);
  size_t i = 0;
  for (; i < value->size; i++) {
    if (!pb_encode_tag_for_field(stream, field))
      KRPC_CALLBACK_RETURN_ERROR("encoding tag for list item");
    size_t size;
    KRPC_CALLBACK_RETURN_ON_ERROR(krpc_encode_size_object(&size, value->items[i]));
    if (!pb_encode_varint(stream, size))
      KRPC_CALLBACK_RETURN_ERROR("encoding size for list item");
    KRPC_CALLBACK_RETURN_ON_ERROR(krpc_encode_object(stream, value->items[i]));
  }
  return true;
}

inline krpc_error_t krpc_encode_list_object(
  pb_ostream_t * stream, const krpc_list_object_t * value) {
  krpc_schema_List message = krpc_schema_List_init_default;
  message.items.funcs.encode = &krpc_encode_callback_items_list_object;
  message.items.arg = (krpc_list_object_t*)value;
  KRPC_RETURN_ON_ERROR(krpc_encode_message_List(stream, &message));
  return KRPC_OK;
}

inline krpc_error_t krpc_encode_size_list_object(
  size_t * size, const krpc_list_object_t * value) {
  pb_ostream_t stream = PB_OSTREAM_SIZING;
  KRPC_RETURN_ON_ERROR(krpc_encode_list_object(&stream, value));
  *size = stream.bytes_written;
  return KRPC_OK;
}

inline bool krpc_encode_callback_list_object(
  pb_ostream_t * stream, const pb_field_t * field, void * const * arg) {
  if (!pb_encode_tag_for_field(stream, field))
    KRPC_CALLBACK_RETURN_ERROR("encoding tag for list_object");
  krpc_list_object_t * value = (krpc_list_object_t*)(*arg);
  size_t size;
  KRPC_CALLBACK_RETURN_ON_ERROR(krpc_encode_size_list_object(&size, value));
  if (!pb_encode_varint(stream, size))
    KRPC_CALLBACK_RETURN_ERROR("encoding size for list_object");
  KRPC_CALLBACK_RETURN_ON_ERROR(krpc_encode_list_object(stream, value));
  return true;
}

static bool krpc_decode_callback_item_list_object(
  pb_istream_t * stream, const pb_field_t * field, void ** arg) {
  typedef struct { size_t capacity; krpc_list_object_t * value; } State;
  State * state = (State*)(*arg);
  size_t i = state->value->size;
  state->value->size++;
  if (state->capacity > 0 && state->value->size > state->capacity) {
    state->value->items = (krpc_SpaceCenter_Thruster_t*)krpc_recalloc(state->value->items, state->capacity, KRPC_ALLOC_BLOCK_SIZE, sizeof(krpc_SpaceCenter_Thruster_t));
    state->capacity += KRPC_ALLOC_BLOCK_SIZE;
  }
  KRPC_CALLBACK_RETURN_ON_ERROR(krpc_decode_object(stream, &state->value->items[i]));
  return true;
}

inline krpc_error_t krpc_decode_list_object(
  pb_istream_t * stream, krpc_list_object_t * value) {
  typedef struct { size_t capacity; krpc_list_object_t * value; } State;
  State state = { 0, value };
  value->size = 0;
  if (value->items == NULL) {
    value->items = (krpc_SpaceCenter_Thruster_t*)krpc_calloc(KRPC_ALLOC_BLOCK_SIZE, sizeof(krpc_SpaceCenter_Thruster_t));
    state.capacity = KRPC_ALLOC_BLOCK_SIZE;
  }
  krpc_schema_List message = krpc_schema_List_init_default;
  message.items.funcs.decode = &krpc_decode_callback_item_list_object;
  message.items.arg = &state;
  KRPC_RETURN_ON_ERROR(krpc_decode_message_List(stream, &message));
  return KRPC_OK;
}

#endif  // KRPC_IMPL_TYPE_LIST_OBJECT

#ifndef KRPC_IMPL_TYPE_LIST_OBJECT
#define KRPC_IMPL_TYPE_LIST_OBJECT

static bool krpc_encode_callback_items_list_object(
  pb_ostream_t * stream, const pb_field_t * field, void * const * arg) {
  const krpc_list_object_t * value = (const krpc_list_object_t*)(*arg);
  size_t i = 0;
  for (; i < value->size; i++) {
    if (!pb_encode_tag_for_field(stream, field))
      KRPC_CALLBACK_RETURN_ERROR("encoding tag for list item");
    size_t size;
    KRPC_CALLBACK_RETURN_ON_ERROR(krpc_encode_size_object(&size, value->items[i]));
    if (!pb_encode_varint(stream, size))
      KRPC_CALLBACK_RETURN_ERROR("encoding size for list item");
    KRPC_CALLBACK_RETURN_ON_ERROR(krpc_encode_object(stream, value->items[i]));
  }
  return true;
}

inline krpc_error_t krpc_encode_list_object(
  pb_ostream_t * stream, const krpc_list_object_t * value) {
  krpc_schema_List message = krpc_schema_List_init_default;
  message.items.funcs.encode = &krpc_encode_callback_items_list_object;
  message.items.arg = (krpc_list_object_t*)value;
  KRPC_RETURN_ON_ERROR(krpc_encode_message_List(stream, &message));
  return KRPC_OK;
}

inline krpc_error_t krpc_encode_size_list_object(
  size_t * size, const krpc_list_object_t * value) {
  pb_ostream_t stream = PB_OSTREAM_SIZING;
  KRPC_RETURN_ON_ERROR(krpc_encode_list_object(&stream, value));
  *size = stream.bytes_written;
  return KRPC_OK;
}

inline bool krpc_encode_callback_list_object(
  pb_ostream_t * stream, const pb_field_t * field, void * const * arg) {
  if (!pb_encode_tag_for_field(stream, field))
    KRPC_CALLBACK_RETURN_ERROR("encoding tag for list_object");
  krpc_list_object_t * value = (krpc_list_object_t*)(*arg);
  size_t size;
  KRPC_CALLBACK_RETURN_ON_ERROR(krpc_encode_size_list_object(&size, value));
  if (!pb_encode_varint(stream, size))
    KRPC_CALLBACK_RETURN_ERROR("encoding size for list_object");
  KRPC_CALLBACK_RETURN_ON_ERROR(krpc_encode_list_object(stream, value));
  return true;
}

static bool krpc_decode_callback_item_list_object(
  pb_istream_t * stream, const pb_field_t * field, void ** arg) {
  typedef struct { size_t capacity; krpc_list_object_t * value; } State;
  State * state = (State*)(*arg);
  size_t i = state->value->size;
  state->value->size++;
  if (state->capacity > 0 && state->value->size > state->capacity) {
    state->value->items = (krpc_SpaceCenter_Engine_t*)krpc_recalloc(state->value->items, state->capacity, KRPC_ALLOC_BLOCK_SIZE, sizeof(krpc_SpaceCenter_Engine_t));
    state->capacity += KRPC_ALLOC_BLOCK_SIZE;
  }
  KRPC_CALLBACK_RETURN_ON_ERROR(krpc_decode_object(stream, &state->value->items[i]));
  return true;
}

inline krpc_error_t krpc_decode_list_object(
  pb_istream_t * stream, krpc_list_object_t * value) {
  typedef struct { size_t capacity; krpc_list_object_t * value; } State;
  State state = { 0, value };
  value->size = 0;
  if (value->items == NULL) {
    value->items = (krpc_SpaceCenter_Engine_t*)krpc_calloc(KRPC_ALLOC_BLOCK_SIZE, sizeof(krpc_SpaceCenter_Engine_t));
    state.capacity = KRPC_ALLOC_BLOCK_SIZE;
  }
  krpc_schema_List message = krpc_schema_List_init_default;
  message.items.funcs.decode = &krpc_decode_callback_item_list_object;
  message.items.arg = &state;
  KRPC_RETURN_ON_ERROR(krpc_decode_message_List(stream, &message));
  return KRPC_OK;
}

#endif  // KRPC_IMPL_TYPE_LIST_OBJECT

#ifndef KRPC_IMPL_TYPE_DICTIONARY_STRING_OBJECT
#define KRPC_IMPL_TYPE_DICTIONARY_STRING_OBJECT

static bool krpc_encode_callback_key_dictionary_string_object(
  pb_ostream_t * stream, const pb_field_t * field, void * const * arg) {
  if (!pb_encode_tag_for_field(stream, field))
    KRPC_CALLBACK_RETURN_ERROR("encoding tag for dictionary entry key");
  const char * * key = (const char **)(*arg);
  size_t size = 0;
  KRPC_CALLBACK_RETURN_ON_ERROR(krpc_encode_size_string(&size, *key));
  if (!pb_encode_varint(stream, size))
    KRPC_CALLBACK_RETURN_ERROR("encoding size for dictionary entry key");
  KRPC_CALLBACK_RETURN_ON_ERROR(krpc_encode_string(stream, *key));
  return true;
}

static bool krpc_encode_callback_value_dictionary_string_object(
  pb_ostream_t * stream, const pb_field_t * field, void * const * arg) {
  if (!pb_encode_tag_for_field(stream, field))
    KRPC_CALLBACK_RETURN_ERROR("encoding tag for dictionary entry value");
  const krpc_SpaceCenter_Engine_t * value = (const krpc_SpaceCenter_Engine_t*)(*arg);
  size_t size = 0;
  KRPC_CALLBACK_RETURN_ON_ERROR(krpc_encode_size_object(&size, *value));
  if (!pb_encode_varint(stream, size))
    KRPC_CALLBACK_RETURN_ERROR("encoding size for dictionary entry value");
  KRPC_CALLBACK_RETURN_ON_ERROR(krpc_encode_object(stream, *value));
  return true;
}

static bool krpc_encode_callback_entry_dictionary_string_object(
  pb_ostream_t * stream, const pb_field_t * field, void * const * arg) {
  const krpc_dictionary_string_object_t * value = (const krpc_dictionary_string_object_t*)(*arg);
  krpc_schema_DictionaryEntry entry = krpc_schema_DictionaryEntry_init_default;
  entry.key.funcs.encode = &krpc_encode_callback_key_dictionary_string_object;
  entry.value.funcs.encode = &krpc_encode_callback_value_dictionary_string_object;
  size_t i = 0;
  for (; i < value->size; i++) {
    entry.key.arg = &value->entries[i].key;
    entry.value.arg = &value->entries[i].value;
    if (!pb_encode_tag_for_field(stream, field))
      KRPC_CALLBACK_RETURN_ERROR("encoding tag for dictionary entry");
    size_t size;
    KRPC_CALLBACK_RETURN_ON_ERROR(krpc_encode_size_message_DictionaryEntry(&size, &entry));
    if (!pb_encode_varint(stream, size))
      KRPC_CALLBACK_RETURN_ERROR("encoding size for dictionary item");
    KRPC_CALLBACK_RETURN_ON_ERROR(krpc_encode_message_DictionaryEntry(stream, &entry));
  }
  return true;
}

inline krpc_error_t krpc_encode_dictionary_string_object(
  pb_ostream_t * stream, const krpc_dictionary_string_object_t * value) {
  krpc_schema_Dictionary message = krpc_schema_Dictionary_init_default;
  message.entries.funcs.encode = &krpc_encode_callback_entry_dictionary_string_object;
  message.entries.arg = (krpc_dictionary_string_object_t*)value;
  KRPC_RETURN_ON_ERROR(krpc_encode_message_Dictionary(stream, &message));
  return KRPC_OK;
}

inline krpc_error_t krpc_encode_size_dictionary_string_object(
  size_t * size, const krpc_dictionary_string_object_t * value) {
  pb_ostream_t stream = PB_OSTREAM_SIZING;
  KRPC_RETURN_ON_ERROR(krpc_encode_dictionary_string_object(&stream, value));
  *size = stream.bytes_written;
  return KRPC_OK;
}

inline bool krpc_encode_callback_dictionary_string_object(
  pb_ostream_t * stream, const pb_field_t * field, void * const * arg) {
  if (!pb_encode_tag_for_field(stream, field))
    KRPC_CALLBACK_RETURN_ERROR("encoding tag for dictionary_string_object");
  krpc_dictionary_string_object_t * value = (krpc_dictionary_string_object_t*)(*arg);
  size_t size;
  KRPC_CALLBACK_RETURN_ON_ERROR(krpc_encode_size_dictionary_string_object(&size, value));
  if (!pb_encode_varint(stream, size))
    KRPC_CALLBACK_RETURN_ERROR("encoding size for dictionary_string_object");
  KRPC_CALLBACK_RETURN_ON_ERROR(krpc_encode_dictionary_string_object(stream, value));
  return true;
}

static bool krpc_decode_callback_key_dictionary_string_object(
  pb_istream_t * stream, const pb_field_t * field, void ** arg) {
  char * * key = (char **)(*arg);
  KRPC_CALLBACK_RETURN_ON_ERROR(krpc_decode_string(stream, key));
  return true;
}

static bool krpc_decode_callback_value_dictionary_string_object(
  pb_istream_t * stream, const pb_field_t * field, void ** arg) {
  krpc_SpaceCenter_Engine_t * value = (krpc_SpaceCenter_Engine_t*)(*arg);
  KRPC_CALLBACK_RETURN_ON_ERROR(krpc_decode_object(stream, value));
  return true;
}

static bool krpc_decode_callback_entry_dictionary_string_object(
  pb_istream_t * stream, const pb_field_t * field, void ** arg) {
  typedef struct { size_t capacity; krpc_dictionary_string_object_t * value; } State;
  State * state = (State*)(*arg);
  krpc_dictionary_string_object_t * value = state->value;
  size_t i = value->size;
  value->size++;
  if (state->capacity > 0 && state->value->size > state->capacity) {
    state->value->entries = (krpc_dictionary_entry_string_object_t*)krpc_recalloc(state->value->entries, state->capacity, KRPC_ALLOC_BLOCK_SIZE, sizeof(krpc_dictionary_entry_string_object_t));
    state->capacity += KRPC_ALLOC_BLOCK_SIZE;
  }
  krpc_schema_DictionaryEntry message = krpc_schema_DictionaryEntry_init_default;
  message.key.funcs.decode = &krpc_decode_callback_key_dictionary_string_object;
  message.key.arg = &value->entries[i].key;
  message.value.funcs.decode = &krpc_decode_callback_value_dictionary_string_object;
  message.value.arg = &value->entries[i].value;
  KRPC_CALLBACK_RETURN_ON_ERROR(krpc_decode_message_DictionaryEntry(stream, &message));
  return true;
}

inline krpc_error_t krpc_decode_dictionary_string_object(
  pb_istream_t * stream, krpc_dictionary_string_object_t * value) {
  typedef struct { size_t capacity; krpc_dictionary_string_object_t * value; } State;
  State state = { 0, value };
  value->size = 0;
  if (value->entries == NULL) {
    value->entries = (krpc_dictionary_entry_string_object_t*)krpc_calloc(KRPC_ALLOC_BLOCK_SIZE, sizeof(krpc_dictionary_entry_string_object_t));
    state.capacity = KRPC_ALLOC_BLOCK_SIZE;
  }
  krpc_schema_Dictionary message = krpc_schema_Dictionary_init_default;
  message.entries.funcs.decode = &krpc_decode_callback_entry_dictionary_string_object;
  message.entries.arg = &state;
  KRPC_RETURN_ON_ERROR(krpc_decode_message_Dictionary(stream, &message));
  return KRPC_OK;
}

#endif  // KRPC_IMPL_TYPE_DICTIONARY_STRING_OBJECT

#ifndef KRPC_IMPL_TYPE_LIST_OBJECT
#define KRPC_IMPL_TYPE_LIST_OBJECT

static bool krpc_encode_callback_items_list_object(
  pb_ostream_t * stream, const pb_field_t * field, void * const * arg) {
  const krpc_list_object_t * value = (const krpc_list_object_t*)(*arg);
  size_t i = 0;
  for (; i < value->size; i++) {
    if (!pb_encode_tag_for_field(stream, field))
      KRPC_CALLBACK_RETURN_ERROR("encoding tag for list item");
    size_t size;
    KRPC_CALLBACK_RETURN_ON_ERROR(krpc_encode_size_object(&size, value->items[i]));
    if (!pb_encode_varint(stream, size))
      KRPC_CALLBACK_RETURN_ERROR("encoding size for list item");
    KRPC_CALLBACK_RETURN_ON_ERROR(krpc_encode_object(stream, value->items[i]));
  }
  return true;
}

inline krpc_error_t krpc_encode_list_object(
  pb_ostream_t * stream, const krpc_list_object_t * value) {
  krpc_schema_List message = krpc_schema_List_init_default;
  message.items.funcs.encode = &krpc_encode_callback_items_list_object;
  message.items.arg = (krpc_list_object_t*)value;
  KRPC_RETURN_ON_ERROR(krpc_encode_message_List(stream, &message));
  return KRPC_OK;
}

inline krpc_error_t krpc_encode_size_list_object(
  size_t * size, const krpc_list_object_t * value) {
  pb_ostream_t stream = PB_OSTREAM_SIZING;
  KRPC_RETURN_ON_ERROR(krpc_encode_list_object(&stream, value));
  *size = stream.bytes_written;
  return KRPC_OK;
}

inline bool krpc_encode_callback_list_object(
  pb_ostream_t * stream, const pb_field_t * field, void * const * arg) {
  if (!pb_encode_tag_for_field(stream, field))
    KRPC_CALLBACK_RETURN_ERROR("encoding tag for list_object");
  krpc_list_object_t * value = (krpc_list_object_t*)(*arg);
  size_t size;
  KRPC_CALLBACK_RETURN_ON_ERROR(krpc_encode_size_list_object(&size, value));
  if (!pb_encode_varint(stream, size))
    KRPC_CALLBACK_RETURN_ERROR("encoding size for list_object");
  KRPC_CALLBACK_RETURN_ON_ERROR(krpc_encode_list_object(stream, value));
  return true;
}

static bool krpc_decode_callback_item_list_object(
  pb_istream_t * stream, const pb_field_t * field, void ** arg) {
  typedef struct { size_t capacity; krpc_list_object_t * value; } State;
  State * state = (State*)(*arg);
  size_t i = state->value->size;
  state->value->size++;
  if (state->capacity > 0 && state->value->size > state->capacity) {
    state->value->items = (krpc_SpaceCenter_Fairing_t*)krpc_recalloc(state->value->items, state->capacity, KRPC_ALLOC_BLOCK_SIZE, sizeof(krpc_SpaceCenter_Fairing_t));
    state->capacity += KRPC_ALLOC_BLOCK_SIZE;
  }
  KRPC_CALLBACK_RETURN_ON_ERROR(krpc_decode_object(stream, &state->value->items[i]));
  return true;
}

inline krpc_error_t krpc_decode_list_object(
  pb_istream_t * stream, krpc_list_object_t * value) {
  typedef struct { size_t capacity; krpc_list_object_t * value; } State;
  State state = { 0, value };
  value->size = 0;
  if (value->items == NULL) {
    value->items = (krpc_SpaceCenter_Fairing_t*)krpc_calloc(KRPC_ALLOC_BLOCK_SIZE, sizeof(krpc_SpaceCenter_Fairing_t));
    state.capacity = KRPC_ALLOC_BLOCK_SIZE;
  }
  krpc_schema_List message = krpc_schema_List_init_default;
  message.items.funcs.decode = &krpc_decode_callback_item_list_object;
  message.items.arg = &state;
  KRPC_RETURN_ON_ERROR(krpc_decode_message_List(stream, &message));
  return KRPC_OK;
}

#endif  // KRPC_IMPL_TYPE_LIST_OBJECT

#ifndef KRPC_IMPL_TYPE_DICTIONARY_STRING_INT32
#define KRPC_IMPL_TYPE_DICTIONARY_STRING_INT32

static bool krpc_encode_callback_key_dictionary_string_int32(
  pb_ostream_t * stream, const pb_field_t * field, void * const * arg) {
  if (!pb_encode_tag_for_field(stream, field))
    KRPC_CALLBACK_RETURN_ERROR("encoding tag for dictionary entry key");
  const char * * key = (const char **)(*arg);
  size_t size = 0;
  KRPC_CALLBACK_RETURN_ON_ERROR(krpc_encode_size_string(&size, *key));
  if (!pb_encode_varint(stream, size))
    KRPC_CALLBACK_RETURN_ERROR("encoding size for dictionary entry key");
  KRPC_CALLBACK_RETURN_ON_ERROR(krpc_encode_string(stream, *key));
  return true;
}

static bool krpc_encode_callback_value_dictionary_string_int32(
  pb_ostream_t * stream, const pb_field_t * field, void * const * arg) {
  if (!pb_encode_tag_for_field(stream, field))
    KRPC_CALLBACK_RETURN_ERROR("encoding tag for dictionary entry value");
  const int32_t * value = (const int32_t*)(*arg);
  size_t size = 0;
  KRPC_CALLBACK_RETURN_ON_ERROR(krpc_encode_size_int32(&size, *value));
  if (!pb_encode_varint(stream, size))
    KRPC_CALLBACK_RETURN_ERROR("encoding size for dictionary entry value");
  KRPC_CALLBACK_RETURN_ON_ERROR(krpc_encode_int32(stream, *value));
  return true;
}

static bool krpc_encode_callback_entry_dictionary_string_int32(
  pb_ostream_t * stream, const pb_field_t * field, void * const * arg) {
  const krpc_dictionary_string_int32_t * value = (const krpc_dictionary_string_int32_t*)(*arg);
  krpc_schema_DictionaryEntry entry = krpc_schema_DictionaryEntry_init_default;
  entry.key.funcs.encode = &krpc_encode_callback_key_dictionary_string_int32;
  entry.value.funcs.encode = &krpc_encode_callback_value_dictionary_string_int32;
  size_t i = 0;
  for (; i < value->size; i++) {
    entry.key.arg = &value->entries[i].key;
    entry.value.arg = &value->entries[i].value;
    if (!pb_encode_tag_for_field(stream, field))
      KRPC_CALLBACK_RETURN_ERROR("encoding tag for dictionary entry");
    size_t size;
    KRPC_CALLBACK_RETURN_ON_ERROR(krpc_encode_size_message_DictionaryEntry(&size, &entry));
    if (!pb_encode_varint(stream, size))
      KRPC_CALLBACK_RETURN_ERROR("encoding size for dictionary item");
    KRPC_CALLBACK_RETURN_ON_ERROR(krpc_encode_message_DictionaryEntry(stream, &entry));
  }
  return true;
}

inline krpc_error_t krpc_encode_dictionary_string_int32(
  pb_ostream_t * stream, const krpc_dictionary_string_int32_t * value) {
  krpc_schema_Dictionary message = krpc_schema_Dictionary_init_default;
  message.entries.funcs.encode = &krpc_encode_callback_entry_dictionary_string_int32;
  message.entries.arg = (krpc_dictionary_string_int32_t*)value;
  KRPC_RETURN_ON_ERROR(krpc_encode_message_Dictionary(stream, &message));
  return KRPC_OK;
}

inline krpc_error_t krpc_encode_size_dictionary_string_int32(
  size_t * size, const krpc_dictionary_string_int32_t * value) {
  pb_ostream_t stream = PB_OSTREAM_SIZING;
  KRPC_RETURN_ON_ERROR(krpc_encode_dictionary_string_int32(&stream, value));
  *size = stream.bytes_written;
  return KRPC_OK;
}

inline bool krpc_encode_callback_dictionary_string_int32(
  pb_ostream_t * stream, const pb_field_t * field, void * const * arg) {
  if (!pb_encode_tag_for_field(stream, field))
    KRPC_CALLBACK_RETURN_ERROR("encoding tag for dictionary_string_int32");
  krpc_dictionary_string_int32_t * value = (krpc_dictionary_string_int32_t*)(*arg);
  size_t size;
  KRPC_CALLBACK_RETURN_ON_ERROR(krpc_encode_size_dictionary_string_int32(&size, value));
  if (!pb_encode_varint(stream, size))
    KRPC_CALLBACK_RETURN_ERROR("encoding size for dictionary_string_int32");
  KRPC_CALLBACK_RETURN_ON_ERROR(krpc_encode_dictionary_string_int32(stream, value));
  return true;
}

static bool krpc_decode_callback_key_dictionary_string_int32(
  pb_istream_t * stream, const pb_field_t * field, void ** arg) {
  char * * key = (char **)(*arg);
  KRPC_CALLBACK_RETURN_ON_ERROR(krpc_decode_string(stream, key));
  return true;
}

static bool krpc_decode_callback_value_dictionary_string_int32(
  pb_istream_t * stream, const pb_field_t * field, void ** arg) {
  int32_t * value = (int32_t*)(*arg);
  KRPC_CALLBACK_RETURN_ON_ERROR(krpc_decode_int32(stream, value));
  return true;
}

static bool krpc_decode_callback_entry_dictionary_string_int32(
  pb_istream_t * stream, const pb_field_t * field, void ** arg) {
  typedef struct { size_t capacity; krpc_dictionary_string_int32_t * value; } State;
  State * state = (State*)(*arg);
  krpc_dictionary_string_int32_t * value = state->value;
  size_t i = value->size;
  value->size++;
  if (state->capacity > 0 && state->value->size > state->capacity) {
    state->value->entries = (krpc_dictionary_entry_string_int32_t*)krpc_recalloc(state->value->entries, state->capacity, KRPC_ALLOC_BLOCK_SIZE, sizeof(krpc_dictionary_entry_string_int32_t));
    state->capacity += KRPC_ALLOC_BLOCK_SIZE;
  }
  krpc_schema_DictionaryEntry message = krpc_schema_DictionaryEntry_init_default;
  message.key.funcs.decode = &krpc_decode_callback_key_dictionary_string_int32;
  message.key.arg = &value->entries[i].key;
  message.value.funcs.decode = &krpc_decode_callback_value_dictionary_string_int32;
  message.value.arg = &value->entries[i].value;
  KRPC_CALLBACK_RETURN_ON_ERROR(krpc_decode_message_DictionaryEntry(stream, &message));
  return true;
}

inline krpc_error_t krpc_decode_dictionary_string_int32(
  pb_istream_t * stream, krpc_dictionary_string_int32_t * value) {
  typedef struct { size_t capacity; krpc_dictionary_string_int32_t * value; } State;
  State state = { 0, value };
  value->size = 0;
  if (value->entries == NULL) {
    value->entries = (krpc_dictionary_entry_string_int32_t*)krpc_calloc(KRPC_ALLOC_BLOCK_SIZE, sizeof(krpc_dictionary_entry_string_int32_t));
    state.capacity = KRPC_ALLOC_BLOCK_SIZE;
  }
  krpc_schema_Dictionary message = krpc_schema_Dictionary_init_default;
  message.entries.funcs.decode = &krpc_decode_callback_entry_dictionary_string_int32;
  message.entries.arg = &state;
  KRPC_RETURN_ON_ERROR(krpc_decode_message_Dictionary(stream, &message));
  return KRPC_OK;
}

#endif  // KRPC_IMPL_TYPE_DICTIONARY_STRING_INT32

#ifndef KRPC_IMPL_TYPE_LIST_OBJECT
#define KRPC_IMPL_TYPE_LIST_OBJECT

static bool krpc_encode_callback_items_list_object(
  pb_ostream_t * stream, const pb_field_t * field, void * const * arg) {
  const krpc_list_object_t * value = (const krpc_list_object_t*)(*arg);
  size_t i = 0;
  for (; i < value->size; i++) {
    if (!pb_encode_tag_for_field(stream, field))
      KRPC_CALLBACK_RETURN_ERROR("encoding tag for list item");
    size_t size;
    KRPC_CALLBACK_RETURN_ON_ERROR(krpc_encode_size_object(&size, value->items[i]));
    if (!pb_encode_varint(stream, size))
      KRPC_CALLBACK_RETURN_ERROR("encoding size for list item");
    KRPC_CALLBACK_RETURN_ON_ERROR(krpc_encode_object(stream, value->items[i]));
  }
  return true;
}

inline krpc_error_t krpc_encode_list_object(
  pb_ostream_t * stream, const krpc_list_object_t * value) {
  krpc_schema_List message = krpc_schema_List_init_default;
  message.items.funcs.encode = &krpc_encode_callback_items_list_object;
  message.items.arg = (krpc_list_object_t*)value;
  KRPC_RETURN_ON_ERROR(krpc_encode_message_List(stream, &message));
  return KRPC_OK;
}

inline krpc_error_t krpc_encode_size_list_object(
  size_t * size, const krpc_list_object_t * value) {
  pb_ostream_t stream = PB_OSTREAM_SIZING;
  KRPC_RETURN_ON_ERROR(krpc_encode_list_object(&stream, value));
  *size = stream.bytes_written;
  return KRPC_OK;
}

inline bool krpc_encode_callback_list_object(
  pb_ostream_t * stream, const pb_field_t * field, void * const * arg) {
  if (!pb_encode_tag_for_field(stream, field))
    KRPC_CALLBACK_RETURN_ERROR("encoding tag for list_object");
  krpc_list_object_t * value = (krpc_list_object_t*)(*arg);
  size_t size;
  KRPC_CALLBACK_RETURN_ON_ERROR(krpc_encode_size_list_object(&size, value));
  if (!pb_encode_varint(stream, size))
    KRPC_CALLBACK_RETURN_ERROR("encoding size for list_object");
  KRPC_CALLBACK_RETURN_ON_ERROR(krpc_encode_list_object(stream, value));
  return true;
}

static bool krpc_decode_callback_item_list_object(
  pb_istream_t * stream, const pb_field_t * field, void ** arg) {
  typedef struct { size_t capacity; krpc_list_object_t * value; } State;
  State * state = (State*)(*arg);
  size_t i = state->value->size;
  state->value->size++;
  if (state->capacity > 0 && state->value->size > state->capacity) {
    state->value->items = (krpc_SpaceCenter_Light_t*)krpc_recalloc(state->value->items, state->capacity, KRPC_ALLOC_BLOCK_SIZE, sizeof(krpc_SpaceCenter_Light_t));
    state->capacity += KRPC_ALLOC_BLOCK_SIZE;
  }
  KRPC_CALLBACK_RETURN_ON_ERROR(krpc_decode_object(stream, &state->value->items[i]));
  return true;
}

inline krpc_error_t krpc_decode_list_object(
  pb_istream_t * stream, krpc_list_object_t * value) {
  typedef struct { size_t capacity; krpc_list_object_t * value; } State;
  State state = { 0, value };
  value->size = 0;
  if (value->items == NULL) {
    value->items = (krpc_SpaceCenter_Light_t*)krpc_calloc(KRPC_ALLOC_BLOCK_SIZE, sizeof(krpc_SpaceCenter_Light_t));
    state.capacity = KRPC_ALLOC_BLOCK_SIZE;
  }
  krpc_schema_List message = krpc_schema_List_init_default;
  message.items.funcs.decode = &krpc_decode_callback_item_list_object;
  message.items.arg = &state;
  KRPC_RETURN_ON_ERROR(krpc_decode_message_List(stream, &message));
  return KRPC_OK;
}

#endif  // KRPC_IMPL_TYPE_LIST_OBJECT

#ifndef KRPC_IMPL_TYPE_LIST_OBJECT
#define KRPC_IMPL_TYPE_LIST_OBJECT

static bool krpc_encode_callback_items_list_object(
  pb_ostream_t * stream, const pb_field_t * field, void * const * arg) {
  const krpc_list_object_t * value = (const krpc_list_object_t*)(*arg);
  size_t i = 0;
  for (; i < value->size; i++) {
    if (!pb_encode_tag_for_field(stream, field))
      KRPC_CALLBACK_RETURN_ERROR("encoding tag for list item");
    size_t size;
    KRPC_CALLBACK_RETURN_ON_ERROR(krpc_encode_size_object(&size, value->items[i]));
    if (!pb_encode_varint(stream, size))
      KRPC_CALLBACK_RETURN_ERROR("encoding size for list item");
    KRPC_CALLBACK_RETURN_ON_ERROR(krpc_encode_object(stream, value->items[i]));
  }
  return true;
}

inline krpc_error_t krpc_encode_list_object(
  pb_ostream_t * stream, const krpc_list_object_t * value) {
  krpc_schema_List message = krpc_schema_List_init_default;
  message.items.funcs.encode = &krpc_encode_callback_items_list_object;
  message.items.arg = (krpc_list_object_t*)value;
  KRPC_RETURN_ON_ERROR(krpc_encode_message_List(stream, &message));
  return KRPC_OK;
}

inline krpc_error_t krpc_encode_size_list_object(
  size_t * size, const krpc_list_object_t * value) {
  pb_ostream_t stream = PB_OSTREAM_SIZING;
  KRPC_RETURN_ON_ERROR(krpc_encode_list_object(&stream, value));
  *size = stream.bytes_written;
  return KRPC_OK;
}

inline bool krpc_encode_callback_list_object(
  pb_ostream_t * stream, const pb_field_t * field, void * const * arg) {
  if (!pb_encode_tag_for_field(stream, field))
    KRPC_CALLBACK_RETURN_ERROR("encoding tag for list_object");
  krpc_list_object_t * value = (krpc_list_object_t*)(*arg);
  size_t size;
  KRPC_CALLBACK_RETURN_ON_ERROR(krpc_encode_size_list_object(&size, value));
  if (!pb_encode_varint(stream, size))
    KRPC_CALLBACK_RETURN_ERROR("encoding size for list_object");
  KRPC_CALLBACK_RETURN_ON_ERROR(krpc_encode_list_object(stream, value));
  return true;
}

static bool krpc_decode_callback_item_list_object(
  pb_istream_t * stream, const pb_field_t * field, void ** arg) {
  typedef struct { size_t capacity; krpc_list_object_t * value; } State;
  State * state = (State*)(*arg);
  size_t i = state->value->size;
  state->value->size++;
  if (state->capacity > 0 && state->value->size > state->capacity) {
    state->value->items = (krpc_SpaceCenter_CrewMember_t*)krpc_recalloc(state->value->items, state->capacity, KRPC_ALLOC_BLOCK_SIZE, sizeof(krpc_SpaceCenter_CrewMember_t));
    state->capacity += KRPC_ALLOC_BLOCK_SIZE;
  }
  KRPC_CALLBACK_RETURN_ON_ERROR(krpc_decode_object(stream, &state->value->items[i]));
  return true;
}

inline krpc_error_t krpc_decode_list_object(
  pb_istream_t * stream, krpc_list_object_t * value) {
  typedef struct { size_t capacity; krpc_list_object_t * value; } State;
  State state = { 0, value };
  value->size = 0;
  if (value->items == NULL) {
    value->items = (krpc_SpaceCenter_CrewMember_t*)krpc_calloc(KRPC_ALLOC_BLOCK_SIZE, sizeof(krpc_SpaceCenter_CrewMember_t));
    state.capacity = KRPC_ALLOC_BLOCK_SIZE;
  }
  krpc_schema_List message = krpc_schema_List_init_default;
  message.items.funcs.decode = &krpc_decode_callback_item_list_object;
  message.items.arg = &state;
  KRPC_RETURN_ON_ERROR(krpc_decode_message_List(stream, &message));
  return KRPC_OK;
}

#endif  // KRPC_IMPL_TYPE_LIST_OBJECT

#ifndef KRPC_IMPL_TYPE_SET_STRING
#define KRPC_IMPL_TYPE_SET_STRING

static bool krpc_encode_callback_items_set_string(
  pb_ostream_t * stream, const pb_field_t * field, void * const * arg) {
  const krpc_set_string_t * value = (const krpc_set_string_t*)(*arg);
  size_t i = 0;
  for (; i < value->size; i++) {
    if (!pb_encode_tag_for_field(stream, field))
      KRPC_CALLBACK_RETURN_ERROR("encoding tag for set item");
    size_t size;
    KRPC_CALLBACK_RETURN_ON_ERROR(krpc_encode_size_string(&size, value->items[i]));
    if (!pb_encode_varint(stream, size))
      KRPC_CALLBACK_RETURN_ERROR("encoding size for set item");
    KRPC_CALLBACK_RETURN_ON_ERROR(krpc_encode_string(stream, value->items[i]));
  }
  return true;
}

inline krpc_error_t krpc_encode_set_string(
  pb_ostream_t * stream, const krpc_set_string_t * value) {
  krpc_schema_Set message = krpc_schema_Set_init_default;
  message.items.funcs.encode = &krpc_encode_callback_items_set_string;
  message.items.arg = (krpc_set_string_t*)value;
  KRPC_RETURN_ON_ERROR(krpc_encode_message_Set(stream, &message));
  return KRPC_OK;
}

inline krpc_error_t krpc_encode_size_set_string(
  size_t * size, const krpc_set_string_t * value) {
  pb_ostream_t stream = PB_OSTREAM_SIZING;
  KRPC_RETURN_ON_ERROR(krpc_encode_set_string(&stream, value));
  *size = stream.bytes_written;
  return KRPC_OK;
}

inline bool krpc_encode_callback_set_string(
  pb_ostream_t * stream, const pb_field_t * field, void * const * arg) {
  if (!pb_encode_tag_for_field(stream, field))
    KRPC_CALLBACK_RETURN_ERROR("encoding tag for set_string");
  krpc_set_string_t * value = (krpc_set_string_t*)(*arg);
  size_t size;
  KRPC_CALLBACK_RETURN_ON_ERROR(krpc_encode_size_set_string(&size, value));
  if (!pb_encode_varint(stream, size))
    KRPC_CALLBACK_RETURN_ERROR("encoding size for set_string");
  KRPC_CALLBACK_RETURN_ON_ERROR(krpc_encode_set_string(stream, value));
  return true;
}

static bool krpc_decode_callback_item_set_string(
  pb_istream_t * stream, const pb_field_t * field, void ** arg) {
  typedef struct { size_t capacity; krpc_set_string_t * value; } State;
  State * state = (State*)(*arg);
  size_t i = state->value->size;
  state->value->size++;
  if (state->capacity > 0 && state->value->size > state->capacity) {
    state->value->items = (char **)krpc_recalloc(state->value->items, state->capacity, KRPC_ALLOC_BLOCK_SIZE, sizeof(char *));
    state->capacity += KRPC_ALLOC_BLOCK_SIZE;
  }
  KRPC_CALLBACK_RETURN_ON_ERROR(krpc_decode_string(stream, &state->value->items[i]));
  return true;
}

inline krpc_error_t krpc_decode_set_string(
  pb_istream_t * stream, krpc_set_string_t * value) {
  typedef struct { size_t capacity; krpc_set_string_t * value; } State;
  State state = { 0, value };
  value->size = 0;
  if (value->items == NULL) {
    value->items = (char **)krpc_calloc(KRPC_ALLOC_BLOCK_SIZE, sizeof(char *));
    state.capacity = KRPC_ALLOC_BLOCK_SIZE;
  }
  krpc_schema_Set message = krpc_schema_Set_init_default;
  message.items.funcs.decode = &krpc_decode_callback_item_set_string;
  message.items.arg = &state;
  KRPC_RETURN_ON_ERROR(krpc_decode_message_Set(stream, &message));
  return KRPC_OK;
}

#endif  // KRPC_IMPL_TYPE_SET_STRING

#ifndef KRPC_IMPL_TYPE_LIST_OBJECT
#define KRPC_IMPL_TYPE_LIST_OBJECT

static bool krpc_encode_callback_items_list_object(
  pb_ostream_t * stream, const pb_field_t * field, void * const * arg) {
  const krpc_list_object_t * value = (const krpc_list_object_t*)(*arg);
  size_t i = 0;
  for (; i < value->size; i++) {
    if (!pb_encode_tag_for_field(stream, field))
      KRPC_CALLBACK_RETURN_ERROR("encoding tag for list item");
    size_t size;
    KRPC_CALLBACK_RETURN_ON_ERROR(krpc_encode_size_object(&size, value->items[i]));
    if (!pb_encode_varint(stream, size))
      KRPC_CALLBACK_RETURN_ERROR("encoding size for list item");
    KRPC_CALLBACK_RETURN_ON_ERROR(krpc_encode_object(stream, value->items[i]));
  }
  return true;
}

inline krpc_error_t krpc_encode_list_object(
  pb_ostream_t * stream, const krpc_list_object_t * value) {
  krpc_schema_List message = krpc_schema_List_init_default;
  message.items.funcs.encode = &krpc_encode_callback_items_list_object;
  message.items.arg = (krpc_list_object_t*)value;
  KRPC_RETURN_ON_ERROR(krpc_encode_message_List(stream, &message));
  return KRPC_OK;
}

inline krpc_error_t krpc_encode_size_list_object(
  size_t * size, const krpc_list_object_t * value) {
  pb_ostream_t stream = PB_OSTREAM_SIZING;
  KRPC_RETURN_ON_ERROR(krpc_encode_list_object(&stream, value));
  *size = stream.bytes_written;
  return KRPC_OK;
}

inline bool krpc_encode_callback_list_object(
  pb_ostream_t * stream, const pb_field_t * field, void * const * arg) {
  if (!pb_encode_tag_for_field(stream, field))
    KRPC_CALLBACK_RETURN_ERROR("encoding tag for list_object");
  krpc_list_object_t * value = (krpc_list_object_t*)(*arg);
  size_t size;
  KRPC_CALLBACK_RETURN_ON_ERROR(krpc_encode_size_list_object(&size, value));
  if (!pb_encode_varint(stream, size))
    KRPC_CALLBACK_RETURN_ERROR("encoding size for list_object");
  KRPC_CALLBACK_RETURN_ON_ERROR(krpc_encode_list_object(stream, value));
  return true;
}

static bool krpc_decode_callback_item_list_object(
  pb_istream_t * stream, const pb_field_t * field, void ** arg) {
  typedef struct { size_t capacity; krpc_list_object_t * value; } State;
  State * state = (State*)(*arg);
  size_t i = state->value->size;
  state->value->size++;
  if (state->capacity > 0 && state->value->size > state->capacity) {
    state->value->items = (krpc_SpaceCenter_Sensor_t*)krpc_recalloc(state->value->items, state->capacity, KRPC_ALLOC_BLOCK_SIZE, sizeof(krpc_SpaceCenter_Sensor_t));
    state->capacity += KRPC_ALLOC_BLOCK_SIZE;
  }
  KRPC_CALLBACK_RETURN_ON_ERROR(krpc_decode_object(stream, &state->value->items[i]));
  return true;
}

inline krpc_error_t krpc_decode_list_object(
  pb_istream_t * stream, krpc_list_object_t * value) {
  typedef struct { size_t capacity; krpc_list_object_t * value; } State;
  State state = { 0, value };
  value->size = 0;
  if (value->items == NULL) {
    value->items = (krpc_SpaceCenter_Sensor_t*)krpc_calloc(KRPC_ALLOC_BLOCK_SIZE, sizeof(krpc_SpaceCenter_Sensor_t));
    state.capacity = KRPC_ALLOC_BLOCK_SIZE;
  }
  krpc_schema_List message = krpc_schema_List_init_default;
  message.items.funcs.decode = &krpc_decode_callback_item_list_object;
  message.items.arg = &state;
  KRPC_RETURN_ON_ERROR(krpc_decode_message_List(stream, &message));
  return KRPC_OK;
}

#endif  // KRPC_IMPL_TYPE_LIST_OBJECT

#ifndef KRPC_IMPL_TYPE_LIST_OBJECT
#define KRPC_IMPL_TYPE_LIST_OBJECT

static bool krpc_encode_callback_items_list_object(
  pb_ostream_t * stream, const pb_field_t * field, void * const * arg) {
  const krpc_list_object_t * value = (const krpc_list_object_t*)(*arg);
  size_t i = 0;
  for (; i < value->size; i++) {
    if (!pb_encode_tag_for_field(stream, field))
      KRPC_CALLBACK_RETURN_ERROR("encoding tag for list item");
    size_t size;
    KRPC_CALLBACK_RETURN_ON_ERROR(krpc_encode_size_object(&size, value->items[i]));
    if (!pb_encode_varint(stream, size))
      KRPC_CALLBACK_RETURN_ERROR("encoding size for list item");
    KRPC_CALLBACK_RETURN_ON_ERROR(krpc_encode_object(stream, value->items[i]));
  }
  return true;
}

inline krpc_error_t krpc_encode_list_object(
  pb_ostream_t * stream, const krpc_list_object_t * value) {
  krpc_schema_List message = krpc_schema_List_init_default;
  message.items.funcs.encode = &krpc_encode_callback_items_list_object;
  message.items.arg = (krpc_list_object_t*)value;
  KRPC_RETURN_ON_ERROR(krpc_encode_message_List(stream, &message));
  return KRPC_OK;
}

inline krpc_error_t krpc_encode_size_list_object(
  size_t * size, const krpc_list_object_t * value) {
  pb_ostream_t stream = PB_OSTREAM_SIZING;
  KRPC_RETURN_ON_ERROR(krpc_encode_list_object(&stream, value));
  *size = stream.bytes_written;
  return KRPC_OK;
}

inline bool krpc_encode_callback_list_object(
  pb_ostream_t * stream, const pb_field_t * field, void * const * arg) {
  if (!pb_encode_tag_for_field(stream, field))
    KRPC_CALLBACK_RETURN_ERROR("encoding tag for list_object");
  krpc_list_object_t * value = (krpc_list_object_t*)(*arg);
  size_t size;
  KRPC_CALLBACK_RETURN_ON_ERROR(krpc_encode_size_list_object(&size, value));
  if (!pb_encode_varint(stream, size))
    KRPC_CALLBACK_RETURN_ERROR("encoding size for list_object");
  KRPC_CALLBACK_RETURN_ON_ERROR(krpc_encode_list_object(stream, value));
  return true;
}

static bool krpc_decode_callback_item_list_object(
  pb_istream_t * stream, const pb_field_t * field, void ** arg) {
  typedef struct { size_t capacity; krpc_list_object_t * value; } State;
  State * state = (State*)(*arg);
  size_t i = state->value->size;
  state->value->size++;
  if (state->capacity > 0 && state->value->size > state->capacity) {
    state->value->items = (krpc_SpaceCenter_Antenna_t*)krpc_recalloc(state->value->items, state->capacity, KRPC_ALLOC_BLOCK_SIZE, sizeof(krpc_SpaceCenter_Antenna_t));
    state->capacity += KRPC_ALLOC_BLOCK_SIZE;
  }
  KRPC_CALLBACK_RETURN_ON_ERROR(krpc_decode_object(stream, &state->value->items[i]));
  return true;
}

inline krpc_error_t krpc_decode_list_object(
  pb_istream_t * stream, krpc_list_object_t * value) {
  typedef struct { size_t capacity; krpc_list_object_t * value; } State;
  State state = { 0, value };
  value->size = 0;
  if (value->items == NULL) {
    value->items = (krpc_SpaceCenter_Antenna_t*)krpc_calloc(KRPC_ALLOC_BLOCK_SIZE, sizeof(krpc_SpaceCenter_Antenna_t));
    state.capacity = KRPC_ALLOC_BLOCK_SIZE;
  }
  krpc_schema_List message = krpc_schema_List_init_default;
  message.items.funcs.decode = &krpc_decode_callback_item_list_object;
  message.items.arg = &state;
  KRPC_RETURN_ON_ERROR(krpc_decode_message_List(stream, &message));
  return KRPC_OK;
}

#endif  // KRPC_IMPL_TYPE_LIST_OBJECT

#ifndef KRPC_IMPL_TYPE_LIST_OBJECT
#define KRPC_IMPL_TYPE_LIST_OBJECT

static bool krpc_encode_callback_items_list_object(
  pb_ostream_t * stream, const pb_field_t * field, void * const * arg) {
  const krpc_list_object_t * value = (const krpc_list_object_t*)(*arg);
  size_t i = 0;
  for (; i < value->size; i++) {
    if (!pb_encode_tag_for_field(stream, field))
      KRPC_CALLBACK_RETURN_ERROR("encoding tag for list item");
    size_t size;
    KRPC_CALLBACK_RETURN_ON_ERROR(krpc_encode_size_object(&size, value->items[i]));
    if (!pb_encode_varint(stream, size))
      KRPC_CALLBACK_RETURN_ERROR("encoding size for list item");
    KRPC_CALLBACK_RETURN_ON_ERROR(krpc_encode_object(stream, value->items[i]));
  }
  return true;
}

inline krpc_error_t krpc_encode_list_object(
  pb_ostream_t * stream, const krpc_list_object_t * value) {
  krpc_schema_List message = krpc_schema_List_init_default;
  message.items.funcs.encode = &krpc_encode_callback_items_list_object;
  message.items.arg = (krpc_list_object_t*)value;
  KRPC_RETURN_ON_ERROR(krpc_encode_message_List(stream, &message));
  return KRPC_OK;
}

inline krpc_error_t krpc_encode_size_list_object(
  size_t * size, const krpc_list_object_t * value) {
  pb_ostream_t stream = PB_OSTREAM_SIZING;
  KRPC_RETURN_ON_ERROR(krpc_encode_list_object(&stream, value));
  *size = stream.bytes_written;
  return KRPC_OK;
}

inline bool krpc_encode_callback_list_object(
  pb_ostream_t * stream, const pb_field_t * field, void * const * arg) {
  if (!pb_encode_tag_for_field(stream, field))
    KRPC_CALLBACK_RETURN_ERROR("encoding tag for list_object");
  krpc_list_object_t * value = (krpc_list_object_t*)(*arg);
  size_t size;
  KRPC_CALLBACK_RETURN_ON_ERROR(krpc_encode_size_list_object(&size, value));
  if (!pb_encode_varint(stream, size))
    KRPC_CALLBACK_RETURN_ERROR("encoding size for list_object");
  KRPC_CALLBACK_RETURN_ON_ERROR(krpc_encode_list_object(stream, value));
  return true;
}

static bool krpc_decode_callback_item_list_object(
  pb_istream_t * stream, const pb_field_t * field, void ** arg) {
  typedef struct { size_t capacity; krpc_list_object_t * value; } State;
  State * state = (State*)(*arg);
  size_t i = state->value->size;
  state->value->size++;
  if (state->capacity > 0 && state->value->size > state->capacity) {
    state->value->items = (krpc_SpaceCenter_Vessel_t*)krpc_recalloc(state->value->items, state->capacity, KRPC_ALLOC_BLOCK_SIZE, sizeof(krpc_SpaceCenter_Vessel_t));
    state->capacity += KRPC_ALLOC_BLOCK_SIZE;
  }
  KRPC_CALLBACK_RETURN_ON_ERROR(krpc_decode_object(stream, &state->value->items[i]));
  return true;
}

inline krpc_error_t krpc_decode_list_object(
  pb_istream_t * stream, krpc_list_object_t * value) {
  typedef struct { size_t capacity; krpc_list_object_t * value; } State;
  State state = { 0, value };
  value->size = 0;
  if (value->items == NULL) {
    value->items = (krpc_SpaceCenter_Vessel_t*)krpc_calloc(KRPC_ALLOC_BLOCK_SIZE, sizeof(krpc_SpaceCenter_Vessel_t));
    state.capacity = KRPC_ALLOC_BLOCK_SIZE;
  }
  krpc_schema_List message = krpc_schema_List_init_default;
  message.items.funcs.decode = &krpc_decode_callback_item_list_object;
  message.items.arg = &state;
  KRPC_RETURN_ON_ERROR(krpc_decode_message_List(stream, &message));
  return KRPC_OK;
}

#endif  // KRPC_IMPL_TYPE_LIST_OBJECT

#ifndef KRPC_IMPL_TYPE_LIST_OBJECT
#define KRPC_IMPL_TYPE_LIST_OBJECT

static bool krpc_encode_callback_items_list_object(
  pb_ostream_t * stream, const pb_field_t * field, void * const * arg) {
  const krpc_list_object_t * value = (const krpc_list_object_t*)(*arg);
  size_t i = 0;
  for (; i < value->size; i++) {
    if (!pb_encode_tag_for_field(stream, field))
      KRPC_CALLBACK_RETURN_ERROR("encoding tag for list item");
    size_t size;
    KRPC_CALLBACK_RETURN_ON_ERROR(krpc_encode_size_object(&size, value->items[i]));
    if (!pb_encode_varint(stream, size))
      KRPC_CALLBACK_RETURN_ERROR("encoding size for list item");
    KRPC_CALLBACK_RETURN_ON_ERROR(krpc_encode_object(stream, value->items[i]));
  }
  return true;
}

inline krpc_error_t krpc_encode_list_object(
  pb_ostream_t * stream, const krpc_list_object_t * value) {
  krpc_schema_List message = krpc_schema_List_init_default;
  message.items.funcs.encode = &krpc_encode_callback_items_list_object;
  message.items.arg = (krpc_list_object_t*)value;
  KRPC_RETURN_ON_ERROR(krpc_encode_message_List(stream, &message));
  return KRPC_OK;
}

inline krpc_error_t krpc_encode_size_list_object(
  size_t * size, const krpc_list_object_t * value) {
  pb_ostream_t stream = PB_OSTREAM_SIZING;
  KRPC_RETURN_ON_ERROR(krpc_encode_list_object(&stream, value));
  *size = stream.bytes_written;
  return KRPC_OK;
}

inline bool krpc_encode_callback_list_object(
  pb_ostream_t * stream, const pb_field_t * field, void * const * arg) {
  if (!pb_encode_tag_for_field(stream, field))
    KRPC_CALLBACK_RETURN_ERROR("encoding tag for list_object");
  krpc_list_object_t * value = (krpc_list_object_t*)(*arg);
  size_t size;
  KRPC_CALLBACK_RETURN_ON_ERROR(krpc_encode_size_list_object(&size, value));
  if (!pb_encode_varint(stream, size))
    KRPC_CALLBACK_RETURN_ERROR("encoding size for list_object");
  KRPC_CALLBACK_RETURN_ON_ERROR(krpc_encode_list_object(stream, value));
  return true;
}

static bool krpc_decode_callback_item_list_object(
  pb_istream_t * stream, const pb_field_t * field, void ** arg) {
  typedef struct { size_t capacity; krpc_list_object_t * value; } State;
  State * state = (State*)(*arg);
  size_t i = state->value->size;
  state->value->size++;
  if (state->capacity > 0 && state->value->size > state->capacity) {
    state->value->items = (krpc_SpaceCenter_ResourceConverter_t*)krpc_recalloc(state->value->items, state->capacity, KRPC_ALLOC_BLOCK_SIZE, sizeof(krpc_SpaceCenter_ResourceConverter_t));
    state->capacity += KRPC_ALLOC_BLOCK_SIZE;
  }
  KRPC_CALLBACK_RETURN_ON_ERROR(krpc_decode_object(stream, &state->value->items[i]));
  return true;
}

inline krpc_error_t krpc_decode_list_object(
  pb_istream_t * stream, krpc_list_object_t * value) {
  typedef struct { size_t capacity; krpc_list_object_t * value; } State;
  State state = { 0, value };
  value->size = 0;
  if (value->items == NULL) {
    value->items = (krpc_SpaceCenter_ResourceConverter_t*)krpc_calloc(KRPC_ALLOC_BLOCK_SIZE, sizeof(krpc_SpaceCenter_ResourceConverter_t));
    state.capacity = KRPC_ALLOC_BLOCK_SIZE;
  }
  krpc_schema_List message = krpc_schema_List_init_default;
  message.items.funcs.decode = &krpc_decode_callback_item_list_object;
  message.items.arg = &state;
  KRPC_RETURN_ON_ERROR(krpc_decode_message_List(stream, &message));
  return KRPC_OK;
}

#endif  // KRPC_IMPL_TYPE_LIST_OBJECT

#ifndef KRPC_IMPL_TYPE_LIST_OBJECT
#define KRPC_IMPL_TYPE_LIST_OBJECT

static bool krpc_encode_callback_items_list_object(
  pb_ostream_t * stream, const pb_field_t * field, void * const * arg) {
  const krpc_list_object_t * value = (const krpc_list_object_t*)(*arg);
  size_t i = 0;
  for (; i < value->size; i++) {
    if (!pb_encode_tag_for_field(stream, field))
      KRPC_CALLBACK_RETURN_ERROR("encoding tag for list item");
    size_t size;
    KRPC_CALLBACK_RETURN_ON_ERROR(krpc_encode_size_object(&size, value->items[i]));
    if (!pb_encode_varint(stream, size))
      KRPC_CALLBACK_RETURN_ERROR("encoding size for list item");
    KRPC_CALLBACK_RETURN_ON_ERROR(krpc_encode_object(stream, value->items[i]));
  }
  return true;
}

inline krpc_error_t krpc_encode_list_object(
  pb_ostream_t * stream, const krpc_list_object_t * value) {
  krpc_schema_List message = krpc_schema_List_init_default;
  message.items.funcs.encode = &krpc_encode_callback_items_list_object;
  message.items.arg = (krpc_list_object_t*)value;
  KRPC_RETURN_ON_ERROR(krpc_encode_message_List(stream, &message));
  return KRPC_OK;
}

inline krpc_error_t krpc_encode_size_list_object(
  size_t * size, const krpc_list_object_t * value) {
  pb_ostream_t stream = PB_OSTREAM_SIZING;
  KRPC_RETURN_ON_ERROR(krpc_encode_list_object(&stream, value));
  *size = stream.bytes_written;
  return KRPC_OK;
}

inline bool krpc_encode_callback_list_object(
  pb_ostream_t * stream, const pb_field_t * field, void * const * arg) {
  if (!pb_encode_tag_for_field(stream, field))
    KRPC_CALLBACK_RETURN_ERROR("encoding tag for list_object");
  krpc_list_object_t * value = (krpc_list_object_t*)(*arg);
  size_t size;
  KRPC_CALLBACK_RETURN_ON_ERROR(krpc_encode_size_list_object(&size, value));
  if (!pb_encode_varint(stream, size))
    KRPC_CALLBACK_RETURN_ERROR("encoding size for list_object");
  KRPC_CALLBACK_RETURN_ON_ERROR(krpc_encode_list_object(stream, value));
  return true;
}

static bool krpc_decode_callback_item_list_object(
  pb_istream_t * stream, const pb_field_t * field, void ** arg) {
  typedef struct { size_t capacity; krpc_list_object_t * value; } State;
  State * state = (State*)(*arg);
  size_t i = state->value->size;
  state->value->size++;
  if (state->capacity > 0 && state->value->size > state->capacity) {
    state->value->items = (krpc_SpaceCenter_LaunchClamp_t*)krpc_recalloc(state->value->items, state->capacity, KRPC_ALLOC_BLOCK_SIZE, sizeof(krpc_SpaceCenter_LaunchClamp_t));
    state->capacity += KRPC_ALLOC_BLOCK_SIZE;
  }
  KRPC_CALLBACK_RETURN_ON_ERROR(krpc_decode_object(stream, &state->value->items[i]));
  return true;
}

inline krpc_error_t krpc_decode_list_object(
  pb_istream_t * stream, krpc_list_object_t * value) {
  typedef struct { size_t capacity; krpc_list_object_t * value; } State;
  State state = { 0, value };
  value->size = 0;
  if (value->items == NULL) {
    value->items = (krpc_SpaceCenter_LaunchClamp_t*)krpc_calloc(KRPC_ALLOC_BLOCK_SIZE, sizeof(krpc_SpaceCenter_LaunchClamp_t));
    state.capacity = KRPC_ALLOC_BLOCK_SIZE;
  }
  krpc_schema_List message = krpc_schema_List_init_default;
  message.items.funcs.decode = &krpc_decode_callback_item_list_object;
  message.items.arg = &state;
  KRPC_RETURN_ON_ERROR(krpc_decode_message_List(stream, &message));
  return KRPC_OK;
}

#endif  // KRPC_IMPL_TYPE_LIST_OBJECT

#ifndef KRPC_IMPL_TYPE_LIST_OBJECT
#define KRPC_IMPL_TYPE_LIST_OBJECT

static bool krpc_encode_callback_items_list_object(
  pb_ostream_t * stream, const pb_field_t * field, void * const * arg) {
  const krpc_list_object_t * value = (const krpc_list_object_t*)(*arg);
  size_t i = 0;
  for (; i < value->size; i++) {
    if (!pb_encode_tag_for_field(stream, field))
      KRPC_CALLBACK_RETURN_ERROR("encoding tag for list item");
    size_t size;
    KRPC_CALLBACK_RETURN_ON_ERROR(krpc_encode_size_object(&size, value->items[i]));
    if (!pb_encode_varint(stream, size))
      KRPC_CALLBACK_RETURN_ERROR("encoding size for list item");
    KRPC_CALLBACK_RETURN_ON_ERROR(krpc_encode_object(stream, value->items[i]));
  }
  return true;
}

inline krpc_error_t krpc_encode_list_object(
  pb_ostream_t * stream, const krpc_list_object_t * value) {
  krpc_schema_List message = krpc_schema_List_init_default;
  message.items.funcs.encode = &krpc_encode_callback_items_list_object;
  message.items.arg = (krpc_list_object_t*)value;
  KRPC_RETURN_ON_ERROR(krpc_encode_message_List(stream, &message));
  return KRPC_OK;
}

inline krpc_error_t krpc_encode_size_list_object(
  size_t * size, const krpc_list_object_t * value) {
  pb_ostream_t stream = PB_OSTREAM_SIZING;
  KRPC_RETURN_ON_ERROR(krpc_encode_list_object(&stream, value));
  *size = stream.bytes_written;
  return KRPC_OK;
}

inline bool krpc_encode_callback_list_object(
  pb_ostream_t * stream, const pb_field_t * field, void * const * arg) {
  if (!pb_encode_tag_for_field(stream, field))
    KRPC_CALLBACK_RETURN_ERROR("encoding tag for list_object");
  krpc_list_object_t * value = (krpc_list_object_t*)(*arg);
  size_t size;
  KRPC_CALLBACK_RETURN_ON_ERROR(krpc_encode_size_list_object(&size, value));
  if (!pb_encode_varint(stream, size))
    KRPC_CALLBACK_RETURN_ERROR("encoding size for list_object");
  KRPC_CALLBACK_RETURN_ON_ERROR(krpc_encode_list_object(stream, value));
  return true;
}

static bool krpc_decode_callback_item_list_object(
  pb_istream_t * stream, const pb_field_t * field, void ** arg) {
  typedef struct { size_t capacity; krpc_list_object_t * value; } State;
  State * state = (State*)(*arg);
  size_t i = state->value->size;
  state->value->size++;
  if (state->capacity > 0 && state->value->size > state->capacity) {
    state->value->items = (krpc_SpaceCenter_Experiment_t*)krpc_recalloc(state->value->items, state->capacity, KRPC_ALLOC_BLOCK_SIZE, sizeof(krpc_SpaceCenter_Experiment_t));
    state->capacity += KRPC_ALLOC_BLOCK_SIZE;
  }
  KRPC_CALLBACK_RETURN_ON_ERROR(krpc_decode_object(stream, &state->value->items[i]));
  return true;
}

inline krpc_error_t krpc_decode_list_object(
  pb_istream_t * stream, krpc_list_object_t * value) {
  typedef struct { size_t capacity; krpc_list_object_t * value; } State;
  State state = { 0, value };
  value->size = 0;
  if (value->items == NULL) {
    value->items = (krpc_SpaceCenter_Experiment_t*)krpc_calloc(KRPC_ALLOC_BLOCK_SIZE, sizeof(krpc_SpaceCenter_Experiment_t));
    state.capacity = KRPC_ALLOC_BLOCK_SIZE;
  }
  krpc_schema_List message = krpc_schema_List_init_default;
  message.items.funcs.decode = &krpc_decode_callback_item_list_object;
  message.items.arg = &state;
  KRPC_RETURN_ON_ERROR(krpc_decode_message_List(stream, &message));
  return KRPC_OK;
}

#endif  // KRPC_IMPL_TYPE_LIST_OBJECT

#ifndef KRPC_IMPL_TYPE_LIST_OBJECT
#define KRPC_IMPL_TYPE_LIST_OBJECT

static bool krpc_encode_callback_items_list_object(
  pb_ostream_t * stream, const pb_field_t * field, void * const * arg) {
  const krpc_list_object_t * value = (const krpc_list_object_t*)(*arg);
  size_t i = 0;
  for (; i < value->size; i++) {
    if (!pb_encode_tag_for_field(stream, field))
      KRPC_CALLBACK_RETURN_ERROR("encoding tag for list item");
    size_t size;
    KRPC_CALLBACK_RETURN_ON_ERROR(krpc_encode_size_object(&size, value->items[i]));
    if (!pb_encode_varint(stream, size))
      KRPC_CALLBACK_RETURN_ERROR("encoding size for list item");
    KRPC_CALLBACK_RETURN_ON_ERROR(krpc_encode_object(stream, value->items[i]));
  }
  return true;
}

inline krpc_error_t krpc_encode_list_object(
  pb_ostream_t * stream, const krpc_list_object_t * value) {
  krpc_schema_List message = krpc_schema_List_init_default;
  message.items.funcs.encode = &krpc_encode_callback_items_list_object;
  message.items.arg = (krpc_list_object_t*)value;
  KRPC_RETURN_ON_ERROR(krpc_encode_message_List(stream, &message));
  return KRPC_OK;
}

inline krpc_error_t krpc_encode_size_list_object(
  size_t * size, const krpc_list_object_t * value) {
  pb_ostream_t stream = PB_OSTREAM_SIZING;
  KRPC_RETURN_ON_ERROR(krpc_encode_list_object(&stream, value));
  *size = stream.bytes_written;
  return KRPC_OK;
}

inline bool krpc_encode_callback_list_object(
  pb_ostream_t * stream, const pb_field_t * field, void * const * arg) {
  if (!pb_encode_tag_for_field(stream, field))
    KRPC_CALLBACK_RETURN_ERROR("encoding tag for list_object");
  krpc_list_object_t * value = (krpc_list_object_t*)(*arg);
  size_t size;
  KRPC_CALLBACK_RETURN_ON_ERROR(krpc_encode_size_list_object(&size, value));
  if (!pb_encode_varint(stream, size))
    KRPC_CALLBACK_RETURN_ERROR("encoding size for list_object");
  KRPC_CALLBACK_RETURN_ON_ERROR(krpc_encode_list_object(stream, value));
  return true;
}

static bool krpc_decode_callback_item_list_object(
  pb_istream_t * stream, const pb_field_t * field, void ** arg) {
  typedef struct { size_t capacity; krpc_list_object_t * value; } State;
  State * state = (State*)(*arg);
  size_t i = state->value->size;
  state->value->size++;
  if (state->capacity > 0 && state->value->size > state->capacity) {
    state->value->items = (krpc_SpaceCenter_ResourceHarvester_t*)krpc_recalloc(state->value->items, state->capacity, KRPC_ALLOC_BLOCK_SIZE, sizeof(krpc_SpaceCenter_ResourceHarvester_t));
    state->capacity += KRPC_ALLOC_BLOCK_SIZE;
  }
  KRPC_CALLBACK_RETURN_ON_ERROR(krpc_decode_object(stream, &state->value->items[i]));
  return true;
}

inline krpc_error_t krpc_decode_list_object(
  pb_istream_t * stream, krpc_list_object_t * value) {
  typedef struct { size_t capacity; krpc_list_object_t * value; } State;
  State state = { 0, value };
  value->size = 0;
  if (value->items == NULL) {
    value->items = (krpc_SpaceCenter_ResourceHarvester_t*)krpc_calloc(KRPC_ALLOC_BLOCK_SIZE, sizeof(krpc_SpaceCenter_ResourceHarvester_t));
    state.capacity = KRPC_ALLOC_BLOCK_SIZE;
  }
  krpc_schema_List message = krpc_schema_List_init_default;
  message.items.funcs.decode = &krpc_decode_callback_item_list_object;
  message.items.arg = &state;
  KRPC_RETURN_ON_ERROR(krpc_decode_message_List(stream, &message));
  return KRPC_OK;
}

#endif  // KRPC_IMPL_TYPE_LIST_OBJECT

#ifndef KRPC_IMPL_TYPE_LIST_OBJECT
#define KRPC_IMPL_TYPE_LIST_OBJECT

static bool krpc_encode_callback_items_list_object(
  pb_ostream_t * stream, const pb_field_t * field, void * const * arg) {
  const krpc_list_object_t * value = (const krpc_list_object_t*)(*arg);
  size_t i = 0;
  for (; i < value->size; i++) {
    if (!pb_encode_tag_for_field(stream, field))
      KRPC_CALLBACK_RETURN_ERROR("encoding tag for list item");
    size_t size;
    KRPC_CALLBACK_RETURN_ON_ERROR(krpc_encode_size_object(&size, value->items[i]));
    if (!pb_encode_varint(stream, size))
      KRPC_CALLBACK_RETURN_ERROR("encoding size for list item");
    KRPC_CALLBACK_RETURN_ON_ERROR(krpc_encode_object(stream, value->items[i]));
  }
  return true;
}

inline krpc_error_t krpc_encode_list_object(
  pb_ostream_t * stream, const krpc_list_object_t * value) {
  krpc_schema_List message = krpc_schema_List_init_default;
  message.items.funcs.encode = &krpc_encode_callback_items_list_object;
  message.items.arg = (krpc_list_object_t*)value;
  KRPC_RETURN_ON_ERROR(krpc_encode_message_List(stream, &message));
  return KRPC_OK;
}

inline krpc_error_t krpc_encode_size_list_object(
  size_t * size, const krpc_list_object_t * value) {
  pb_ostream_t stream = PB_OSTREAM_SIZING;
  KRPC_RETURN_ON_ERROR(krpc_encode_list_object(&stream, value));
  *size = stream.bytes_written;
  return KRPC_OK;
}

inline bool krpc_encode_callback_list_object(
  pb_ostream_t * stream, const pb_field_t * field, void * const * arg) {
  if (!pb_encode_tag_for_field(stream, field))
    KRPC_CALLBACK_RETURN_ERROR("encoding tag for list_object");
  krpc_list_object_t * value = (krpc_list_object_t*)(*arg);
  size_t size;
  KRPC_CALLBACK_RETURN_ON_ERROR(krpc_encode_size_list_object(&size, value));
  if (!pb_encode_varint(stream, size))
    KRPC_CALLBACK_RETURN_ERROR("encoding size for list_object");
  KRPC_CALLBACK_RETURN_ON_ERROR(krpc_encode_list_object(stream, value));
  return true;
}

static bool krpc_decode_callback_item_list_object(
  pb_istream_t * stream, const pb_field_t * field, void ** arg) {
  typedef struct { size_t capacity; krpc_list_object_t * value; } State;
  State * state = (State*)(*arg);
  size_t i = state->value->size;
  state->value->size++;
  if (state->capacity > 0 && state->value->size > state->capacity) {
    state->value->items = (krpc_SpaceCenter_ScienceData_t*)krpc_recalloc(state->value->items, state->capacity, KRPC_ALLOC_BLOCK_SIZE, sizeof(krpc_SpaceCenter_ScienceData_t));
    state->capacity += KRPC_ALLOC_BLOCK_SIZE;
  }
  KRPC_CALLBACK_RETURN_ON_ERROR(krpc_decode_object(stream, &state->value->items[i]));
  return true;
}

inline krpc_error_t krpc_decode_list_object(
  pb_istream_t * stream, krpc_list_object_t * value) {
  typedef struct { size_t capacity; krpc_list_object_t * value; } State;
  State state = { 0, value };
  value->size = 0;
  if (value->items == NULL) {
    value->items = (krpc_SpaceCenter_ScienceData_t*)krpc_calloc(KRPC_ALLOC_BLOCK_SIZE, sizeof(krpc_SpaceCenter_ScienceData_t));
    state.capacity = KRPC_ALLOC_BLOCK_SIZE;
  }
  krpc_schema_List message = krpc_schema_List_init_default;
  message.items.funcs.decode = &krpc_decode_callback_item_list_object;
  message.items.arg = &state;
  KRPC_RETURN_ON_ERROR(krpc_decode_message_List(stream, &message));
  return KRPC_OK;
}

#endif  // KRPC_IMPL_TYPE_LIST_OBJECT

#ifndef KRPC_IMPL_TYPE_LIST_OBJECT
#define KRPC_IMPL_TYPE_LIST_OBJECT

static bool krpc_encode_callback_items_list_object(
  pb_ostream_t * stream, const pb_field_t * field, void * const * arg) {
  const krpc_list_object_t * value = (const krpc_list_object_t*)(*arg);
  size_t i = 0;
  for (; i < value->size; i++) {
    if (!pb_encode_tag_for_field(stream, field))
      KRPC_CALLBACK_RETURN_ERROR("encoding tag for list item");
    size_t size;
    KRPC_CALLBACK_RETURN_ON_ERROR(krpc_encode_size_object(&size, value->items[i]));
    if (!pb_encode_varint(stream, size))
      KRPC_CALLBACK_RETURN_ERROR("encoding size for list item");
    KRPC_CALLBACK_RETURN_ON_ERROR(krpc_encode_object(stream, value->items[i]));
  }
  return true;
}

inline krpc_error_t krpc_encode_list_object(
  pb_ostream_t * stream, const krpc_list_object_t * value) {
  krpc_schema_List message = krpc_schema_List_init_default;
  message.items.funcs.encode = &krpc_encode_callback_items_list_object;
  message.items.arg = (krpc_list_object_t*)value;
  KRPC_RETURN_ON_ERROR(krpc_encode_message_List(stream, &message));
  return KRPC_OK;
}

inline krpc_error_t krpc_encode_size_list_object(
  size_t * size, const krpc_list_object_t * value) {
  pb_ostream_t stream = PB_OSTREAM_SIZING;
  KRPC_RETURN_ON_ERROR(krpc_encode_list_object(&stream, value));
  *size = stream.bytes_written;
  return KRPC_OK;
}

inline bool krpc_encode_callback_list_object(
  pb_ostream_t * stream, const pb_field_t * field, void * const * arg) {
  if (!pb_encode_tag_for_field(stream, field))
    KRPC_CALLBACK_RETURN_ERROR("encoding tag for list_object");
  krpc_list_object_t * value = (krpc_list_object_t*)(*arg);
  size_t size;
  KRPC_CALLBACK_RETURN_ON_ERROR(krpc_encode_size_list_object(&size, value));
  if (!pb_encode_varint(stream, size))
    KRPC_CALLBACK_RETURN_ERROR("encoding size for list_object");
  KRPC_CALLBACK_RETURN_ON_ERROR(krpc_encode_list_object(stream, value));
  return true;
}

static bool krpc_decode_callback_item_list_object(
  pb_istream_t * stream, const pb_field_t * field, void ** arg) {
  typedef struct { size_t capacity; krpc_list_object_t * value; } State;
  State * state = (State*)(*arg);
  size_t i = state->value->size;
  state->value->size++;
  if (state->capacity > 0 && state->value->size > state->capacity) {
    state->value->items = (krpc_SpaceCenter_Waypoint_t*)krpc_recalloc(state->value->items, state->capacity, KRPC_ALLOC_BLOCK_SIZE, sizeof(krpc_SpaceCenter_Waypoint_t));
    state->capacity += KRPC_ALLOC_BLOCK_SIZE;
  }
  KRPC_CALLBACK_RETURN_ON_ERROR(krpc_decode_object(stream, &state->value->items[i]));
  return true;
}

inline krpc_error_t krpc_decode_list_object(
  pb_istream_t * stream, krpc_list_object_t * value) {
  typedef struct { size_t capacity; krpc_list_object_t * value; } State;
  State state = { 0, value };
  value->size = 0;
  if (value->items == NULL) {
    value->items = (krpc_SpaceCenter_Waypoint_t*)krpc_calloc(KRPC_ALLOC_BLOCK_SIZE, sizeof(krpc_SpaceCenter_Waypoint_t));
    state.capacity = KRPC_ALLOC_BLOCK_SIZE;
  }
  krpc_schema_List message = krpc_schema_List_init_default;
  message.items.funcs.decode = &krpc_decode_callback_item_list_object;
  message.items.arg = &state;
  KRPC_RETURN_ON_ERROR(krpc_decode_message_List(stream, &message));
  return KRPC_OK;
}

#endif  // KRPC_IMPL_TYPE_LIST_OBJECT

inline krpc_error_t krpc_SpaceCenter_CanRailsWarpAt(krpc_connection_t connection, bool * returnValue, int32_t factor) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "CanRailsWarpAt", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_int32, &factor));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_bool(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_ClearTarget(krpc_connection_t connection) {
  krpc_call_t _call;
  krpc_argument_t _arguments[0];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "ClearTarget", 0, _arguments));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_LaunchVessel(krpc_connection_t connection, const char * craftDirectory, const char * name, const char * launchSite) {
  krpc_call_t _call;
  krpc_argument_t _arguments[3];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "LaunchVessel", 3, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_string, &craftDirectory));
  KRPC_CHECK(krpc_add_argument(&_call, 1, &krpc_encode_callback_string, &name));
  KRPC_CHECK(krpc_add_argument(&_call, 2, &krpc_encode_callback_string, &launchSite));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_LaunchVesselFromSPH(krpc_connection_t connection, const char * name) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "LaunchVesselFromSPH", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_string, &name));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_LaunchVesselFromVAB(krpc_connection_t connection, const char * name) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "LaunchVesselFromVAB", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_string, &name));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_LaunchableVessels(krpc_connection_t connection, krpc_list_string_t * returnValue, const char * craftDirectory) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "LaunchableVessels", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_string, &craftDirectory));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_list_string(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Load(krpc_connection_t connection, const char * name) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Load", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_string, &name));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Quickload(krpc_connection_t connection) {
  krpc_call_t _call;
  krpc_argument_t _arguments[0];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Quickload", 0, _arguments));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Quicksave(krpc_connection_t connection) {
  krpc_call_t _call;
  krpc_argument_t _arguments[0];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Quicksave", 0, _arguments));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_RaycastDistance(krpc_connection_t connection, double * returnValue, const krpc_tuple_double_double_double_t * position, const krpc_tuple_double_double_double_t * direction, krpc_SpaceCenter_ReferenceFrame_t referenceFrame) {
  krpc_call_t _call;
  krpc_argument_t _arguments[3];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "RaycastDistance", 3, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_tuple_double_double_double, position));
  KRPC_CHECK(krpc_add_argument(&_call, 1, &krpc_encode_callback_tuple_double_double_double, direction));
  KRPC_CHECK(krpc_add_argument(&_call, 2, &krpc_encode_callback_object, &referenceFrame));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_double(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_RaycastPart(krpc_connection_t connection, krpc_SpaceCenter_Part_t * returnValue, const krpc_tuple_double_double_double_t * position, const krpc_tuple_double_double_double_t * direction, krpc_SpaceCenter_ReferenceFrame_t referenceFrame) {
  krpc_call_t _call;
  krpc_argument_t _arguments[3];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "RaycastPart", 3, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_tuple_double_double_double, position));
  KRPC_CHECK(krpc_add_argument(&_call, 1, &krpc_encode_callback_tuple_double_double_double, direction));
  KRPC_CHECK(krpc_add_argument(&_call, 2, &krpc_encode_callback_object, &referenceFrame));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_object(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Save(krpc_connection_t connection, const char * name) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Save", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_string, &name));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_TransformDirection(krpc_connection_t connection, krpc_tuple_double_double_double_t * returnValue, const krpc_tuple_double_double_double_t * direction, krpc_SpaceCenter_ReferenceFrame_t from, krpc_SpaceCenter_ReferenceFrame_t to) {
  krpc_call_t _call;
  krpc_argument_t _arguments[3];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "TransformDirection", 3, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_tuple_double_double_double, direction));
  KRPC_CHECK(krpc_add_argument(&_call, 1, &krpc_encode_callback_object, &from));
  KRPC_CHECK(krpc_add_argument(&_call, 2, &krpc_encode_callback_object, &to));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_tuple_double_double_double(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_TransformPosition(krpc_connection_t connection, krpc_tuple_double_double_double_t * returnValue, const krpc_tuple_double_double_double_t * position, krpc_SpaceCenter_ReferenceFrame_t from, krpc_SpaceCenter_ReferenceFrame_t to) {
  krpc_call_t _call;
  krpc_argument_t _arguments[3];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "TransformPosition", 3, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_tuple_double_double_double, position));
  KRPC_CHECK(krpc_add_argument(&_call, 1, &krpc_encode_callback_object, &from));
  KRPC_CHECK(krpc_add_argument(&_call, 2, &krpc_encode_callback_object, &to));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_tuple_double_double_double(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_TransformRotation(krpc_connection_t connection, krpc_tuple_double_double_double_double_t * returnValue, const krpc_tuple_double_double_double_double_t * rotation, krpc_SpaceCenter_ReferenceFrame_t from, krpc_SpaceCenter_ReferenceFrame_t to) {
  krpc_call_t _call;
  krpc_argument_t _arguments[3];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "TransformRotation", 3, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_tuple_double_double_double_double, rotation));
  KRPC_CHECK(krpc_add_argument(&_call, 1, &krpc_encode_callback_object, &from));
  KRPC_CHECK(krpc_add_argument(&_call, 2, &krpc_encode_callback_object, &to));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_tuple_double_double_double_double(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_TransformVelocity(krpc_connection_t connection, krpc_tuple_double_double_double_t * returnValue, const krpc_tuple_double_double_double_t * position, const krpc_tuple_double_double_double_t * velocity, krpc_SpaceCenter_ReferenceFrame_t from, krpc_SpaceCenter_ReferenceFrame_t to) {
  krpc_call_t _call;
  krpc_argument_t _arguments[4];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "TransformVelocity", 4, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_tuple_double_double_double, position));
  KRPC_CHECK(krpc_add_argument(&_call, 1, &krpc_encode_callback_tuple_double_double_double, velocity));
  KRPC_CHECK(krpc_add_argument(&_call, 2, &krpc_encode_callback_object, &from));
  KRPC_CHECK(krpc_add_argument(&_call, 3, &krpc_encode_callback_object, &to));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_tuple_double_double_double(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_WarpTo(krpc_connection_t connection, double ut, float maxRailsRate, float maxPhysicsRate) {
  krpc_call_t _call;
  krpc_argument_t _arguments[3];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "WarpTo", 3, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_double, &ut));
  KRPC_CHECK(krpc_add_argument(&_call, 1, &krpc_encode_callback_float, &maxRailsRate));
  KRPC_CHECK(krpc_add_argument(&_call, 2, &krpc_encode_callback_float, &maxPhysicsRate));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_WarpFactor(krpc_connection_t connection, float * returnValue) {
  krpc_call_t _call;
  krpc_argument_t _arguments[0];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "get_WarpFactor", 0, _arguments));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_float(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Vessels(krpc_connection_t connection, krpc_list_object_t * returnValue) {
  krpc_call_t _call;
  krpc_argument_t _arguments[0];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "get_Vessels", 0, _arguments));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_list_object(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Camera(krpc_connection_t connection, krpc_SpaceCenter_Camera_t * returnValue) {
  krpc_call_t _call;
  krpc_argument_t _arguments[0];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "get_Camera", 0, _arguments));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_object(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_MaximumRailsWarpFactor(krpc_connection_t connection, int32_t * returnValue) {
  krpc_call_t _call;
  krpc_argument_t _arguments[0];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "get_MaximumRailsWarpFactor", 0, _arguments));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_int32(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_set_TargetVessel(krpc_connection_t connection, krpc_SpaceCenter_Vessel_t value) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "set_TargetVessel", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_object, &value));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Navball(krpc_connection_t connection, bool * returnValue) {
  krpc_call_t _call;
  krpc_argument_t _arguments[0];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "get_Navball", 0, _arguments));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_bool(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_set_UIVisible(krpc_connection_t connection, bool value) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "set_UIVisible", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_bool, &value));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_G(krpc_connection_t connection, double * returnValue) {
  krpc_call_t _call;
  krpc_argument_t _arguments[0];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "get_G", 0, _arguments));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_double(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_TargetVessel(krpc_connection_t connection, krpc_SpaceCenter_Vessel_t * returnValue) {
  krpc_call_t _call;
  krpc_argument_t _arguments[0];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "get_TargetVessel", 0, _arguments));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_object(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_set_TargetBody(krpc_connection_t connection, krpc_SpaceCenter_CelestialBody_t value) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "set_TargetBody", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_object, &value));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_WaypointManager(krpc_connection_t connection, krpc_SpaceCenter_WaypointManager_t * returnValue) {
  krpc_call_t _call;
  krpc_argument_t _arguments[0];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "get_WaypointManager", 0, _arguments));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_object(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_RailsWarpFactor(krpc_connection_t connection, int32_t * returnValue) {
  krpc_call_t _call;
  krpc_argument_t _arguments[0];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "get_RailsWarpFactor", 0, _arguments));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_int32(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_WarpMode(krpc_connection_t connection, krpc_SpaceCenter_WarpMode_t * returnValue) {
  krpc_call_t _call;
  krpc_argument_t _arguments[0];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "get_WarpMode", 0, _arguments));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_enum(&_stream, (int*)returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_set_RailsWarpFactor(krpc_connection_t connection, int32_t value) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "set_RailsWarpFactor", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_int32, &value));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_set_PhysicsWarpFactor(krpc_connection_t connection, int32_t value) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "set_PhysicsWarpFactor", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_int32, &value));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_TargetBody(krpc_connection_t connection, krpc_SpaceCenter_CelestialBody_t * returnValue) {
  krpc_call_t _call;
  krpc_argument_t _arguments[0];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "get_TargetBody", 0, _arguments));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_object(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Bodies(krpc_connection_t connection, krpc_dictionary_string_object_t * returnValue) {
  krpc_call_t _call;
  krpc_argument_t _arguments[0];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "get_Bodies", 0, _arguments));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_dictionary_string_object(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_set_Navball(krpc_connection_t connection, bool value) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "set_Navball", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_bool, &value));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_ActiveVessel(krpc_connection_t connection, krpc_SpaceCenter_Vessel_t * returnValue) {
  krpc_call_t _call;
  krpc_argument_t _arguments[0];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "get_ActiveVessel", 0, _arguments));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_object(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_UIVisible(krpc_connection_t connection, bool * returnValue) {
  krpc_call_t _call;
  krpc_argument_t _arguments[0];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "get_UIVisible", 0, _arguments));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_bool(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_FARAvailable(krpc_connection_t connection, bool * returnValue) {
  krpc_call_t _call;
  krpc_argument_t _arguments[0];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "get_FARAvailable", 0, _arguments));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_bool(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_UT(krpc_connection_t connection, double * returnValue) {
  krpc_call_t _call;
  krpc_argument_t _arguments[0];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "get_UT", 0, _arguments));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_double(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_ContractManager(krpc_connection_t connection, krpc_SpaceCenter_ContractManager_t * returnValue) {
  krpc_call_t _call;
  krpc_argument_t _arguments[0];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "get_ContractManager", 0, _arguments));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_object(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_TargetDockingPort(krpc_connection_t connection, krpc_SpaceCenter_DockingPort_t * returnValue) {
  krpc_call_t _call;
  krpc_argument_t _arguments[0];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "get_TargetDockingPort", 0, _arguments));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_object(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_set_ActiveVessel(krpc_connection_t connection, krpc_SpaceCenter_Vessel_t value) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "set_ActiveVessel", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_object, &value));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_PhysicsWarpFactor(krpc_connection_t connection, int32_t * returnValue) {
  krpc_call_t _call;
  krpc_argument_t _arguments[0];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "get_PhysicsWarpFactor", 0, _arguments));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_int32(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_set_TargetDockingPort(krpc_connection_t connection, krpc_SpaceCenter_DockingPort_t value) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "set_TargetDockingPort", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_object, &value));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_WarpRate(krpc_connection_t connection, float * returnValue) {
  krpc_call_t _call;
  krpc_argument_t _arguments[0];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "get_WarpRate", 0, _arguments));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_float(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Antenna_Cancel(krpc_connection_t connection, krpc_SpaceCenter_Antenna_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Antenna_Cancel", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Antenna_Transmit(krpc_connection_t connection, krpc_SpaceCenter_Antenna_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Antenna_Transmit", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Antenna_CanTransmit(krpc_connection_t connection, bool * returnValue, krpc_SpaceCenter_Antenna_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Antenna_get_CanTransmit", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_bool(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Antenna_Combinable(krpc_connection_t connection, bool * returnValue, krpc_SpaceCenter_Antenna_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Antenna_get_Combinable", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_bool(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Antenna_Power(krpc_connection_t connection, double * returnValue, krpc_SpaceCenter_Antenna_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Antenna_get_Power", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_double(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Antenna_set_Deployed(krpc_connection_t connection, krpc_SpaceCenter_Antenna_t instance, bool value) {
  krpc_call_t _call;
  krpc_argument_t _arguments[2];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Antenna_set_Deployed", 2, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  KRPC_CHECK(krpc_add_argument(&_call, 1, &krpc_encode_callback_bool, &value));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Antenna_set_AllowPartial(krpc_connection_t connection, krpc_SpaceCenter_Antenna_t instance, bool value) {
  krpc_call_t _call;
  krpc_argument_t _arguments[2];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Antenna_set_AllowPartial", 2, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  KRPC_CHECK(krpc_add_argument(&_call, 1, &krpc_encode_callback_bool, &value));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Antenna_CombinableExponent(krpc_connection_t connection, double * returnValue, krpc_SpaceCenter_Antenna_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Antenna_get_CombinableExponent", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_double(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Antenna_AllowPartial(krpc_connection_t connection, bool * returnValue, krpc_SpaceCenter_Antenna_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Antenna_get_AllowPartial", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_bool(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Antenna_Deployable(krpc_connection_t connection, bool * returnValue, krpc_SpaceCenter_Antenna_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Antenna_get_Deployable", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_bool(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Antenna_State(krpc_connection_t connection, krpc_SpaceCenter_AntennaState_t * returnValue, krpc_SpaceCenter_Antenna_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Antenna_get_State", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_enum(&_stream, (int*)returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Antenna_Part(krpc_connection_t connection, krpc_SpaceCenter_Part_t * returnValue, krpc_SpaceCenter_Antenna_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Antenna_get_Part", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_object(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Antenna_PacketInterval(krpc_connection_t connection, float * returnValue, krpc_SpaceCenter_Antenna_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Antenna_get_PacketInterval", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_float(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Antenna_PacketSize(krpc_connection_t connection, float * returnValue, krpc_SpaceCenter_Antenna_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Antenna_get_PacketSize", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_float(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Antenna_PacketResourceCost(krpc_connection_t connection, double * returnValue, krpc_SpaceCenter_Antenna_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Antenna_get_PacketResourceCost", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_double(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Antenna_Deployed(krpc_connection_t connection, bool * returnValue, krpc_SpaceCenter_Antenna_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Antenna_get_Deployed", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_bool(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_AutoPilot_Disengage(krpc_connection_t connection, krpc_SpaceCenter_AutoPilot_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "AutoPilot_Disengage", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_AutoPilot_Engage(krpc_connection_t connection, krpc_SpaceCenter_AutoPilot_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "AutoPilot_Engage", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_AutoPilot_TargetPitchAndHeading(krpc_connection_t connection, krpc_SpaceCenter_AutoPilot_t instance, float pitch, float heading) {
  krpc_call_t _call;
  krpc_argument_t _arguments[3];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "AutoPilot_TargetPitchAndHeading", 3, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  KRPC_CHECK(krpc_add_argument(&_call, 1, &krpc_encode_callback_float, &pitch));
  KRPC_CHECK(krpc_add_argument(&_call, 2, &krpc_encode_callback_float, &heading));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_AutoPilot_Wait(krpc_connection_t connection, krpc_SpaceCenter_AutoPilot_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "AutoPilot_Wait", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_AutoPilot_set_PitchPIDGains(krpc_connection_t connection, krpc_SpaceCenter_AutoPilot_t instance, const krpc_tuple_double_double_double_t * value) {
  krpc_call_t _call;
  krpc_argument_t _arguments[2];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "AutoPilot_set_PitchPIDGains", 2, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  KRPC_CHECK(krpc_add_argument(&_call, 1, &krpc_encode_callback_tuple_double_double_double, value));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_AutoPilot_set_AutoTune(krpc_connection_t connection, krpc_SpaceCenter_AutoPilot_t instance, bool value) {
  krpc_call_t _call;
  krpc_argument_t _arguments[2];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "AutoPilot_set_AutoTune", 2, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  KRPC_CHECK(krpc_add_argument(&_call, 1, &krpc_encode_callback_bool, &value));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_AutoPilot_TargetDirection(krpc_connection_t connection, krpc_tuple_double_double_double_t * returnValue, krpc_SpaceCenter_AutoPilot_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "AutoPilot_get_TargetDirection", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_tuple_double_double_double(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_AutoPilot_set_AttenuationAngle(krpc_connection_t connection, krpc_SpaceCenter_AutoPilot_t instance, const krpc_tuple_double_double_double_t * value) {
  krpc_call_t _call;
  krpc_argument_t _arguments[2];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "AutoPilot_set_AttenuationAngle", 2, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  KRPC_CHECK(krpc_add_argument(&_call, 1, &krpc_encode_callback_tuple_double_double_double, value));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_AutoPilot_set_StoppingTime(krpc_connection_t connection, krpc_SpaceCenter_AutoPilot_t instance, const krpc_tuple_double_double_double_t * value) {
  krpc_call_t _call;
  krpc_argument_t _arguments[2];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "AutoPilot_set_StoppingTime", 2, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  KRPC_CHECK(krpc_add_argument(&_call, 1, &krpc_encode_callback_tuple_double_double_double, value));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_AutoPilot_StoppingTime(krpc_connection_t connection, krpc_tuple_double_double_double_t * returnValue, krpc_SpaceCenter_AutoPilot_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "AutoPilot_get_StoppingTime", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_tuple_double_double_double(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_AutoPilot_set_ReferenceFrame(krpc_connection_t connection, krpc_SpaceCenter_AutoPilot_t instance, krpc_SpaceCenter_ReferenceFrame_t value) {
  krpc_call_t _call;
  krpc_argument_t _arguments[2];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "AutoPilot_set_ReferenceFrame", 2, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  KRPC_CHECK(krpc_add_argument(&_call, 1, &krpc_encode_callback_object, &value));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_AutoPilot_HeadingError(krpc_connection_t connection, float * returnValue, krpc_SpaceCenter_AutoPilot_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "AutoPilot_get_HeadingError", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_float(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_AutoPilot_TargetHeading(krpc_connection_t connection, float * returnValue, krpc_SpaceCenter_AutoPilot_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "AutoPilot_get_TargetHeading", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_float(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_AutoPilot_set_TargetRoll(krpc_connection_t connection, krpc_SpaceCenter_AutoPilot_t instance, float value) {
  krpc_call_t _call;
  krpc_argument_t _arguments[2];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "AutoPilot_set_TargetRoll", 2, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  KRPC_CHECK(krpc_add_argument(&_call, 1, &krpc_encode_callback_float, &value));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_AutoPilot_ReferenceFrame(krpc_connection_t connection, krpc_SpaceCenter_ReferenceFrame_t * returnValue, krpc_SpaceCenter_AutoPilot_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "AutoPilot_get_ReferenceFrame", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_object(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_AutoPilot_RollThreshold(krpc_connection_t connection, double * returnValue, krpc_SpaceCenter_AutoPilot_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "AutoPilot_get_RollThreshold", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_double(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_AutoPilot_set_RollPIDGains(krpc_connection_t connection, krpc_SpaceCenter_AutoPilot_t instance, const krpc_tuple_double_double_double_t * value) {
  krpc_call_t _call;
  krpc_argument_t _arguments[2];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "AutoPilot_set_RollPIDGains", 2, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  KRPC_CHECK(krpc_add_argument(&_call, 1, &krpc_encode_callback_tuple_double_double_double, value));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_AutoPilot_AutoTune(krpc_connection_t connection, bool * returnValue, krpc_SpaceCenter_AutoPilot_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "AutoPilot_get_AutoTune", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_bool(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_AutoPilot_SAS(krpc_connection_t connection, bool * returnValue, krpc_SpaceCenter_AutoPilot_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "AutoPilot_get_SAS", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_bool(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_AutoPilot_PitchError(krpc_connection_t connection, float * returnValue, krpc_SpaceCenter_AutoPilot_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "AutoPilot_get_PitchError", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_float(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_AutoPilot_SASMode(krpc_connection_t connection, krpc_SpaceCenter_SASMode_t * returnValue, krpc_SpaceCenter_AutoPilot_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "AutoPilot_get_SASMode", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_enum(&_stream, (int*)returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_AutoPilot_YawPIDGains(krpc_connection_t connection, krpc_tuple_double_double_double_t * returnValue, krpc_SpaceCenter_AutoPilot_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "AutoPilot_get_YawPIDGains", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_tuple_double_double_double(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_AutoPilot_TimeToPeak(krpc_connection_t connection, krpc_tuple_double_double_double_t * returnValue, krpc_SpaceCenter_AutoPilot_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "AutoPilot_get_TimeToPeak", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_tuple_double_double_double(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_AutoPilot_DecelerationTime(krpc_connection_t connection, krpc_tuple_double_double_double_t * returnValue, krpc_SpaceCenter_AutoPilot_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "AutoPilot_get_DecelerationTime", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_tuple_double_double_double(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_AutoPilot_RollPIDGains(krpc_connection_t connection, krpc_tuple_double_double_double_t * returnValue, krpc_SpaceCenter_AutoPilot_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "AutoPilot_get_RollPIDGains", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_tuple_double_double_double(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_AutoPilot_AttenuationAngle(krpc_connection_t connection, krpc_tuple_double_double_double_t * returnValue, krpc_SpaceCenter_AutoPilot_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "AutoPilot_get_AttenuationAngle", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_tuple_double_double_double(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_AutoPilot_set_TargetHeading(krpc_connection_t connection, krpc_SpaceCenter_AutoPilot_t instance, float value) {
  krpc_call_t _call;
  krpc_argument_t _arguments[2];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "AutoPilot_set_TargetHeading", 2, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  KRPC_CHECK(krpc_add_argument(&_call, 1, &krpc_encode_callback_float, &value));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_AutoPilot_set_TargetDirection(krpc_connection_t connection, krpc_SpaceCenter_AutoPilot_t instance, const krpc_tuple_double_double_double_t * value) {
  krpc_call_t _call;
  krpc_argument_t _arguments[2];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "AutoPilot_set_TargetDirection", 2, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  KRPC_CHECK(krpc_add_argument(&_call, 1, &krpc_encode_callback_tuple_double_double_double, value));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_AutoPilot_set_SASMode(krpc_connection_t connection, krpc_SpaceCenter_AutoPilot_t instance, krpc_SpaceCenter_SASMode_t value) {
  krpc_call_t _call;
  krpc_argument_t _arguments[2];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "AutoPilot_set_SASMode", 2, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  KRPC_CHECK(krpc_add_argument(&_call, 1, &krpc_encode_callback_enum, &value));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_AutoPilot_set_SAS(krpc_connection_t connection, krpc_SpaceCenter_AutoPilot_t instance, bool value) {
  krpc_call_t _call;
  krpc_argument_t _arguments[2];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "AutoPilot_set_SAS", 2, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  KRPC_CHECK(krpc_add_argument(&_call, 1, &krpc_encode_callback_bool, &value));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_AutoPilot_PitchPIDGains(krpc_connection_t connection, krpc_tuple_double_double_double_t * returnValue, krpc_SpaceCenter_AutoPilot_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "AutoPilot_get_PitchPIDGains", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_tuple_double_double_double(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_AutoPilot_Error(krpc_connection_t connection, float * returnValue, krpc_SpaceCenter_AutoPilot_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "AutoPilot_get_Error", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_float(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_AutoPilot_TargetPitch(krpc_connection_t connection, float * returnValue, krpc_SpaceCenter_AutoPilot_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "AutoPilot_get_TargetPitch", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_float(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_AutoPilot_TargetRoll(krpc_connection_t connection, float * returnValue, krpc_SpaceCenter_AutoPilot_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "AutoPilot_get_TargetRoll", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_float(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_AutoPilot_set_TimeToPeak(krpc_connection_t connection, krpc_SpaceCenter_AutoPilot_t instance, const krpc_tuple_double_double_double_t * value) {
  krpc_call_t _call;
  krpc_argument_t _arguments[2];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "AutoPilot_set_TimeToPeak", 2, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  KRPC_CHECK(krpc_add_argument(&_call, 1, &krpc_encode_callback_tuple_double_double_double, value));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_AutoPilot_Overshoot(krpc_connection_t connection, krpc_tuple_double_double_double_t * returnValue, krpc_SpaceCenter_AutoPilot_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "AutoPilot_get_Overshoot", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_tuple_double_double_double(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_AutoPilot_set_Overshoot(krpc_connection_t connection, krpc_SpaceCenter_AutoPilot_t instance, const krpc_tuple_double_double_double_t * value) {
  krpc_call_t _call;
  krpc_argument_t _arguments[2];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "AutoPilot_set_Overshoot", 2, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  KRPC_CHECK(krpc_add_argument(&_call, 1, &krpc_encode_callback_tuple_double_double_double, value));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_AutoPilot_set_TargetPitch(krpc_connection_t connection, krpc_SpaceCenter_AutoPilot_t instance, float value) {
  krpc_call_t _call;
  krpc_argument_t _arguments[2];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "AutoPilot_set_TargetPitch", 2, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  KRPC_CHECK(krpc_add_argument(&_call, 1, &krpc_encode_callback_float, &value));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_AutoPilot_RollError(krpc_connection_t connection, float * returnValue, krpc_SpaceCenter_AutoPilot_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "AutoPilot_get_RollError", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_float(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_AutoPilot_set_DecelerationTime(krpc_connection_t connection, krpc_SpaceCenter_AutoPilot_t instance, const krpc_tuple_double_double_double_t * value) {
  krpc_call_t _call;
  krpc_argument_t _arguments[2];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "AutoPilot_set_DecelerationTime", 2, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  KRPC_CHECK(krpc_add_argument(&_call, 1, &krpc_encode_callback_tuple_double_double_double, value));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_AutoPilot_set_YawPIDGains(krpc_connection_t connection, krpc_SpaceCenter_AutoPilot_t instance, const krpc_tuple_double_double_double_t * value) {
  krpc_call_t _call;
  krpc_argument_t _arguments[2];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "AutoPilot_set_YawPIDGains", 2, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  KRPC_CHECK(krpc_add_argument(&_call, 1, &krpc_encode_callback_tuple_double_double_double, value));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_AutoPilot_set_RollThreshold(krpc_connection_t connection, krpc_SpaceCenter_AutoPilot_t instance, double value) {
  krpc_call_t _call;
  krpc_argument_t _arguments[2];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "AutoPilot_set_RollThreshold", 2, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  KRPC_CHECK(krpc_add_argument(&_call, 1, &krpc_encode_callback_double, &value));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Camera_FocussedBody(krpc_connection_t connection, krpc_SpaceCenter_CelestialBody_t * returnValue, krpc_SpaceCenter_Camera_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Camera_get_FocussedBody", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_object(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Camera_DefaultDistance(krpc_connection_t connection, float * returnValue, krpc_SpaceCenter_Camera_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Camera_get_DefaultDistance", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_float(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Camera_set_Heading(krpc_connection_t connection, krpc_SpaceCenter_Camera_t instance, float value) {
  krpc_call_t _call;
  krpc_argument_t _arguments[2];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Camera_set_Heading", 2, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  KRPC_CHECK(krpc_add_argument(&_call, 1, &krpc_encode_callback_float, &value));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Camera_set_Mode(krpc_connection_t connection, krpc_SpaceCenter_Camera_t instance, krpc_SpaceCenter_CameraMode_t value) {
  krpc_call_t _call;
  krpc_argument_t _arguments[2];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Camera_set_Mode", 2, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  KRPC_CHECK(krpc_add_argument(&_call, 1, &krpc_encode_callback_enum, &value));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Camera_Distance(krpc_connection_t connection, float * returnValue, krpc_SpaceCenter_Camera_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Camera_get_Distance", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_float(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Camera_MaxPitch(krpc_connection_t connection, float * returnValue, krpc_SpaceCenter_Camera_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Camera_get_MaxPitch", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_float(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Camera_FocussedNode(krpc_connection_t connection, krpc_SpaceCenter_Node_t * returnValue, krpc_SpaceCenter_Camera_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Camera_get_FocussedNode", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_object(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Camera_set_Pitch(krpc_connection_t connection, krpc_SpaceCenter_Camera_t instance, float value) {
  krpc_call_t _call;
  krpc_argument_t _arguments[2];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Camera_set_Pitch", 2, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  KRPC_CHECK(krpc_add_argument(&_call, 1, &krpc_encode_callback_float, &value));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Camera_set_FocussedVessel(krpc_connection_t connection, krpc_SpaceCenter_Camera_t instance, krpc_SpaceCenter_Vessel_t value) {
  krpc_call_t _call;
  krpc_argument_t _arguments[2];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Camera_set_FocussedVessel", 2, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  KRPC_CHECK(krpc_add_argument(&_call, 1, &krpc_encode_callback_object, &value));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Camera_set_Distance(krpc_connection_t connection, krpc_SpaceCenter_Camera_t instance, float value) {
  krpc_call_t _call;
  krpc_argument_t _arguments[2];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Camera_set_Distance", 2, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  KRPC_CHECK(krpc_add_argument(&_call, 1, &krpc_encode_callback_float, &value));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Camera_set_FocussedBody(krpc_connection_t connection, krpc_SpaceCenter_Camera_t instance, krpc_SpaceCenter_CelestialBody_t value) {
  krpc_call_t _call;
  krpc_argument_t _arguments[2];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Camera_set_FocussedBody", 2, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  KRPC_CHECK(krpc_add_argument(&_call, 1, &krpc_encode_callback_object, &value));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Camera_Mode(krpc_connection_t connection, krpc_SpaceCenter_CameraMode_t * returnValue, krpc_SpaceCenter_Camera_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Camera_get_Mode", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_enum(&_stream, (int*)returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Camera_MinDistance(krpc_connection_t connection, float * returnValue, krpc_SpaceCenter_Camera_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Camera_get_MinDistance", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_float(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Camera_Pitch(krpc_connection_t connection, float * returnValue, krpc_SpaceCenter_Camera_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Camera_get_Pitch", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_float(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Camera_FocussedVessel(krpc_connection_t connection, krpc_SpaceCenter_Vessel_t * returnValue, krpc_SpaceCenter_Camera_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Camera_get_FocussedVessel", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_object(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Camera_set_FocussedNode(krpc_connection_t connection, krpc_SpaceCenter_Camera_t instance, krpc_SpaceCenter_Node_t value) {
  krpc_call_t _call;
  krpc_argument_t _arguments[2];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Camera_set_FocussedNode", 2, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  KRPC_CHECK(krpc_add_argument(&_call, 1, &krpc_encode_callback_object, &value));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Camera_MaxDistance(krpc_connection_t connection, float * returnValue, krpc_SpaceCenter_Camera_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Camera_get_MaxDistance", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_float(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Camera_Heading(krpc_connection_t connection, float * returnValue, krpc_SpaceCenter_Camera_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Camera_get_Heading", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_float(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Camera_MinPitch(krpc_connection_t connection, float * returnValue, krpc_SpaceCenter_Camera_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Camera_get_MinPitch", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_float(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_CargoBay_State(krpc_connection_t connection, krpc_SpaceCenter_CargoBayState_t * returnValue, krpc_SpaceCenter_CargoBay_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "CargoBay_get_State", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_enum(&_stream, (int*)returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_CargoBay_set_Open(krpc_connection_t connection, krpc_SpaceCenter_CargoBay_t instance, bool value) {
  krpc_call_t _call;
  krpc_argument_t _arguments[2];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "CargoBay_set_Open", 2, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  KRPC_CHECK(krpc_add_argument(&_call, 1, &krpc_encode_callback_bool, &value));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_CargoBay_Open(krpc_connection_t connection, bool * returnValue, krpc_SpaceCenter_CargoBay_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "CargoBay_get_Open", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_bool(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_CargoBay_Part(krpc_connection_t connection, krpc_SpaceCenter_Part_t * returnValue, krpc_SpaceCenter_CargoBay_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "CargoBay_get_Part", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_object(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_CelestialBody_AltitudeAtPosition(krpc_connection_t connection, double * returnValue, krpc_SpaceCenter_CelestialBody_t instance, const krpc_tuple_double_double_double_t * position, krpc_SpaceCenter_ReferenceFrame_t referenceFrame) {
  krpc_call_t _call;
  krpc_argument_t _arguments[3];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "CelestialBody_AltitudeAtPosition", 3, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  KRPC_CHECK(krpc_add_argument(&_call, 1, &krpc_encode_callback_tuple_double_double_double, position));
  KRPC_CHECK(krpc_add_argument(&_call, 2, &krpc_encode_callback_object, &referenceFrame));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_double(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_CelestialBody_AngularVelocity(krpc_connection_t connection, krpc_tuple_double_double_double_t * returnValue, krpc_SpaceCenter_CelestialBody_t instance, krpc_SpaceCenter_ReferenceFrame_t referenceFrame) {
  krpc_call_t _call;
  krpc_argument_t _arguments[2];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "CelestialBody_AngularVelocity", 2, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  KRPC_CHECK(krpc_add_argument(&_call, 1, &krpc_encode_callback_object, &referenceFrame));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_tuple_double_double_double(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_CelestialBody_AtmosphericDensityAtPosition(krpc_connection_t connection, double * returnValue, krpc_SpaceCenter_CelestialBody_t instance, const krpc_tuple_double_double_double_t * position, krpc_SpaceCenter_ReferenceFrame_t referenceFrame) {
  krpc_call_t _call;
  krpc_argument_t _arguments[3];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "CelestialBody_AtmosphericDensityAtPosition", 3, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  KRPC_CHECK(krpc_add_argument(&_call, 1, &krpc_encode_callback_tuple_double_double_double, position));
  KRPC_CHECK(krpc_add_argument(&_call, 2, &krpc_encode_callback_object, &referenceFrame));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_double(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_CelestialBody_BedrockHeight(krpc_connection_t connection, double * returnValue, krpc_SpaceCenter_CelestialBody_t instance, double latitude, double longitude) {
  krpc_call_t _call;
  krpc_argument_t _arguments[3];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "CelestialBody_BedrockHeight", 3, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  KRPC_CHECK(krpc_add_argument(&_call, 1, &krpc_encode_callback_double, &latitude));
  KRPC_CHECK(krpc_add_argument(&_call, 2, &krpc_encode_callback_double, &longitude));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_double(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_CelestialBody_BedrockPosition(krpc_connection_t connection, krpc_tuple_double_double_double_t * returnValue, krpc_SpaceCenter_CelestialBody_t instance, double latitude, double longitude, krpc_SpaceCenter_ReferenceFrame_t referenceFrame) {
  krpc_call_t _call;
  krpc_argument_t _arguments[4];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "CelestialBody_BedrockPosition", 4, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  KRPC_CHECK(krpc_add_argument(&_call, 1, &krpc_encode_callback_double, &latitude));
  KRPC_CHECK(krpc_add_argument(&_call, 2, &krpc_encode_callback_double, &longitude));
  KRPC_CHECK(krpc_add_argument(&_call, 3, &krpc_encode_callback_object, &referenceFrame));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_tuple_double_double_double(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_CelestialBody_BiomeAt(krpc_connection_t connection, char * * returnValue, krpc_SpaceCenter_CelestialBody_t instance, double latitude, double longitude) {
  krpc_call_t _call;
  krpc_argument_t _arguments[3];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "CelestialBody_BiomeAt", 3, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  KRPC_CHECK(krpc_add_argument(&_call, 1, &krpc_encode_callback_double, &latitude));
  KRPC_CHECK(krpc_add_argument(&_call, 2, &krpc_encode_callback_double, &longitude));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_string(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_CelestialBody_DensityAt(krpc_connection_t connection, double * returnValue, krpc_SpaceCenter_CelestialBody_t instance, double altitude) {
  krpc_call_t _call;
  krpc_argument_t _arguments[2];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "CelestialBody_DensityAt", 2, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  KRPC_CHECK(krpc_add_argument(&_call, 1, &krpc_encode_callback_double, &altitude));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_double(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_CelestialBody_Direction(krpc_connection_t connection, krpc_tuple_double_double_double_t * returnValue, krpc_SpaceCenter_CelestialBody_t instance, krpc_SpaceCenter_ReferenceFrame_t referenceFrame) {
  krpc_call_t _call;
  krpc_argument_t _arguments[2];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "CelestialBody_Direction", 2, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  KRPC_CHECK(krpc_add_argument(&_call, 1, &krpc_encode_callback_object, &referenceFrame));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_tuple_double_double_double(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_CelestialBody_LatitudeAtPosition(krpc_connection_t connection, double * returnValue, krpc_SpaceCenter_CelestialBody_t instance, const krpc_tuple_double_double_double_t * position, krpc_SpaceCenter_ReferenceFrame_t referenceFrame) {
  krpc_call_t _call;
  krpc_argument_t _arguments[3];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "CelestialBody_LatitudeAtPosition", 3, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  KRPC_CHECK(krpc_add_argument(&_call, 1, &krpc_encode_callback_tuple_double_double_double, position));
  KRPC_CHECK(krpc_add_argument(&_call, 2, &krpc_encode_callback_object, &referenceFrame));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_double(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_CelestialBody_LongitudeAtPosition(krpc_connection_t connection, double * returnValue, krpc_SpaceCenter_CelestialBody_t instance, const krpc_tuple_double_double_double_t * position, krpc_SpaceCenter_ReferenceFrame_t referenceFrame) {
  krpc_call_t _call;
  krpc_argument_t _arguments[3];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "CelestialBody_LongitudeAtPosition", 3, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  KRPC_CHECK(krpc_add_argument(&_call, 1, &krpc_encode_callback_tuple_double_double_double, position));
  KRPC_CHECK(krpc_add_argument(&_call, 2, &krpc_encode_callback_object, &referenceFrame));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_double(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_CelestialBody_MSLPosition(krpc_connection_t connection, krpc_tuple_double_double_double_t * returnValue, krpc_SpaceCenter_CelestialBody_t instance, double latitude, double longitude, krpc_SpaceCenter_ReferenceFrame_t referenceFrame) {
  krpc_call_t _call;
  krpc_argument_t _arguments[4];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "CelestialBody_MSLPosition", 4, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  KRPC_CHECK(krpc_add_argument(&_call, 1, &krpc_encode_callback_double, &latitude));
  KRPC_CHECK(krpc_add_argument(&_call, 2, &krpc_encode_callback_double, &longitude));
  KRPC_CHECK(krpc_add_argument(&_call, 3, &krpc_encode_callback_object, &referenceFrame));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_tuple_double_double_double(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_CelestialBody_Position(krpc_connection_t connection, krpc_tuple_double_double_double_t * returnValue, krpc_SpaceCenter_CelestialBody_t instance, krpc_SpaceCenter_ReferenceFrame_t referenceFrame) {
  krpc_call_t _call;
  krpc_argument_t _arguments[2];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "CelestialBody_Position", 2, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  KRPC_CHECK(krpc_add_argument(&_call, 1, &krpc_encode_callback_object, &referenceFrame));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_tuple_double_double_double(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_CelestialBody_PositionAtAltitude(krpc_connection_t connection, krpc_tuple_double_double_double_t * returnValue, krpc_SpaceCenter_CelestialBody_t instance, double latitude, double longitude, double altitude, krpc_SpaceCenter_ReferenceFrame_t referenceFrame) {
  krpc_call_t _call;
  krpc_argument_t _arguments[5];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "CelestialBody_PositionAtAltitude", 5, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  KRPC_CHECK(krpc_add_argument(&_call, 1, &krpc_encode_callback_double, &latitude));
  KRPC_CHECK(krpc_add_argument(&_call, 2, &krpc_encode_callback_double, &longitude));
  KRPC_CHECK(krpc_add_argument(&_call, 3, &krpc_encode_callback_double, &altitude));
  KRPC_CHECK(krpc_add_argument(&_call, 4, &krpc_encode_callback_object, &referenceFrame));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_tuple_double_double_double(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_CelestialBody_PressureAt(krpc_connection_t connection, double * returnValue, krpc_SpaceCenter_CelestialBody_t instance, double altitude) {
  krpc_call_t _call;
  krpc_argument_t _arguments[2];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "CelestialBody_PressureAt", 2, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  KRPC_CHECK(krpc_add_argument(&_call, 1, &krpc_encode_callback_double, &altitude));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_double(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_CelestialBody_Rotation(krpc_connection_t connection, krpc_tuple_double_double_double_double_t * returnValue, krpc_SpaceCenter_CelestialBody_t instance, krpc_SpaceCenter_ReferenceFrame_t referenceFrame) {
  krpc_call_t _call;
  krpc_argument_t _arguments[2];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "CelestialBody_Rotation", 2, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  KRPC_CHECK(krpc_add_argument(&_call, 1, &krpc_encode_callback_object, &referenceFrame));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_tuple_double_double_double_double(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_CelestialBody_SurfaceHeight(krpc_connection_t connection, double * returnValue, krpc_SpaceCenter_CelestialBody_t instance, double latitude, double longitude) {
  krpc_call_t _call;
  krpc_argument_t _arguments[3];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "CelestialBody_SurfaceHeight", 3, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  KRPC_CHECK(krpc_add_argument(&_call, 1, &krpc_encode_callback_double, &latitude));
  KRPC_CHECK(krpc_add_argument(&_call, 2, &krpc_encode_callback_double, &longitude));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_double(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_CelestialBody_SurfacePosition(krpc_connection_t connection, krpc_tuple_double_double_double_t * returnValue, krpc_SpaceCenter_CelestialBody_t instance, double latitude, double longitude, krpc_SpaceCenter_ReferenceFrame_t referenceFrame) {
  krpc_call_t _call;
  krpc_argument_t _arguments[4];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "CelestialBody_SurfacePosition", 4, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  KRPC_CHECK(krpc_add_argument(&_call, 1, &krpc_encode_callback_double, &latitude));
  KRPC_CHECK(krpc_add_argument(&_call, 2, &krpc_encode_callback_double, &longitude));
  KRPC_CHECK(krpc_add_argument(&_call, 3, &krpc_encode_callback_object, &referenceFrame));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_tuple_double_double_double(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_CelestialBody_TemperatureAt(krpc_connection_t connection, double * returnValue, krpc_SpaceCenter_CelestialBody_t instance, const krpc_tuple_double_double_double_t * position, krpc_SpaceCenter_ReferenceFrame_t referenceFrame) {
  krpc_call_t _call;
  krpc_argument_t _arguments[3];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "CelestialBody_TemperatureAt", 3, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  KRPC_CHECK(krpc_add_argument(&_call, 1, &krpc_encode_callback_tuple_double_double_double, position));
  KRPC_CHECK(krpc_add_argument(&_call, 2, &krpc_encode_callback_object, &referenceFrame));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_double(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_CelestialBody_Velocity(krpc_connection_t connection, krpc_tuple_double_double_double_t * returnValue, krpc_SpaceCenter_CelestialBody_t instance, krpc_SpaceCenter_ReferenceFrame_t referenceFrame) {
  krpc_call_t _call;
  krpc_argument_t _arguments[2];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "CelestialBody_Velocity", 2, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  KRPC_CHECK(krpc_add_argument(&_call, 1, &krpc_encode_callback_object, &referenceFrame));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_tuple_double_double_double(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_CelestialBody_ReferenceFrame(krpc_connection_t connection, krpc_SpaceCenter_ReferenceFrame_t * returnValue, krpc_SpaceCenter_CelestialBody_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "CelestialBody_get_ReferenceFrame", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_object(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_CelestialBody_Name(krpc_connection_t connection, char * * returnValue, krpc_SpaceCenter_CelestialBody_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "CelestialBody_get_Name", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_string(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_CelestialBody_NonRotatingReferenceFrame(krpc_connection_t connection, krpc_SpaceCenter_ReferenceFrame_t * returnValue, krpc_SpaceCenter_CelestialBody_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "CelestialBody_get_NonRotatingReferenceFrame", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_object(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_CelestialBody_SpaceHighAltitudeThreshold(krpc_connection_t connection, float * returnValue, krpc_SpaceCenter_CelestialBody_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "CelestialBody_get_SpaceHighAltitudeThreshold", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_float(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_CelestialBody_InitialRotation(krpc_connection_t connection, double * returnValue, krpc_SpaceCenter_CelestialBody_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "CelestialBody_get_InitialRotation", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_double(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_CelestialBody_SphereOfInfluence(krpc_connection_t connection, float * returnValue, krpc_SpaceCenter_CelestialBody_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "CelestialBody_get_SphereOfInfluence", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_float(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_CelestialBody_Orbit(krpc_connection_t connection, krpc_SpaceCenter_Orbit_t * returnValue, krpc_SpaceCenter_CelestialBody_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "CelestialBody_get_Orbit", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_object(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_CelestialBody_RotationalSpeed(krpc_connection_t connection, float * returnValue, krpc_SpaceCenter_CelestialBody_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "CelestialBody_get_RotationalSpeed", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_float(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_CelestialBody_AtmosphereDepth(krpc_connection_t connection, float * returnValue, krpc_SpaceCenter_CelestialBody_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "CelestialBody_get_AtmosphereDepth", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_float(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_CelestialBody_RotationalPeriod(krpc_connection_t connection, float * returnValue, krpc_SpaceCenter_CelestialBody_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "CelestialBody_get_RotationalPeriod", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_float(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_CelestialBody_RotationAngle(krpc_connection_t connection, double * returnValue, krpc_SpaceCenter_CelestialBody_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "CelestialBody_get_RotationAngle", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_double(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_CelestialBody_Mass(krpc_connection_t connection, float * returnValue, krpc_SpaceCenter_CelestialBody_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "CelestialBody_get_Mass", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_float(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_CelestialBody_EquatorialRadius(krpc_connection_t connection, float * returnValue, krpc_SpaceCenter_CelestialBody_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "CelestialBody_get_EquatorialRadius", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_float(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_CelestialBody_GravitationalParameter(krpc_connection_t connection, float * returnValue, krpc_SpaceCenter_CelestialBody_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "CelestialBody_get_GravitationalParameter", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_float(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_CelestialBody_Satellites(krpc_connection_t connection, krpc_list_object_t * returnValue, krpc_SpaceCenter_CelestialBody_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "CelestialBody_get_Satellites", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_list_object(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_CelestialBody_Biomes(krpc_connection_t connection, krpc_set_string_t * returnValue, krpc_SpaceCenter_CelestialBody_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "CelestialBody_get_Biomes", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_set_string(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_CelestialBody_FlyingHighAltitudeThreshold(krpc_connection_t connection, float * returnValue, krpc_SpaceCenter_CelestialBody_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "CelestialBody_get_FlyingHighAltitudeThreshold", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_float(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_CelestialBody_OrbitalReferenceFrame(krpc_connection_t connection, krpc_SpaceCenter_ReferenceFrame_t * returnValue, krpc_SpaceCenter_CelestialBody_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "CelestialBody_get_OrbitalReferenceFrame", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_object(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_CelestialBody_HasAtmosphere(krpc_connection_t connection, bool * returnValue, krpc_SpaceCenter_CelestialBody_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "CelestialBody_get_HasAtmosphere", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_bool(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_CelestialBody_SurfaceGravity(krpc_connection_t connection, float * returnValue, krpc_SpaceCenter_CelestialBody_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "CelestialBody_get_SurfaceGravity", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_float(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_CelestialBody_HasAtmosphericOxygen(krpc_connection_t connection, bool * returnValue, krpc_SpaceCenter_CelestialBody_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "CelestialBody_get_HasAtmosphericOxygen", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_bool(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_CommLink_SignalStrength(krpc_connection_t connection, double * returnValue, krpc_SpaceCenter_CommLink_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "CommLink_get_SignalStrength", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_double(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_CommLink_Type(krpc_connection_t connection, krpc_SpaceCenter_CommLinkType_t * returnValue, krpc_SpaceCenter_CommLink_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "CommLink_get_Type", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_enum(&_stream, (int*)returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_CommLink_End(krpc_connection_t connection, krpc_SpaceCenter_CommNode_t * returnValue, krpc_SpaceCenter_CommLink_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "CommLink_get_End", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_object(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_CommLink_Start(krpc_connection_t connection, krpc_SpaceCenter_CommNode_t * returnValue, krpc_SpaceCenter_CommLink_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "CommLink_get_Start", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_object(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_CommNode_Vessel(krpc_connection_t connection, krpc_SpaceCenter_Vessel_t * returnValue, krpc_SpaceCenter_CommNode_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "CommNode_get_Vessel", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_object(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_CommNode_IsHome(krpc_connection_t connection, bool * returnValue, krpc_SpaceCenter_CommNode_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "CommNode_get_IsHome", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_bool(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_CommNode_IsControlPoint(krpc_connection_t connection, bool * returnValue, krpc_SpaceCenter_CommNode_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "CommNode_get_IsControlPoint", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_bool(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_CommNode_IsVessel(krpc_connection_t connection, bool * returnValue, krpc_SpaceCenter_CommNode_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "CommNode_get_IsVessel", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_bool(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_CommNode_Name(krpc_connection_t connection, char * * returnValue, krpc_SpaceCenter_CommNode_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "CommNode_get_Name", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_string(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Comms_SignalStrength(krpc_connection_t connection, double * returnValue, krpc_SpaceCenter_Comms_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Comms_get_SignalStrength", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_double(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Comms_Power(krpc_connection_t connection, double * returnValue, krpc_SpaceCenter_Comms_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Comms_get_Power", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_double(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Comms_CanCommunicate(krpc_connection_t connection, bool * returnValue, krpc_SpaceCenter_Comms_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Comms_get_CanCommunicate", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_bool(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Comms_SignalDelay(krpc_connection_t connection, double * returnValue, krpc_SpaceCenter_Comms_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Comms_get_SignalDelay", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_double(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Comms_CanTransmitScience(krpc_connection_t connection, bool * returnValue, krpc_SpaceCenter_Comms_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Comms_get_CanTransmitScience", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_bool(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Comms_ControlPath(krpc_connection_t connection, krpc_list_object_t * returnValue, krpc_SpaceCenter_Comms_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Comms_get_ControlPath", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_list_object(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Contract_Accept(krpc_connection_t connection, krpc_SpaceCenter_Contract_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Contract_Accept", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Contract_Cancel(krpc_connection_t connection, krpc_SpaceCenter_Contract_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Contract_Cancel", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Contract_Decline(krpc_connection_t connection, krpc_SpaceCenter_Contract_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Contract_Decline", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Contract_FundsCompletion(krpc_connection_t connection, double * returnValue, krpc_SpaceCenter_Contract_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Contract_get_FundsCompletion", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_double(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Contract_ReputationCompletion(krpc_connection_t connection, double * returnValue, krpc_SpaceCenter_Contract_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Contract_get_ReputationCompletion", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_double(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Contract_Description(krpc_connection_t connection, char * * returnValue, krpc_SpaceCenter_Contract_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Contract_get_Description", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_string(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Contract_FundsAdvance(krpc_connection_t connection, double * returnValue, krpc_SpaceCenter_Contract_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Contract_get_FundsAdvance", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_double(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Contract_ScienceCompletion(krpc_connection_t connection, double * returnValue, krpc_SpaceCenter_Contract_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Contract_get_ScienceCompletion", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_double(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Contract_Read(krpc_connection_t connection, bool * returnValue, krpc_SpaceCenter_Contract_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Contract_get_Read", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_bool(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Contract_Notes(krpc_connection_t connection, char * * returnValue, krpc_SpaceCenter_Contract_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Contract_get_Notes", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_string(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Contract_Title(krpc_connection_t connection, char * * returnValue, krpc_SpaceCenter_Contract_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Contract_get_Title", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_string(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Contract_Synopsis(krpc_connection_t connection, char * * returnValue, krpc_SpaceCenter_Contract_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Contract_get_Synopsis", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_string(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Contract_CanBeCanceled(krpc_connection_t connection, bool * returnValue, krpc_SpaceCenter_Contract_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Contract_get_CanBeCanceled", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_bool(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Contract_Parameters(krpc_connection_t connection, krpc_list_object_t * returnValue, krpc_SpaceCenter_Contract_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Contract_get_Parameters", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_list_object(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Contract_Failed(krpc_connection_t connection, bool * returnValue, krpc_SpaceCenter_Contract_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Contract_get_Failed", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_bool(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Contract_FundsFailure(krpc_connection_t connection, double * returnValue, krpc_SpaceCenter_Contract_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Contract_get_FundsFailure", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_double(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Contract_ReputationFailure(krpc_connection_t connection, double * returnValue, krpc_SpaceCenter_Contract_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Contract_get_ReputationFailure", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_double(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Contract_Keywords(krpc_connection_t connection, krpc_list_string_t * returnValue, krpc_SpaceCenter_Contract_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Contract_get_Keywords", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_list_string(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Contract_CanBeDeclined(krpc_connection_t connection, bool * returnValue, krpc_SpaceCenter_Contract_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Contract_get_CanBeDeclined", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_bool(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Contract_Active(krpc_connection_t connection, bool * returnValue, krpc_SpaceCenter_Contract_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Contract_get_Active", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_bool(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Contract_Seen(krpc_connection_t connection, bool * returnValue, krpc_SpaceCenter_Contract_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Contract_get_Seen", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_bool(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Contract_Type(krpc_connection_t connection, char * * returnValue, krpc_SpaceCenter_Contract_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Contract_get_Type", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_string(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Contract_State(krpc_connection_t connection, krpc_SpaceCenter_ContractState_t * returnValue, krpc_SpaceCenter_Contract_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Contract_get_State", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_enum(&_stream, (int*)returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Contract_CanBeFailed(krpc_connection_t connection, bool * returnValue, krpc_SpaceCenter_Contract_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Contract_get_CanBeFailed", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_bool(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_ContractManager_OfferedContracts(krpc_connection_t connection, krpc_list_object_t * returnValue, krpc_SpaceCenter_ContractManager_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "ContractManager_get_OfferedContracts", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_list_object(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_ContractManager_CompletedContracts(krpc_connection_t connection, krpc_list_object_t * returnValue, krpc_SpaceCenter_ContractManager_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "ContractManager_get_CompletedContracts", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_list_object(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_ContractManager_AllContracts(krpc_connection_t connection, krpc_list_object_t * returnValue, krpc_SpaceCenter_ContractManager_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "ContractManager_get_AllContracts", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_list_object(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_ContractManager_ActiveContracts(krpc_connection_t connection, krpc_list_object_t * returnValue, krpc_SpaceCenter_ContractManager_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "ContractManager_get_ActiveContracts", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_list_object(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_ContractManager_Types(krpc_connection_t connection, krpc_set_string_t * returnValue, krpc_SpaceCenter_ContractManager_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "ContractManager_get_Types", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_set_string(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_ContractManager_FailedContracts(krpc_connection_t connection, krpc_list_object_t * returnValue, krpc_SpaceCenter_ContractManager_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "ContractManager_get_FailedContracts", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_list_object(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_ContractParameter_FundsCompletion(krpc_connection_t connection, double * returnValue, krpc_SpaceCenter_ContractParameter_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "ContractParameter_get_FundsCompletion", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_double(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_ContractParameter_ReputationCompletion(krpc_connection_t connection, double * returnValue, krpc_SpaceCenter_ContractParameter_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "ContractParameter_get_ReputationCompletion", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_double(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_ContractParameter_FundsFailure(krpc_connection_t connection, double * returnValue, krpc_SpaceCenter_ContractParameter_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "ContractParameter_get_FundsFailure", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_double(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_ContractParameter_ScienceCompletion(krpc_connection_t connection, double * returnValue, krpc_SpaceCenter_ContractParameter_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "ContractParameter_get_ScienceCompletion", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_double(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_ContractParameter_ReputationFailure(krpc_connection_t connection, double * returnValue, krpc_SpaceCenter_ContractParameter_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "ContractParameter_get_ReputationFailure", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_double(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_ContractParameter_Completed(krpc_connection_t connection, bool * returnValue, krpc_SpaceCenter_ContractParameter_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "ContractParameter_get_Completed", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_bool(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_ContractParameter_Title(krpc_connection_t connection, char * * returnValue, krpc_SpaceCenter_ContractParameter_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "ContractParameter_get_Title", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_string(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_ContractParameter_Children(krpc_connection_t connection, krpc_list_object_t * returnValue, krpc_SpaceCenter_ContractParameter_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "ContractParameter_get_Children", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_list_object(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_ContractParameter_Failed(krpc_connection_t connection, bool * returnValue, krpc_SpaceCenter_ContractParameter_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "ContractParameter_get_Failed", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_bool(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_ContractParameter_Optional(krpc_connection_t connection, bool * returnValue, krpc_SpaceCenter_ContractParameter_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "ContractParameter_get_Optional", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_bool(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_ContractParameter_Notes(krpc_connection_t connection, char * * returnValue, krpc_SpaceCenter_ContractParameter_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "ContractParameter_get_Notes", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_string(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Control_ActivateNextStage(krpc_connection_t connection, krpc_list_object_t * returnValue, krpc_SpaceCenter_Control_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Control_ActivateNextStage", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_list_object(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Control_AddNode(krpc_connection_t connection, krpc_SpaceCenter_Node_t * returnValue, krpc_SpaceCenter_Control_t instance, double ut, float prograde, float normal, float radial) {
  krpc_call_t _call;
  krpc_argument_t _arguments[5];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Control_AddNode", 5, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  KRPC_CHECK(krpc_add_argument(&_call, 1, &krpc_encode_callback_double, &ut));
  KRPC_CHECK(krpc_add_argument(&_call, 2, &krpc_encode_callback_float, &prograde));
  KRPC_CHECK(krpc_add_argument(&_call, 3, &krpc_encode_callback_float, &normal));
  KRPC_CHECK(krpc_add_argument(&_call, 4, &krpc_encode_callback_float, &radial));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_object(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Control_GetActionGroup(krpc_connection_t connection, bool * returnValue, krpc_SpaceCenter_Control_t instance, uint32_t group) {
  krpc_call_t _call;
  krpc_argument_t _arguments[2];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Control_GetActionGroup", 2, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  KRPC_CHECK(krpc_add_argument(&_call, 1, &krpc_encode_callback_uint32, &group));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_bool(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Control_RemoveNodes(krpc_connection_t connection, krpc_SpaceCenter_Control_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Control_RemoveNodes", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Control_SetActionGroup(krpc_connection_t connection, krpc_SpaceCenter_Control_t instance, uint32_t group, bool state) {
  krpc_call_t _call;
  krpc_argument_t _arguments[3];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Control_SetActionGroup", 3, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  KRPC_CHECK(krpc_add_argument(&_call, 1, &krpc_encode_callback_uint32, &group));
  KRPC_CHECK(krpc_add_argument(&_call, 2, &krpc_encode_callback_bool, &state));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Control_ToggleActionGroup(krpc_connection_t connection, krpc_SpaceCenter_Control_t instance, uint32_t group) {
  krpc_call_t _call;
  krpc_argument_t _arguments[2];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Control_ToggleActionGroup", 2, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  KRPC_CHECK(krpc_add_argument(&_call, 1, &krpc_encode_callback_uint32, &group));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Control_set_Brakes(krpc_connection_t connection, krpc_SpaceCenter_Control_t instance, bool value) {
  krpc_call_t _call;
  krpc_argument_t _arguments[2];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Control_set_Brakes", 2, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  KRPC_CHECK(krpc_add_argument(&_call, 1, &krpc_encode_callback_bool, &value));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Control_set_Intakes(krpc_connection_t connection, krpc_SpaceCenter_Control_t instance, bool value) {
  krpc_call_t _call;
  krpc_argument_t _arguments[2];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Control_set_Intakes", 2, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  KRPC_CHECK(krpc_add_argument(&_call, 1, &krpc_encode_callback_bool, &value));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Control_set_Right(krpc_connection_t connection, krpc_SpaceCenter_Control_t instance, float value) {
  krpc_call_t _call;
  krpc_argument_t _arguments[2];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Control_set_Right", 2, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  KRPC_CHECK(krpc_add_argument(&_call, 1, &krpc_encode_callback_float, &value));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Control_Yaw(krpc_connection_t connection, float * returnValue, krpc_SpaceCenter_Control_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Control_get_Yaw", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_float(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Control_set_Wheels(krpc_connection_t connection, krpc_SpaceCenter_Control_t instance, bool value) {
  krpc_call_t _call;
  krpc_argument_t _arguments[2];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Control_set_Wheels", 2, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  KRPC_CHECK(krpc_add_argument(&_call, 1, &krpc_encode_callback_bool, &value));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Control_RCS(krpc_connection_t connection, bool * returnValue, krpc_SpaceCenter_Control_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Control_get_RCS", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_bool(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Control_Lights(krpc_connection_t connection, bool * returnValue, krpc_SpaceCenter_Control_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Control_get_Lights", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_bool(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Control_State(krpc_connection_t connection, krpc_SpaceCenter_ControlState_t * returnValue, krpc_SpaceCenter_Control_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Control_get_State", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_enum(&_stream, (int*)returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Control_set_SpeedMode(krpc_connection_t connection, krpc_SpaceCenter_Control_t instance, krpc_SpaceCenter_SpeedMode_t value) {
  krpc_call_t _call;
  krpc_argument_t _arguments[2];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Control_set_SpeedMode", 2, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  KRPC_CHECK(krpc_add_argument(&_call, 1, &krpc_encode_callback_enum, &value));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Control_WheelThrottle(krpc_connection_t connection, float * returnValue, krpc_SpaceCenter_Control_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Control_get_WheelThrottle", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_float(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Control_ResourceHarvesters(krpc_connection_t connection, bool * returnValue, krpc_SpaceCenter_Control_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Control_get_ResourceHarvesters", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_bool(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Control_Forward(krpc_connection_t connection, float * returnValue, krpc_SpaceCenter_Control_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Control_get_Forward", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_float(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Control_set_WheelThrottle(krpc_connection_t connection, krpc_SpaceCenter_Control_t instance, float value) {
  krpc_call_t _call;
  krpc_argument_t _arguments[2];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Control_set_WheelThrottle", 2, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  KRPC_CHECK(krpc_add_argument(&_call, 1, &krpc_encode_callback_float, &value));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Control_set_Gear(krpc_connection_t connection, krpc_SpaceCenter_Control_t instance, bool value) {
  krpc_call_t _call;
  krpc_argument_t _arguments[2];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Control_set_Gear", 2, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  KRPC_CHECK(krpc_add_argument(&_call, 1, &krpc_encode_callback_bool, &value));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Control_Legs(krpc_connection_t connection, bool * returnValue, krpc_SpaceCenter_Control_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Control_get_Legs", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_bool(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Control_Nodes(krpc_connection_t connection, krpc_list_object_t * returnValue, krpc_SpaceCenter_Control_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Control_get_Nodes", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_list_object(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Control_set_CargoBays(krpc_connection_t connection, krpc_SpaceCenter_Control_t instance, bool value) {
  krpc_call_t _call;
  krpc_argument_t _arguments[2];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Control_set_CargoBays", 2, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  KRPC_CHECK(krpc_add_argument(&_call, 1, &krpc_encode_callback_bool, &value));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Control_Gear(krpc_connection_t connection, bool * returnValue, krpc_SpaceCenter_Control_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Control_get_Gear", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_bool(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Control_SAS(krpc_connection_t connection, bool * returnValue, krpc_SpaceCenter_Control_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Control_get_SAS", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_bool(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Control_set_ResourceHarvesters(krpc_connection_t connection, krpc_SpaceCenter_Control_t instance, bool value) {
  krpc_call_t _call;
  krpc_argument_t _arguments[2];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Control_set_ResourceHarvesters", 2, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  KRPC_CHECK(krpc_add_argument(&_call, 1, &krpc_encode_callback_bool, &value));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Control_WheelSteering(krpc_connection_t connection, float * returnValue, krpc_SpaceCenter_Control_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Control_get_WheelSteering", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_float(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Control_Wheels(krpc_connection_t connection, bool * returnValue, krpc_SpaceCenter_Control_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Control_get_Wheels", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_bool(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Control_set_Radiators(krpc_connection_t connection, krpc_SpaceCenter_Control_t instance, bool value) {
  krpc_call_t _call;
  krpc_argument_t _arguments[2];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Control_set_Radiators", 2, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  KRPC_CHECK(krpc_add_argument(&_call, 1, &krpc_encode_callback_bool, &value));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Control_Roll(krpc_connection_t connection, float * returnValue, krpc_SpaceCenter_Control_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Control_get_Roll", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_float(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Control_set_ResourceHarvestersActive(krpc_connection_t connection, krpc_SpaceCenter_Control_t instance, bool value) {
  krpc_call_t _call;
  krpc_argument_t _arguments[2];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Control_set_ResourceHarvestersActive", 2, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  KRPC_CHECK(krpc_add_argument(&_call, 1, &krpc_encode_callback_bool, &value));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Control_CargoBays(krpc_connection_t connection, bool * returnValue, krpc_SpaceCenter_Control_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Control_get_CargoBays", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_bool(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Control_ResourceHarvestersActive(krpc_connection_t connection, bool * returnValue, krpc_SpaceCenter_Control_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Control_get_ResourceHarvestersActive", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_bool(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Control_InputMode(krpc_connection_t connection, krpc_SpaceCenter_ControlInputMode_t * returnValue, krpc_SpaceCenter_Control_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Control_get_InputMode", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_enum(&_stream, (int*)returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Control_set_RCS(krpc_connection_t connection, krpc_SpaceCenter_Control_t instance, bool value) {
  krpc_call_t _call;
  krpc_argument_t _arguments[2];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Control_set_RCS", 2, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  KRPC_CHECK(krpc_add_argument(&_call, 1, &krpc_encode_callback_bool, &value));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Control_Antennas(krpc_connection_t connection, bool * returnValue, krpc_SpaceCenter_Control_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Control_get_Antennas", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_bool(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Control_set_Throttle(krpc_connection_t connection, krpc_SpaceCenter_Control_t instance, float value) {
  krpc_call_t _call;
  krpc_argument_t _arguments[2];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Control_set_Throttle", 2, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  KRPC_CHECK(krpc_add_argument(&_call, 1, &krpc_encode_callback_float, &value));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Control_SASMode(krpc_connection_t connection, krpc_SpaceCenter_SASMode_t * returnValue, krpc_SpaceCenter_Control_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Control_get_SASMode", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_enum(&_stream, (int*)returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Control_SpeedMode(krpc_connection_t connection, krpc_SpaceCenter_SpeedMode_t * returnValue, krpc_SpaceCenter_Control_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Control_get_SpeedMode", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_enum(&_stream, (int*)returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Control_set_SolarPanels(krpc_connection_t connection, krpc_SpaceCenter_Control_t instance, bool value) {
  krpc_call_t _call;
  krpc_argument_t _arguments[2];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Control_set_SolarPanels", 2, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  KRPC_CHECK(krpc_add_argument(&_call, 1, &krpc_encode_callback_bool, &value));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Control_set_Abort(krpc_connection_t connection, krpc_SpaceCenter_Control_t instance, bool value) {
  krpc_call_t _call;
  krpc_argument_t _arguments[2];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Control_set_Abort", 2, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  KRPC_CHECK(krpc_add_argument(&_call, 1, &krpc_encode_callback_bool, &value));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Control_Throttle(krpc_connection_t connection, float * returnValue, krpc_SpaceCenter_Control_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Control_get_Throttle", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_float(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Control_set_ReactionWheels(krpc_connection_t connection, krpc_SpaceCenter_Control_t instance, bool value) {
  krpc_call_t _call;
  krpc_argument_t _arguments[2];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Control_set_ReactionWheels", 2, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  KRPC_CHECK(krpc_add_argument(&_call, 1, &krpc_encode_callback_bool, &value));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Control_set_Parachutes(krpc_connection_t connection, krpc_SpaceCenter_Control_t instance, bool value) {
  krpc_call_t _call;
  krpc_argument_t _arguments[2];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Control_set_Parachutes", 2, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  KRPC_CHECK(krpc_add_argument(&_call, 1, &krpc_encode_callback_bool, &value));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Control_set_Pitch(krpc_connection_t connection, krpc_SpaceCenter_Control_t instance, float value) {
  krpc_call_t _call;
  krpc_argument_t _arguments[2];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Control_set_Pitch", 2, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  KRPC_CHECK(krpc_add_argument(&_call, 1, &krpc_encode_callback_float, &value));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Control_set_Yaw(krpc_connection_t connection, krpc_SpaceCenter_Control_t instance, float value) {
  krpc_call_t _call;
  krpc_argument_t _arguments[2];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Control_set_Yaw", 2, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  KRPC_CHECK(krpc_add_argument(&_call, 1, &krpc_encode_callback_float, &value));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Control_set_Forward(krpc_connection_t connection, krpc_SpaceCenter_Control_t instance, float value) {
  krpc_call_t _call;
  krpc_argument_t _arguments[2];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Control_set_Forward", 2, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  KRPC_CHECK(krpc_add_argument(&_call, 1, &krpc_encode_callback_float, &value));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Control_Up(krpc_connection_t connection, float * returnValue, krpc_SpaceCenter_Control_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Control_get_Up", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_float(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Control_Intakes(krpc_connection_t connection, bool * returnValue, krpc_SpaceCenter_Control_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Control_get_Intakes", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_bool(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Control_Parachutes(krpc_connection_t connection, bool * returnValue, krpc_SpaceCenter_Control_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Control_get_Parachutes", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_bool(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Control_Right(krpc_connection_t connection, float * returnValue, krpc_SpaceCenter_Control_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Control_get_Right", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_float(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Control_set_Legs(krpc_connection_t connection, krpc_SpaceCenter_Control_t instance, bool value) {
  krpc_call_t _call;
  krpc_argument_t _arguments[2];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Control_set_Legs", 2, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  KRPC_CHECK(krpc_add_argument(&_call, 1, &krpc_encode_callback_bool, &value));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Control_set_SAS(krpc_connection_t connection, krpc_SpaceCenter_Control_t instance, bool value) {
  krpc_call_t _call;
  krpc_argument_t _arguments[2];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Control_set_SAS", 2, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  KRPC_CHECK(krpc_add_argument(&_call, 1, &krpc_encode_callback_bool, &value));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Control_set_Roll(krpc_connection_t connection, krpc_SpaceCenter_Control_t instance, float value) {
  krpc_call_t _call;
  krpc_argument_t _arguments[2];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Control_set_Roll", 2, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  KRPC_CHECK(krpc_add_argument(&_call, 1, &krpc_encode_callback_float, &value));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Control_set_Lights(krpc_connection_t connection, krpc_SpaceCenter_Control_t instance, bool value) {
  krpc_call_t _call;
  krpc_argument_t _arguments[2];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Control_set_Lights", 2, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  KRPC_CHECK(krpc_add_argument(&_call, 1, &krpc_encode_callback_bool, &value));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Control_CurrentStage(krpc_connection_t connection, int32_t * returnValue, krpc_SpaceCenter_Control_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Control_get_CurrentStage", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_int32(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Control_Brakes(krpc_connection_t connection, bool * returnValue, krpc_SpaceCenter_Control_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Control_get_Brakes", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_bool(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Control_set_Antennas(krpc_connection_t connection, krpc_SpaceCenter_Control_t instance, bool value) {
  krpc_call_t _call;
  krpc_argument_t _arguments[2];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Control_set_Antennas", 2, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  KRPC_CHECK(krpc_add_argument(&_call, 1, &krpc_encode_callback_bool, &value));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Control_Source(krpc_connection_t connection, krpc_SpaceCenter_ControlSource_t * returnValue, krpc_SpaceCenter_Control_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Control_get_Source", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_enum(&_stream, (int*)returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Control_set_InputMode(krpc_connection_t connection, krpc_SpaceCenter_Control_t instance, krpc_SpaceCenter_ControlInputMode_t value) {
  krpc_call_t _call;
  krpc_argument_t _arguments[2];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Control_set_InputMode", 2, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  KRPC_CHECK(krpc_add_argument(&_call, 1, &krpc_encode_callback_enum, &value));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Control_ReactionWheels(krpc_connection_t connection, bool * returnValue, krpc_SpaceCenter_Control_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Control_get_ReactionWheels", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_bool(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Control_set_Up(krpc_connection_t connection, krpc_SpaceCenter_Control_t instance, float value) {
  krpc_call_t _call;
  krpc_argument_t _arguments[2];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Control_set_Up", 2, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  KRPC_CHECK(krpc_add_argument(&_call, 1, &krpc_encode_callback_float, &value));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Control_Radiators(krpc_connection_t connection, bool * returnValue, krpc_SpaceCenter_Control_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Control_get_Radiators", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_bool(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Control_SolarPanels(krpc_connection_t connection, bool * returnValue, krpc_SpaceCenter_Control_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Control_get_SolarPanels", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_bool(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Control_set_WheelSteering(krpc_connection_t connection, krpc_SpaceCenter_Control_t instance, float value) {
  krpc_call_t _call;
  krpc_argument_t _arguments[2];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Control_set_WheelSteering", 2, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  KRPC_CHECK(krpc_add_argument(&_call, 1, &krpc_encode_callback_float, &value));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Control_Abort(krpc_connection_t connection, bool * returnValue, krpc_SpaceCenter_Control_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Control_get_Abort", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_bool(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Control_Pitch(krpc_connection_t connection, float * returnValue, krpc_SpaceCenter_Control_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Control_get_Pitch", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_float(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Control_set_SASMode(krpc_connection_t connection, krpc_SpaceCenter_Control_t instance, krpc_SpaceCenter_SASMode_t value) {
  krpc_call_t _call;
  krpc_argument_t _arguments[2];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Control_set_SASMode", 2, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  KRPC_CHECK(krpc_add_argument(&_call, 1, &krpc_encode_callback_enum, &value));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_ControlSurface_AuthorityLimiter(krpc_connection_t connection, float * returnValue, krpc_SpaceCenter_ControlSurface_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "ControlSurface_get_AuthorityLimiter", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_float(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_ControlSurface_set_Deployed(krpc_connection_t connection, krpc_SpaceCenter_ControlSurface_t instance, bool value) {
  krpc_call_t _call;
  krpc_argument_t _arguments[2];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "ControlSurface_set_Deployed", 2, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  KRPC_CHECK(krpc_add_argument(&_call, 1, &krpc_encode_callback_bool, &value));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_ControlSurface_RollEnabled(krpc_connection_t connection, bool * returnValue, krpc_SpaceCenter_ControlSurface_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "ControlSurface_get_RollEnabled", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_bool(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_ControlSurface_set_Inverted(krpc_connection_t connection, krpc_SpaceCenter_ControlSurface_t instance, bool value) {
  krpc_call_t _call;
  krpc_argument_t _arguments[2];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "ControlSurface_set_Inverted", 2, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  KRPC_CHECK(krpc_add_argument(&_call, 1, &krpc_encode_callback_bool, &value));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_ControlSurface_PitchEnabled(krpc_connection_t connection, bool * returnValue, krpc_SpaceCenter_ControlSurface_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "ControlSurface_get_PitchEnabled", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_bool(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_ControlSurface_set_AuthorityLimiter(krpc_connection_t connection, krpc_SpaceCenter_ControlSurface_t instance, float value) {
  krpc_call_t _call;
  krpc_argument_t _arguments[2];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "ControlSurface_set_AuthorityLimiter", 2, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  KRPC_CHECK(krpc_add_argument(&_call, 1, &krpc_encode_callback_float, &value));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_ControlSurface_Inverted(krpc_connection_t connection, bool * returnValue, krpc_SpaceCenter_ControlSurface_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "ControlSurface_get_Inverted", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_bool(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_ControlSurface_Part(krpc_connection_t connection, krpc_SpaceCenter_Part_t * returnValue, krpc_SpaceCenter_ControlSurface_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "ControlSurface_get_Part", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_object(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_ControlSurface_set_RollEnabled(krpc_connection_t connection, krpc_SpaceCenter_ControlSurface_t instance, bool value) {
  krpc_call_t _call;
  krpc_argument_t _arguments[2];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "ControlSurface_set_RollEnabled", 2, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  KRPC_CHECK(krpc_add_argument(&_call, 1, &krpc_encode_callback_bool, &value));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_ControlSurface_set_PitchEnabled(krpc_connection_t connection, krpc_SpaceCenter_ControlSurface_t instance, bool value) {
  krpc_call_t _call;
  krpc_argument_t _arguments[2];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "ControlSurface_set_PitchEnabled", 2, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  KRPC_CHECK(krpc_add_argument(&_call, 1, &krpc_encode_callback_bool, &value));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_ControlSurface_SurfaceArea(krpc_connection_t connection, float * returnValue, krpc_SpaceCenter_ControlSurface_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "ControlSurface_get_SurfaceArea", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_float(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_ControlSurface_YawEnabled(krpc_connection_t connection, bool * returnValue, krpc_SpaceCenter_ControlSurface_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "ControlSurface_get_YawEnabled", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_bool(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_ControlSurface_AvailableTorque(krpc_connection_t connection, krpc_tuple_tuple_double_double_double_tuple_double_double_double_t * returnValue, krpc_SpaceCenter_ControlSurface_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "ControlSurface_get_AvailableTorque", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_tuple_tuple_double_double_double_tuple_double_double_double(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_ControlSurface_Deployed(krpc_connection_t connection, bool * returnValue, krpc_SpaceCenter_ControlSurface_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "ControlSurface_get_Deployed", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_bool(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_ControlSurface_set_YawEnabled(krpc_connection_t connection, krpc_SpaceCenter_ControlSurface_t instance, bool value) {
  krpc_call_t _call;
  krpc_argument_t _arguments[2];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "ControlSurface_set_YawEnabled", 2, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  KRPC_CHECK(krpc_add_argument(&_call, 1, &krpc_encode_callback_bool, &value));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_CrewMember_set_Stupidity(krpc_connection_t connection, krpc_SpaceCenter_CrewMember_t instance, float value) {
  krpc_call_t _call;
  krpc_argument_t _arguments[2];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "CrewMember_set_Stupidity", 2, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  KRPC_CHECK(krpc_add_argument(&_call, 1, &krpc_encode_callback_float, &value));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_CrewMember_set_Name(krpc_connection_t connection, krpc_SpaceCenter_CrewMember_t instance, const char * value) {
  krpc_call_t _call;
  krpc_argument_t _arguments[2];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "CrewMember_set_Name", 2, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  KRPC_CHECK(krpc_add_argument(&_call, 1, &krpc_encode_callback_string, &value));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_CrewMember_set_Experience(krpc_connection_t connection, krpc_SpaceCenter_CrewMember_t instance, float value) {
  krpc_call_t _call;
  krpc_argument_t _arguments[2];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "CrewMember_set_Experience", 2, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  KRPC_CHECK(krpc_add_argument(&_call, 1, &krpc_encode_callback_float, &value));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_CrewMember_OnMission(krpc_connection_t connection, bool * returnValue, krpc_SpaceCenter_CrewMember_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "CrewMember_get_OnMission", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_bool(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_CrewMember_Veteran(krpc_connection_t connection, bool * returnValue, krpc_SpaceCenter_CrewMember_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "CrewMember_get_Veteran", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_bool(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_CrewMember_Experience(krpc_connection_t connection, float * returnValue, krpc_SpaceCenter_CrewMember_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "CrewMember_get_Experience", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_float(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_CrewMember_Stupidity(krpc_connection_t connection, float * returnValue, krpc_SpaceCenter_CrewMember_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "CrewMember_get_Stupidity", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_float(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_CrewMember_Courage(krpc_connection_t connection, float * returnValue, krpc_SpaceCenter_CrewMember_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "CrewMember_get_Courage", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_float(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_CrewMember_set_Courage(krpc_connection_t connection, krpc_SpaceCenter_CrewMember_t instance, float value) {
  krpc_call_t _call;
  krpc_argument_t _arguments[2];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "CrewMember_set_Courage", 2, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  KRPC_CHECK(krpc_add_argument(&_call, 1, &krpc_encode_callback_float, &value));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_CrewMember_set_Badass(krpc_connection_t connection, krpc_SpaceCenter_CrewMember_t instance, bool value) {
  krpc_call_t _call;
  krpc_argument_t _arguments[2];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "CrewMember_set_Badass", 2, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  KRPC_CHECK(krpc_add_argument(&_call, 1, &krpc_encode_callback_bool, &value));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_CrewMember_Badass(krpc_connection_t connection, bool * returnValue, krpc_SpaceCenter_CrewMember_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "CrewMember_get_Badass", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_bool(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_CrewMember_set_Veteran(krpc_connection_t connection, krpc_SpaceCenter_CrewMember_t instance, bool value) {
  krpc_call_t _call;
  krpc_argument_t _arguments[2];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "CrewMember_set_Veteran", 2, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  KRPC_CHECK(krpc_add_argument(&_call, 1, &krpc_encode_callback_bool, &value));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_CrewMember_Type(krpc_connection_t connection, krpc_SpaceCenter_CrewMemberType_t * returnValue, krpc_SpaceCenter_CrewMember_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "CrewMember_get_Type", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_enum(&_stream, (int*)returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_CrewMember_Name(krpc_connection_t connection, char * * returnValue, krpc_SpaceCenter_CrewMember_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "CrewMember_get_Name", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_string(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Decoupler_Decouple(krpc_connection_t connection, krpc_SpaceCenter_Vessel_t * returnValue, krpc_SpaceCenter_Decoupler_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Decoupler_Decouple", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_object(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Decoupler_Part(krpc_connection_t connection, krpc_SpaceCenter_Part_t * returnValue, krpc_SpaceCenter_Decoupler_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Decoupler_get_Part", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_object(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Decoupler_Staged(krpc_connection_t connection, bool * returnValue, krpc_SpaceCenter_Decoupler_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Decoupler_get_Staged", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_bool(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Decoupler_Impulse(krpc_connection_t connection, float * returnValue, krpc_SpaceCenter_Decoupler_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Decoupler_get_Impulse", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_float(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Decoupler_Decoupled(krpc_connection_t connection, bool * returnValue, krpc_SpaceCenter_Decoupler_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Decoupler_get_Decoupled", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_bool(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_DockingPort_Direction(krpc_connection_t connection, krpc_tuple_double_double_double_t * returnValue, krpc_SpaceCenter_DockingPort_t instance, krpc_SpaceCenter_ReferenceFrame_t referenceFrame) {
  krpc_call_t _call;
  krpc_argument_t _arguments[2];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "DockingPort_Direction", 2, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  KRPC_CHECK(krpc_add_argument(&_call, 1, &krpc_encode_callback_object, &referenceFrame));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_tuple_double_double_double(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_DockingPort_Position(krpc_connection_t connection, krpc_tuple_double_double_double_t * returnValue, krpc_SpaceCenter_DockingPort_t instance, krpc_SpaceCenter_ReferenceFrame_t referenceFrame) {
  krpc_call_t _call;
  krpc_argument_t _arguments[2];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "DockingPort_Position", 2, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  KRPC_CHECK(krpc_add_argument(&_call, 1, &krpc_encode_callback_object, &referenceFrame));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_tuple_double_double_double(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_DockingPort_Rotation(krpc_connection_t connection, krpc_tuple_double_double_double_double_t * returnValue, krpc_SpaceCenter_DockingPort_t instance, krpc_SpaceCenter_ReferenceFrame_t referenceFrame) {
  krpc_call_t _call;
  krpc_argument_t _arguments[2];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "DockingPort_Rotation", 2, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  KRPC_CHECK(krpc_add_argument(&_call, 1, &krpc_encode_callback_object, &referenceFrame));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_tuple_double_double_double_double(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_DockingPort_Undock(krpc_connection_t connection, krpc_SpaceCenter_Vessel_t * returnValue, krpc_SpaceCenter_DockingPort_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "DockingPort_Undock", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_object(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_DockingPort_HasShield(krpc_connection_t connection, bool * returnValue, krpc_SpaceCenter_DockingPort_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "DockingPort_get_HasShield", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_bool(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_DockingPort_ReferenceFrame(krpc_connection_t connection, krpc_SpaceCenter_ReferenceFrame_t * returnValue, krpc_SpaceCenter_DockingPort_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "DockingPort_get_ReferenceFrame", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_object(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_DockingPort_DockedPart(krpc_connection_t connection, krpc_SpaceCenter_Part_t * returnValue, krpc_SpaceCenter_DockingPort_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "DockingPort_get_DockedPart", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_object(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_DockingPort_Shielded(krpc_connection_t connection, bool * returnValue, krpc_SpaceCenter_DockingPort_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "DockingPort_get_Shielded", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_bool(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_DockingPort_set_Shielded(krpc_connection_t connection, krpc_SpaceCenter_DockingPort_t instance, bool value) {
  krpc_call_t _call;
  krpc_argument_t _arguments[2];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "DockingPort_set_Shielded", 2, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  KRPC_CHECK(krpc_add_argument(&_call, 1, &krpc_encode_callback_bool, &value));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_DockingPort_State(krpc_connection_t connection, krpc_SpaceCenter_DockingPortState_t * returnValue, krpc_SpaceCenter_DockingPort_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "DockingPort_get_State", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_enum(&_stream, (int*)returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_DockingPort_Part(krpc_connection_t connection, krpc_SpaceCenter_Part_t * returnValue, krpc_SpaceCenter_DockingPort_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "DockingPort_get_Part", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_object(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_DockingPort_ReengageDistance(krpc_connection_t connection, float * returnValue, krpc_SpaceCenter_DockingPort_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "DockingPort_get_ReengageDistance", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_float(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Engine_ToggleMode(krpc_connection_t connection, krpc_SpaceCenter_Engine_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Engine_ToggleMode", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Engine_HasModes(krpc_connection_t connection, bool * returnValue, krpc_SpaceCenter_Engine_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Engine_get_HasModes", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_bool(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Engine_MaxVacuumThrust(krpc_connection_t connection, float * returnValue, krpc_SpaceCenter_Engine_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Engine_get_MaxVacuumThrust", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_float(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Engine_set_Mode(krpc_connection_t connection, krpc_SpaceCenter_Engine_t instance, const char * value) {
  krpc_call_t _call;
  krpc_argument_t _arguments[2];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Engine_set_Mode", 2, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  KRPC_CHECK(krpc_add_argument(&_call, 1, &krpc_encode_callback_string, &value));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Engine_CanShutdown(krpc_connection_t connection, bool * returnValue, krpc_SpaceCenter_Engine_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Engine_get_CanShutdown", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_bool(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Engine_ThrustLimit(krpc_connection_t connection, float * returnValue, krpc_SpaceCenter_Engine_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Engine_get_ThrustLimit", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_float(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Engine_Throttle(krpc_connection_t connection, float * returnValue, krpc_SpaceCenter_Engine_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Engine_get_Throttle", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_float(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Engine_AutoModeSwitch(krpc_connection_t connection, bool * returnValue, krpc_SpaceCenter_Engine_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Engine_get_AutoModeSwitch", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_bool(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Engine_VacuumSpecificImpulse(krpc_connection_t connection, float * returnValue, krpc_SpaceCenter_Engine_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Engine_get_VacuumSpecificImpulse", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_float(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Engine_AvailableTorque(krpc_connection_t connection, krpc_tuple_tuple_double_double_double_tuple_double_double_double_t * returnValue, krpc_SpaceCenter_Engine_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Engine_get_AvailableTorque", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_tuple_tuple_double_double_double_tuple_double_double_double(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Engine_MaxThrust(krpc_connection_t connection, float * returnValue, krpc_SpaceCenter_Engine_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Engine_get_MaxThrust", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_float(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Engine_PropellantRatios(krpc_connection_t connection, krpc_dictionary_string_float_t * returnValue, krpc_SpaceCenter_Engine_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Engine_get_PropellantRatios", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_dictionary_string_float(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Engine_Part(krpc_connection_t connection, krpc_SpaceCenter_Part_t * returnValue, krpc_SpaceCenter_Engine_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Engine_get_Part", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_object(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Engine_Thrusters(krpc_connection_t connection, krpc_list_object_t * returnValue, krpc_SpaceCenter_Engine_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Engine_get_Thrusters", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_list_object(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Engine_Active(krpc_connection_t connection, bool * returnValue, krpc_SpaceCenter_Engine_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Engine_get_Active", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_bool(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Engine_set_AutoModeSwitch(krpc_connection_t connection, krpc_SpaceCenter_Engine_t instance, bool value) {
  krpc_call_t _call;
  krpc_argument_t _arguments[2];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Engine_set_AutoModeSwitch", 2, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  KRPC_CHECK(krpc_add_argument(&_call, 1, &krpc_encode_callback_bool, &value));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Engine_CanRestart(krpc_connection_t connection, bool * returnValue, krpc_SpaceCenter_Engine_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Engine_get_CanRestart", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_bool(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Engine_HasFuel(krpc_connection_t connection, bool * returnValue, krpc_SpaceCenter_Engine_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Engine_get_HasFuel", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_bool(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Engine_AvailableThrust(krpc_connection_t connection, float * returnValue, krpc_SpaceCenter_Engine_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Engine_get_AvailableThrust", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_float(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Engine_Modes(krpc_connection_t connection, krpc_dictionary_string_object_t * returnValue, krpc_SpaceCenter_Engine_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Engine_get_Modes", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_dictionary_string_object(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Engine_set_Active(krpc_connection_t connection, krpc_SpaceCenter_Engine_t instance, bool value) {
  krpc_call_t _call;
  krpc_argument_t _arguments[2];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Engine_set_Active", 2, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  KRPC_CHECK(krpc_add_argument(&_call, 1, &krpc_encode_callback_bool, &value));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Engine_GimbalLimit(krpc_connection_t connection, float * returnValue, krpc_SpaceCenter_Engine_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Engine_get_GimbalLimit", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_float(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Engine_Thrust(krpc_connection_t connection, float * returnValue, krpc_SpaceCenter_Engine_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Engine_get_Thrust", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_float(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Engine_set_GimbalLimit(krpc_connection_t connection, krpc_SpaceCenter_Engine_t instance, float value) {
  krpc_call_t _call;
  krpc_argument_t _arguments[2];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Engine_set_GimbalLimit", 2, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  KRPC_CHECK(krpc_add_argument(&_call, 1, &krpc_encode_callback_float, &value));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Engine_KerbinSeaLevelSpecificImpulse(krpc_connection_t connection, float * returnValue, krpc_SpaceCenter_Engine_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Engine_get_KerbinSeaLevelSpecificImpulse", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_float(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Engine_PropellantNames(krpc_connection_t connection, krpc_list_string_t * returnValue, krpc_SpaceCenter_Engine_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Engine_get_PropellantNames", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_list_string(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Engine_Gimballed(krpc_connection_t connection, bool * returnValue, krpc_SpaceCenter_Engine_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Engine_get_Gimballed", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_bool(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Engine_set_GimbalLocked(krpc_connection_t connection, krpc_SpaceCenter_Engine_t instance, bool value) {
  krpc_call_t _call;
  krpc_argument_t _arguments[2];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Engine_set_GimbalLocked", 2, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  KRPC_CHECK(krpc_add_argument(&_call, 1, &krpc_encode_callback_bool, &value));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Engine_ThrottleLocked(krpc_connection_t connection, bool * returnValue, krpc_SpaceCenter_Engine_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Engine_get_ThrottleLocked", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_bool(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Engine_SpecificImpulse(krpc_connection_t connection, float * returnValue, krpc_SpaceCenter_Engine_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Engine_get_SpecificImpulse", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_float(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Engine_GimbalRange(krpc_connection_t connection, float * returnValue, krpc_SpaceCenter_Engine_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Engine_get_GimbalRange", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_float(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Engine_Propellants(krpc_connection_t connection, krpc_list_object_t * returnValue, krpc_SpaceCenter_Engine_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Engine_get_Propellants", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_list_object(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Engine_GimbalLocked(krpc_connection_t connection, bool * returnValue, krpc_SpaceCenter_Engine_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Engine_get_GimbalLocked", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_bool(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Engine_set_ThrustLimit(krpc_connection_t connection, krpc_SpaceCenter_Engine_t instance, float value) {
  krpc_call_t _call;
  krpc_argument_t _arguments[2];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Engine_set_ThrustLimit", 2, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  KRPC_CHECK(krpc_add_argument(&_call, 1, &krpc_encode_callback_float, &value));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Engine_Mode(krpc_connection_t connection, char * * returnValue, krpc_SpaceCenter_Engine_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Engine_get_Mode", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_string(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Experiment_Dump(krpc_connection_t connection, krpc_SpaceCenter_Experiment_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Experiment_Dump", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Experiment_Reset(krpc_connection_t connection, krpc_SpaceCenter_Experiment_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Experiment_Reset", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Experiment_Run(krpc_connection_t connection, krpc_SpaceCenter_Experiment_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Experiment_Run", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Experiment_Transmit(krpc_connection_t connection, krpc_SpaceCenter_Experiment_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Experiment_Transmit", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Experiment_Available(krpc_connection_t connection, bool * returnValue, krpc_SpaceCenter_Experiment_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Experiment_get_Available", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_bool(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Experiment_Biome(krpc_connection_t connection, char * * returnValue, krpc_SpaceCenter_Experiment_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Experiment_get_Biome", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_string(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Experiment_ScienceSubject(krpc_connection_t connection, krpc_SpaceCenter_ScienceSubject_t * returnValue, krpc_SpaceCenter_Experiment_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Experiment_get_ScienceSubject", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_object(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Experiment_Inoperable(krpc_connection_t connection, bool * returnValue, krpc_SpaceCenter_Experiment_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Experiment_get_Inoperable", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_bool(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Experiment_Part(krpc_connection_t connection, krpc_SpaceCenter_Part_t * returnValue, krpc_SpaceCenter_Experiment_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Experiment_get_Part", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_object(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Experiment_HasData(krpc_connection_t connection, bool * returnValue, krpc_SpaceCenter_Experiment_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Experiment_get_HasData", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_bool(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Experiment_Rerunnable(krpc_connection_t connection, bool * returnValue, krpc_SpaceCenter_Experiment_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Experiment_get_Rerunnable", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_bool(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Experiment_Data(krpc_connection_t connection, krpc_list_object_t * returnValue, krpc_SpaceCenter_Experiment_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Experiment_get_Data", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_list_object(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Experiment_Deployed(krpc_connection_t connection, bool * returnValue, krpc_SpaceCenter_Experiment_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Experiment_get_Deployed", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_bool(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Fairing_Jettison(krpc_connection_t connection, krpc_SpaceCenter_Fairing_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Fairing_Jettison", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Fairing_Part(krpc_connection_t connection, krpc_SpaceCenter_Part_t * returnValue, krpc_SpaceCenter_Fairing_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Fairing_get_Part", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_object(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Fairing_Jettisoned(krpc_connection_t connection, bool * returnValue, krpc_SpaceCenter_Fairing_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Fairing_get_Jettisoned", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_bool(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Flight_SimulateAerodynamicForceAt(krpc_connection_t connection, krpc_tuple_double_double_double_t * returnValue, krpc_SpaceCenter_Flight_t instance, krpc_SpaceCenter_CelestialBody_t body, const krpc_tuple_double_double_double_t * position, const krpc_tuple_double_double_double_t * velocity) {
  krpc_call_t _call;
  krpc_argument_t _arguments[4];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Flight_SimulateAerodynamicForceAt", 4, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  KRPC_CHECK(krpc_add_argument(&_call, 1, &krpc_encode_callback_object, &body));
  KRPC_CHECK(krpc_add_argument(&_call, 2, &krpc_encode_callback_tuple_double_double_double, position));
  KRPC_CHECK(krpc_add_argument(&_call, 3, &krpc_encode_callback_tuple_double_double_double, velocity));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_tuple_double_double_double(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Flight_Rotation(krpc_connection_t connection, krpc_tuple_double_double_double_double_t * returnValue, krpc_SpaceCenter_Flight_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Flight_get_Rotation", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_tuple_double_double_double_double(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Flight_HorizontalSpeed(krpc_connection_t connection, double * returnValue, krpc_SpaceCenter_Flight_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Flight_get_HorizontalSpeed", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_double(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Flight_DragCoefficient(krpc_connection_t connection, float * returnValue, krpc_SpaceCenter_Flight_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Flight_get_DragCoefficient", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_float(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Flight_AngleOfAttack(krpc_connection_t connection, float * returnValue, krpc_SpaceCenter_Flight_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Flight_get_AngleOfAttack", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_float(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Flight_TotalAirTemperature(krpc_connection_t connection, float * returnValue, krpc_SpaceCenter_Flight_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Flight_get_TotalAirTemperature", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_float(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Flight_ReynoldsNumber(krpc_connection_t connection, float * returnValue, krpc_SpaceCenter_Flight_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Flight_get_ReynoldsNumber", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_float(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Flight_SpeedOfSound(krpc_connection_t connection, float * returnValue, krpc_SpaceCenter_Flight_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Flight_get_SpeedOfSound", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_float(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Flight_Radial(krpc_connection_t connection, krpc_tuple_double_double_double_t * returnValue, krpc_SpaceCenter_Flight_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Flight_get_Radial", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_tuple_double_double_double(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Flight_Velocity(krpc_connection_t connection, krpc_tuple_double_double_double_t * returnValue, krpc_SpaceCenter_Flight_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Flight_get_Velocity", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_tuple_double_double_double(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Flight_Latitude(krpc_connection_t connection, double * returnValue, krpc_SpaceCenter_Flight_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Flight_get_Latitude", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_double(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Flight_TerminalVelocity(krpc_connection_t connection, float * returnValue, krpc_SpaceCenter_Flight_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Flight_get_TerminalVelocity", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_float(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Flight_Roll(krpc_connection_t connection, float * returnValue, krpc_SpaceCenter_Flight_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Flight_get_Roll", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_float(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Flight_Direction(krpc_connection_t connection, krpc_tuple_double_double_double_t * returnValue, krpc_SpaceCenter_Flight_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Flight_get_Direction", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_tuple_double_double_double(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Flight_Elevation(krpc_connection_t connection, double * returnValue, krpc_SpaceCenter_Flight_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Flight_get_Elevation", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_double(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Flight_StallFraction(krpc_connection_t connection, float * returnValue, krpc_SpaceCenter_Flight_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Flight_get_StallFraction", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_float(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Flight_Normal(krpc_connection_t connection, krpc_tuple_double_double_double_t * returnValue, krpc_SpaceCenter_Flight_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Flight_get_Normal", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_tuple_double_double_double(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Flight_AntiRadial(krpc_connection_t connection, krpc_tuple_double_double_double_t * returnValue, krpc_SpaceCenter_Flight_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Flight_get_AntiRadial", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_tuple_double_double_double(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Flight_StaticPressure(krpc_connection_t connection, float * returnValue, krpc_SpaceCenter_Flight_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Flight_get_StaticPressure", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_float(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Flight_CenterOfMass(krpc_connection_t connection, krpc_tuple_double_double_double_t * returnValue, krpc_SpaceCenter_Flight_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Flight_get_CenterOfMass", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_tuple_double_double_double(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Flight_Drag(krpc_connection_t connection, krpc_tuple_double_double_double_t * returnValue, krpc_SpaceCenter_Flight_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Flight_get_Drag", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_tuple_double_double_double(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Flight_Lift(krpc_connection_t connection, krpc_tuple_double_double_double_t * returnValue, krpc_SpaceCenter_Flight_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Flight_get_Lift", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_tuple_double_double_double(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Flight_GForce(krpc_connection_t connection, float * returnValue, krpc_SpaceCenter_Flight_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Flight_get_GForce", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_float(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Flight_StaticAirTemperature(krpc_connection_t connection, float * returnValue, krpc_SpaceCenter_Flight_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Flight_get_StaticAirTemperature", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_float(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Flight_DynamicPressure(krpc_connection_t connection, float * returnValue, krpc_SpaceCenter_Flight_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Flight_get_DynamicPressure", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_float(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Flight_Mach(krpc_connection_t connection, float * returnValue, krpc_SpaceCenter_Flight_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Flight_get_Mach", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_float(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Flight_BallisticCoefficient(krpc_connection_t connection, float * returnValue, krpc_SpaceCenter_Flight_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Flight_get_BallisticCoefficient", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_float(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Flight_StaticPressureAtMSL(krpc_connection_t connection, float * returnValue, krpc_SpaceCenter_Flight_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Flight_get_StaticPressureAtMSL", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_float(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Flight_VerticalSpeed(krpc_connection_t connection, double * returnValue, krpc_SpaceCenter_Flight_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Flight_get_VerticalSpeed", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_double(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Flight_MeanAltitude(krpc_connection_t connection, double * returnValue, krpc_SpaceCenter_Flight_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Flight_get_MeanAltitude", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_double(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Flight_Longitude(krpc_connection_t connection, double * returnValue, krpc_SpaceCenter_Flight_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Flight_get_Longitude", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_double(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Flight_SideslipAngle(krpc_connection_t connection, float * returnValue, krpc_SpaceCenter_Flight_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Flight_get_SideslipAngle", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_float(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Flight_BedrockAltitude(krpc_connection_t connection, double * returnValue, krpc_SpaceCenter_Flight_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Flight_get_BedrockAltitude", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_double(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Flight_EquivalentAirSpeed(krpc_connection_t connection, float * returnValue, krpc_SpaceCenter_Flight_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Flight_get_EquivalentAirSpeed", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_float(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Flight_AtmosphereDensity(krpc_connection_t connection, float * returnValue, krpc_SpaceCenter_Flight_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Flight_get_AtmosphereDensity", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_float(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Flight_Heading(krpc_connection_t connection, float * returnValue, krpc_SpaceCenter_Flight_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Flight_get_Heading", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_float(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Flight_SurfaceAltitude(krpc_connection_t connection, double * returnValue, krpc_SpaceCenter_Flight_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Flight_get_SurfaceAltitude", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_double(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Flight_TrueAirSpeed(krpc_connection_t connection, float * returnValue, krpc_SpaceCenter_Flight_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Flight_get_TrueAirSpeed", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_float(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Flight_Retrograde(krpc_connection_t connection, krpc_tuple_double_double_double_t * returnValue, krpc_SpaceCenter_Flight_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Flight_get_Retrograde", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_tuple_double_double_double(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Flight_ThrustSpecificFuelConsumption(krpc_connection_t connection, float * returnValue, krpc_SpaceCenter_Flight_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Flight_get_ThrustSpecificFuelConsumption", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_float(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Flight_AerodynamicForce(krpc_connection_t connection, krpc_tuple_double_double_double_t * returnValue, krpc_SpaceCenter_Flight_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Flight_get_AerodynamicForce", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_tuple_double_double_double(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Flight_Pitch(krpc_connection_t connection, float * returnValue, krpc_SpaceCenter_Flight_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Flight_get_Pitch", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_float(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Flight_LiftCoefficient(krpc_connection_t connection, float * returnValue, krpc_SpaceCenter_Flight_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Flight_get_LiftCoefficient", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_float(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Flight_Prograde(krpc_connection_t connection, krpc_tuple_double_double_double_t * returnValue, krpc_SpaceCenter_Flight_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Flight_get_Prograde", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_tuple_double_double_double(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Flight_AntiNormal(krpc_connection_t connection, krpc_tuple_double_double_double_t * returnValue, krpc_SpaceCenter_Flight_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Flight_get_AntiNormal", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_tuple_double_double_double(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Flight_Speed(krpc_connection_t connection, double * returnValue, krpc_SpaceCenter_Flight_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Flight_get_Speed", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_double(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Force_Remove(krpc_connection_t connection, krpc_SpaceCenter_Force_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Force_Remove", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Force_set_ReferenceFrame(krpc_connection_t connection, krpc_SpaceCenter_Force_t instance, krpc_SpaceCenter_ReferenceFrame_t value) {
  krpc_call_t _call;
  krpc_argument_t _arguments[2];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Force_set_ReferenceFrame", 2, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  KRPC_CHECK(krpc_add_argument(&_call, 1, &krpc_encode_callback_object, &value));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Force_ReferenceFrame(krpc_connection_t connection, krpc_SpaceCenter_ReferenceFrame_t * returnValue, krpc_SpaceCenter_Force_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Force_get_ReferenceFrame", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_object(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Force_set_ForceVector(krpc_connection_t connection, krpc_SpaceCenter_Force_t instance, const krpc_tuple_double_double_double_t * value) {
  krpc_call_t _call;
  krpc_argument_t _arguments[2];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Force_set_ForceVector", 2, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  KRPC_CHECK(krpc_add_argument(&_call, 1, &krpc_encode_callback_tuple_double_double_double, value));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Force_Part(krpc_connection_t connection, krpc_SpaceCenter_Part_t * returnValue, krpc_SpaceCenter_Force_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Force_get_Part", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_object(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Force_Position(krpc_connection_t connection, krpc_tuple_double_double_double_t * returnValue, krpc_SpaceCenter_Force_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Force_get_Position", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_tuple_double_double_double(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Force_set_Position(krpc_connection_t connection, krpc_SpaceCenter_Force_t instance, const krpc_tuple_double_double_double_t * value) {
  krpc_call_t _call;
  krpc_argument_t _arguments[2];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Force_set_Position", 2, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  KRPC_CHECK(krpc_add_argument(&_call, 1, &krpc_encode_callback_tuple_double_double_double, value));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Force_ForceVector(krpc_connection_t connection, krpc_tuple_double_double_double_t * returnValue, krpc_SpaceCenter_Force_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Force_get_ForceVector", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_tuple_double_double_double(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Intake_set_Open(krpc_connection_t connection, krpc_SpaceCenter_Intake_t instance, bool value) {
  krpc_call_t _call;
  krpc_argument_t _arguments[2];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Intake_set_Open", 2, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  KRPC_CHECK(krpc_add_argument(&_call, 1, &krpc_encode_callback_bool, &value));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Intake_Area(krpc_connection_t connection, float * returnValue, krpc_SpaceCenter_Intake_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Intake_get_Area", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_float(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Intake_Speed(krpc_connection_t connection, float * returnValue, krpc_SpaceCenter_Intake_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Intake_get_Speed", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_float(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Intake_Flow(krpc_connection_t connection, float * returnValue, krpc_SpaceCenter_Intake_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Intake_get_Flow", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_float(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Intake_Part(krpc_connection_t connection, krpc_SpaceCenter_Part_t * returnValue, krpc_SpaceCenter_Intake_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Intake_get_Part", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_object(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Intake_Open(krpc_connection_t connection, bool * returnValue, krpc_SpaceCenter_Intake_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Intake_get_Open", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_bool(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_LaunchClamp_Release(krpc_connection_t connection, krpc_SpaceCenter_LaunchClamp_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "LaunchClamp_Release", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_LaunchClamp_Part(krpc_connection_t connection, krpc_SpaceCenter_Part_t * returnValue, krpc_SpaceCenter_LaunchClamp_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "LaunchClamp_get_Part", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_object(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Leg_set_Deployed(krpc_connection_t connection, krpc_SpaceCenter_Leg_t instance, bool value) {
  krpc_call_t _call;
  krpc_argument_t _arguments[2];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Leg_set_Deployed", 2, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  KRPC_CHECK(krpc_add_argument(&_call, 1, &krpc_encode_callback_bool, &value));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Leg_Deployable(krpc_connection_t connection, bool * returnValue, krpc_SpaceCenter_Leg_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Leg_get_Deployable", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_bool(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Leg_State(krpc_connection_t connection, krpc_SpaceCenter_LegState_t * returnValue, krpc_SpaceCenter_Leg_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Leg_get_State", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_enum(&_stream, (int*)returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Leg_Part(krpc_connection_t connection, krpc_SpaceCenter_Part_t * returnValue, krpc_SpaceCenter_Leg_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Leg_get_Part", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_object(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Leg_IsGrounded(krpc_connection_t connection, bool * returnValue, krpc_SpaceCenter_Leg_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Leg_get_IsGrounded", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_bool(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Leg_Deployed(krpc_connection_t connection, bool * returnValue, krpc_SpaceCenter_Leg_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Leg_get_Deployed", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_bool(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Light_set_Active(krpc_connection_t connection, krpc_SpaceCenter_Light_t instance, bool value) {
  krpc_call_t _call;
  krpc_argument_t _arguments[2];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Light_set_Active", 2, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  KRPC_CHECK(krpc_add_argument(&_call, 1, &krpc_encode_callback_bool, &value));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Light_Color(krpc_connection_t connection, krpc_tuple_float_float_float_t * returnValue, krpc_SpaceCenter_Light_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Light_get_Color", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_tuple_float_float_float(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Light_Part(krpc_connection_t connection, krpc_SpaceCenter_Part_t * returnValue, krpc_SpaceCenter_Light_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Light_get_Part", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_object(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Light_Active(krpc_connection_t connection, bool * returnValue, krpc_SpaceCenter_Light_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Light_get_Active", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_bool(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Light_set_Color(krpc_connection_t connection, krpc_SpaceCenter_Light_t instance, const krpc_tuple_float_float_float_t * value) {
  krpc_call_t _call;
  krpc_argument_t _arguments[2];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Light_set_Color", 2, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  KRPC_CHECK(krpc_add_argument(&_call, 1, &krpc_encode_callback_tuple_float_float_float, value));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Light_PowerUsage(krpc_connection_t connection, float * returnValue, krpc_SpaceCenter_Light_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Light_get_PowerUsage", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_float(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Module_GetField(krpc_connection_t connection, char * * returnValue, krpc_SpaceCenter_Module_t instance, const char * name) {
  krpc_call_t _call;
  krpc_argument_t _arguments[2];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Module_GetField", 2, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  KRPC_CHECK(krpc_add_argument(&_call, 1, &krpc_encode_callback_string, &name));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_string(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Module_HasAction(krpc_connection_t connection, bool * returnValue, krpc_SpaceCenter_Module_t instance, const char * name) {
  krpc_call_t _call;
  krpc_argument_t _arguments[2];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Module_HasAction", 2, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  KRPC_CHECK(krpc_add_argument(&_call, 1, &krpc_encode_callback_string, &name));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_bool(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Module_HasEvent(krpc_connection_t connection, bool * returnValue, krpc_SpaceCenter_Module_t instance, const char * name) {
  krpc_call_t _call;
  krpc_argument_t _arguments[2];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Module_HasEvent", 2, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  KRPC_CHECK(krpc_add_argument(&_call, 1, &krpc_encode_callback_string, &name));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_bool(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Module_HasField(krpc_connection_t connection, bool * returnValue, krpc_SpaceCenter_Module_t instance, const char * name) {
  krpc_call_t _call;
  krpc_argument_t _arguments[2];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Module_HasField", 2, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  KRPC_CHECK(krpc_add_argument(&_call, 1, &krpc_encode_callback_string, &name));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_bool(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Module_ResetField(krpc_connection_t connection, krpc_SpaceCenter_Module_t instance, const char * name) {
  krpc_call_t _call;
  krpc_argument_t _arguments[2];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Module_ResetField", 2, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  KRPC_CHECK(krpc_add_argument(&_call, 1, &krpc_encode_callback_string, &name));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Module_SetAction(krpc_connection_t connection, krpc_SpaceCenter_Module_t instance, const char * name, bool value) {
  krpc_call_t _call;
  krpc_argument_t _arguments[3];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Module_SetAction", 3, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  KRPC_CHECK(krpc_add_argument(&_call, 1, &krpc_encode_callback_string, &name));
  KRPC_CHECK(krpc_add_argument(&_call, 2, &krpc_encode_callback_bool, &value));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Module_SetFieldFloat(krpc_connection_t connection, krpc_SpaceCenter_Module_t instance, const char * name, float value) {
  krpc_call_t _call;
  krpc_argument_t _arguments[3];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Module_SetFieldFloat", 3, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  KRPC_CHECK(krpc_add_argument(&_call, 1, &krpc_encode_callback_string, &name));
  KRPC_CHECK(krpc_add_argument(&_call, 2, &krpc_encode_callback_float, &value));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Module_SetFieldInt(krpc_connection_t connection, krpc_SpaceCenter_Module_t instance, const char * name, int32_t value) {
  krpc_call_t _call;
  krpc_argument_t _arguments[3];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Module_SetFieldInt", 3, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  KRPC_CHECK(krpc_add_argument(&_call, 1, &krpc_encode_callback_string, &name));
  KRPC_CHECK(krpc_add_argument(&_call, 2, &krpc_encode_callback_int32, &value));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Module_SetFieldString(krpc_connection_t connection, krpc_SpaceCenter_Module_t instance, const char * name, const char * value) {
  krpc_call_t _call;
  krpc_argument_t _arguments[3];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Module_SetFieldString", 3, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  KRPC_CHECK(krpc_add_argument(&_call, 1, &krpc_encode_callback_string, &name));
  KRPC_CHECK(krpc_add_argument(&_call, 2, &krpc_encode_callback_string, &value));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Module_TriggerEvent(krpc_connection_t connection, krpc_SpaceCenter_Module_t instance, const char * name) {
  krpc_call_t _call;
  krpc_argument_t _arguments[2];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Module_TriggerEvent", 2, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  KRPC_CHECK(krpc_add_argument(&_call, 1, &krpc_encode_callback_string, &name));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Module_Fields(krpc_connection_t connection, krpc_dictionary_string_string_t * returnValue, krpc_SpaceCenter_Module_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Module_get_Fields", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_dictionary_string_string(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Module_Part(krpc_connection_t connection, krpc_SpaceCenter_Part_t * returnValue, krpc_SpaceCenter_Module_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Module_get_Part", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_object(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Module_Events(krpc_connection_t connection, krpc_list_string_t * returnValue, krpc_SpaceCenter_Module_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Module_get_Events", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_list_string(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Module_Actions(krpc_connection_t connection, krpc_list_string_t * returnValue, krpc_SpaceCenter_Module_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Module_get_Actions", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_list_string(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Module_Name(krpc_connection_t connection, char * * returnValue, krpc_SpaceCenter_Module_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Module_get_Name", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_string(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Node_BurnVector(krpc_connection_t connection, krpc_tuple_double_double_double_t * returnValue, krpc_SpaceCenter_Node_t instance, krpc_SpaceCenter_ReferenceFrame_t referenceFrame) {
  krpc_call_t _call;
  krpc_argument_t _arguments[2];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Node_BurnVector", 2, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  KRPC_CHECK(krpc_add_argument(&_call, 1, &krpc_encode_callback_object, &referenceFrame));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_tuple_double_double_double(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Node_Direction(krpc_connection_t connection, krpc_tuple_double_double_double_t * returnValue, krpc_SpaceCenter_Node_t instance, krpc_SpaceCenter_ReferenceFrame_t referenceFrame) {
  krpc_call_t _call;
  krpc_argument_t _arguments[2];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Node_Direction", 2, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  KRPC_CHECK(krpc_add_argument(&_call, 1, &krpc_encode_callback_object, &referenceFrame));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_tuple_double_double_double(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Node_Position(krpc_connection_t connection, krpc_tuple_double_double_double_t * returnValue, krpc_SpaceCenter_Node_t instance, krpc_SpaceCenter_ReferenceFrame_t referenceFrame) {
  krpc_call_t _call;
  krpc_argument_t _arguments[2];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Node_Position", 2, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  KRPC_CHECK(krpc_add_argument(&_call, 1, &krpc_encode_callback_object, &referenceFrame));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_tuple_double_double_double(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Node_RemainingBurnVector(krpc_connection_t connection, krpc_tuple_double_double_double_t * returnValue, krpc_SpaceCenter_Node_t instance, krpc_SpaceCenter_ReferenceFrame_t referenceFrame) {
  krpc_call_t _call;
  krpc_argument_t _arguments[2];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Node_RemainingBurnVector", 2, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  KRPC_CHECK(krpc_add_argument(&_call, 1, &krpc_encode_callback_object, &referenceFrame));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_tuple_double_double_double(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Node_Remove(krpc_connection_t connection, krpc_SpaceCenter_Node_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Node_Remove", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Node_RemainingDeltaV(krpc_connection_t connection, double * returnValue, krpc_SpaceCenter_Node_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Node_get_RemainingDeltaV", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_double(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Node_set_Normal(krpc_connection_t connection, krpc_SpaceCenter_Node_t instance, double value) {
  krpc_call_t _call;
  krpc_argument_t _arguments[2];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Node_set_Normal", 2, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  KRPC_CHECK(krpc_add_argument(&_call, 1, &krpc_encode_callback_double, &value));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Node_set_DeltaV(krpc_connection_t connection, krpc_SpaceCenter_Node_t instance, double value) {
  krpc_call_t _call;
  krpc_argument_t _arguments[2];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Node_set_DeltaV", 2, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  KRPC_CHECK(krpc_add_argument(&_call, 1, &krpc_encode_callback_double, &value));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Node_DeltaV(krpc_connection_t connection, double * returnValue, krpc_SpaceCenter_Node_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Node_get_DeltaV", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_double(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Node_Normal(krpc_connection_t connection, double * returnValue, krpc_SpaceCenter_Node_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Node_get_Normal", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_double(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Node_set_Radial(krpc_connection_t connection, krpc_SpaceCenter_Node_t instance, double value) {
  krpc_call_t _call;
  krpc_argument_t _arguments[2];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Node_set_Radial", 2, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  KRPC_CHECK(krpc_add_argument(&_call, 1, &krpc_encode_callback_double, &value));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Node_UT(krpc_connection_t connection, double * returnValue, krpc_SpaceCenter_Node_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Node_get_UT", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_double(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Node_set_UT(krpc_connection_t connection, krpc_SpaceCenter_Node_t instance, double value) {
  krpc_call_t _call;
  krpc_argument_t _arguments[2];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Node_set_UT", 2, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  KRPC_CHECK(krpc_add_argument(&_call, 1, &krpc_encode_callback_double, &value));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Node_Orbit(krpc_connection_t connection, krpc_SpaceCenter_Orbit_t * returnValue, krpc_SpaceCenter_Node_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Node_get_Orbit", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_object(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Node_TimeTo(krpc_connection_t connection, double * returnValue, krpc_SpaceCenter_Node_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Node_get_TimeTo", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_double(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Node_set_Prograde(krpc_connection_t connection, krpc_SpaceCenter_Node_t instance, double value) {
  krpc_call_t _call;
  krpc_argument_t _arguments[2];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Node_set_Prograde", 2, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  KRPC_CHECK(krpc_add_argument(&_call, 1, &krpc_encode_callback_double, &value));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Node_Radial(krpc_connection_t connection, double * returnValue, krpc_SpaceCenter_Node_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Node_get_Radial", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_double(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Node_ReferenceFrame(krpc_connection_t connection, krpc_SpaceCenter_ReferenceFrame_t * returnValue, krpc_SpaceCenter_Node_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Node_get_ReferenceFrame", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_object(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Node_Prograde(krpc_connection_t connection, double * returnValue, krpc_SpaceCenter_Node_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Node_get_Prograde", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_double(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Node_OrbitalReferenceFrame(krpc_connection_t connection, krpc_SpaceCenter_ReferenceFrame_t * returnValue, krpc_SpaceCenter_Node_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Node_get_OrbitalReferenceFrame", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_object(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Orbit_DistanceAtClosestApproach(krpc_connection_t connection, double * returnValue, krpc_SpaceCenter_Orbit_t instance, krpc_SpaceCenter_Vessel_t target) {
  krpc_call_t _call;
  krpc_argument_t _arguments[2];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Orbit_DistanceAtClosestApproach", 2, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  KRPC_CHECK(krpc_add_argument(&_call, 1, &krpc_encode_callback_object, &target));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_double(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Orbit_EccentricAnomalyAtUT(krpc_connection_t connection, double * returnValue, krpc_SpaceCenter_Orbit_t instance, double ut) {
  krpc_call_t _call;
  krpc_argument_t _arguments[2];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Orbit_EccentricAnomalyAtUT", 2, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  KRPC_CHECK(krpc_add_argument(&_call, 1, &krpc_encode_callback_double, &ut));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_double(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Orbit_ListClosestApproaches(krpc_connection_t connection, krpc_list_list_double_t * returnValue, krpc_SpaceCenter_Orbit_t instance, krpc_SpaceCenter_Vessel_t target, int32_t orbits) {
  krpc_call_t _call;
  krpc_argument_t _arguments[3];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Orbit_ListClosestApproaches", 3, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  KRPC_CHECK(krpc_add_argument(&_call, 1, &krpc_encode_callback_object, &target));
  KRPC_CHECK(krpc_add_argument(&_call, 2, &krpc_encode_callback_int32, &orbits));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_list_list_double(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Orbit_MeanAnomalyAtUT(krpc_connection_t connection, double * returnValue, krpc_SpaceCenter_Orbit_t instance, double ut) {
  krpc_call_t _call;
  krpc_argument_t _arguments[2];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Orbit_MeanAnomalyAtUT", 2, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  KRPC_CHECK(krpc_add_argument(&_call, 1, &krpc_encode_callback_double, &ut));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_double(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Orbit_OrbitalSpeedAt(krpc_connection_t connection, double * returnValue, krpc_SpaceCenter_Orbit_t instance, double time) {
  krpc_call_t _call;
  krpc_argument_t _arguments[2];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Orbit_OrbitalSpeedAt", 2, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  KRPC_CHECK(krpc_add_argument(&_call, 1, &krpc_encode_callback_double, &time));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_double(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Orbit_PositionAt(krpc_connection_t connection, krpc_tuple_double_double_double_t * returnValue, krpc_SpaceCenter_Orbit_t instance, double ut, krpc_SpaceCenter_ReferenceFrame_t referenceFrame) {
  krpc_call_t _call;
  krpc_argument_t _arguments[3];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Orbit_PositionAt", 3, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  KRPC_CHECK(krpc_add_argument(&_call, 1, &krpc_encode_callback_double, &ut));
  KRPC_CHECK(krpc_add_argument(&_call, 2, &krpc_encode_callback_object, &referenceFrame));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_tuple_double_double_double(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Orbit_RadiusAt(krpc_connection_t connection, double * returnValue, krpc_SpaceCenter_Orbit_t instance, double ut) {
  krpc_call_t _call;
  krpc_argument_t _arguments[2];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Orbit_RadiusAt", 2, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  KRPC_CHECK(krpc_add_argument(&_call, 1, &krpc_encode_callback_double, &ut));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_double(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Orbit_RadiusAtTrueAnomaly(krpc_connection_t connection, double * returnValue, krpc_SpaceCenter_Orbit_t instance, double trueAnomaly) {
  krpc_call_t _call;
  krpc_argument_t _arguments[2];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Orbit_RadiusAtTrueAnomaly", 2, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  KRPC_CHECK(krpc_add_argument(&_call, 1, &krpc_encode_callback_double, &trueAnomaly));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_double(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Orbit_RelativeInclination(krpc_connection_t connection, double * returnValue, krpc_SpaceCenter_Orbit_t instance, krpc_SpaceCenter_Vessel_t target) {
  krpc_call_t _call;
  krpc_argument_t _arguments[2];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Orbit_RelativeInclination", 2, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  KRPC_CHECK(krpc_add_argument(&_call, 1, &krpc_encode_callback_object, &target));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_double(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Orbit_TimeOfClosestApproach(krpc_connection_t connection, double * returnValue, krpc_SpaceCenter_Orbit_t instance, krpc_SpaceCenter_Vessel_t target) {
  krpc_call_t _call;
  krpc_argument_t _arguments[2];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Orbit_TimeOfClosestApproach", 2, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  KRPC_CHECK(krpc_add_argument(&_call, 1, &krpc_encode_callback_object, &target));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_double(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Orbit_TrueAnomalyAtAN(krpc_connection_t connection, double * returnValue, krpc_SpaceCenter_Orbit_t instance, krpc_SpaceCenter_Vessel_t target) {
  krpc_call_t _call;
  krpc_argument_t _arguments[2];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Orbit_TrueAnomalyAtAN", 2, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  KRPC_CHECK(krpc_add_argument(&_call, 1, &krpc_encode_callback_object, &target));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_double(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Orbit_TrueAnomalyAtDN(krpc_connection_t connection, double * returnValue, krpc_SpaceCenter_Orbit_t instance, krpc_SpaceCenter_Vessel_t target) {
  krpc_call_t _call;
  krpc_argument_t _arguments[2];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Orbit_TrueAnomalyAtDN", 2, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  KRPC_CHECK(krpc_add_argument(&_call, 1, &krpc_encode_callback_object, &target));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_double(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Orbit_TrueAnomalyAtRadius(krpc_connection_t connection, double * returnValue, krpc_SpaceCenter_Orbit_t instance, double radius) {
  krpc_call_t _call;
  krpc_argument_t _arguments[2];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Orbit_TrueAnomalyAtRadius", 2, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  KRPC_CHECK(krpc_add_argument(&_call, 1, &krpc_encode_callback_double, &radius));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_double(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Orbit_TrueAnomalyAtUT(krpc_connection_t connection, double * returnValue, krpc_SpaceCenter_Orbit_t instance, double ut) {
  krpc_call_t _call;
  krpc_argument_t _arguments[2];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Orbit_TrueAnomalyAtUT", 2, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  KRPC_CHECK(krpc_add_argument(&_call, 1, &krpc_encode_callback_double, &ut));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_double(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Orbit_UTAtTrueAnomaly(krpc_connection_t connection, double * returnValue, krpc_SpaceCenter_Orbit_t instance, double trueAnomaly) {
  krpc_call_t _call;
  krpc_argument_t _arguments[2];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Orbit_UTAtTrueAnomaly", 2, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  KRPC_CHECK(krpc_add_argument(&_call, 1, &krpc_encode_callback_double, &trueAnomaly));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_double(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Orbit_Apoapsis(krpc_connection_t connection, double * returnValue, krpc_SpaceCenter_Orbit_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Orbit_get_Apoapsis", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_double(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Orbit_Epoch(krpc_connection_t connection, double * returnValue, krpc_SpaceCenter_Orbit_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Orbit_get_Epoch", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_double(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Orbit_TrueAnomaly(krpc_connection_t connection, double * returnValue, krpc_SpaceCenter_Orbit_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Orbit_get_TrueAnomaly", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_double(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Orbit_PeriapsisAltitude(krpc_connection_t connection, double * returnValue, krpc_SpaceCenter_Orbit_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Orbit_get_PeriapsisAltitude", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_double(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Orbit_ArgumentOfPeriapsis(krpc_connection_t connection, double * returnValue, krpc_SpaceCenter_Orbit_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Orbit_get_ArgumentOfPeriapsis", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_double(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Orbit_Inclination(krpc_connection_t connection, double * returnValue, krpc_SpaceCenter_Orbit_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Orbit_get_Inclination", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_double(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Orbit_Body(krpc_connection_t connection, krpc_SpaceCenter_CelestialBody_t * returnValue, krpc_SpaceCenter_Orbit_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Orbit_get_Body", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_object(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Orbit_ApoapsisAltitude(krpc_connection_t connection, double * returnValue, krpc_SpaceCenter_Orbit_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Orbit_get_ApoapsisAltitude", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_double(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Orbit_MeanAnomaly(krpc_connection_t connection, double * returnValue, krpc_SpaceCenter_Orbit_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Orbit_get_MeanAnomaly", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_double(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Orbit_OrbitalSpeed(krpc_connection_t connection, double * returnValue, krpc_SpaceCenter_Orbit_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Orbit_get_OrbitalSpeed", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_double(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Orbit_TimeToPeriapsis(krpc_connection_t connection, double * returnValue, krpc_SpaceCenter_Orbit_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Orbit_get_TimeToPeriapsis", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_double(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Orbit_SemiMinorAxis(krpc_connection_t connection, double * returnValue, krpc_SpaceCenter_Orbit_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Orbit_get_SemiMinorAxis", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_double(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Orbit_Eccentricity(krpc_connection_t connection, double * returnValue, krpc_SpaceCenter_Orbit_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Orbit_get_Eccentricity", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_double(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Orbit_Periapsis(krpc_connection_t connection, double * returnValue, krpc_SpaceCenter_Orbit_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Orbit_get_Periapsis", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_double(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Orbit_SemiMajorAxis(krpc_connection_t connection, double * returnValue, krpc_SpaceCenter_Orbit_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Orbit_get_SemiMajorAxis", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_double(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Orbit_MeanAnomalyAtEpoch(krpc_connection_t connection, double * returnValue, krpc_SpaceCenter_Orbit_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Orbit_get_MeanAnomalyAtEpoch", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_double(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Orbit_NextOrbit(krpc_connection_t connection, krpc_SpaceCenter_Orbit_t * returnValue, krpc_SpaceCenter_Orbit_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Orbit_get_NextOrbit", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_object(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Orbit_LongitudeOfAscendingNode(krpc_connection_t connection, double * returnValue, krpc_SpaceCenter_Orbit_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Orbit_get_LongitudeOfAscendingNode", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_double(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Orbit_TimeToSOIChange(krpc_connection_t connection, double * returnValue, krpc_SpaceCenter_Orbit_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Orbit_get_TimeToSOIChange", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_double(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Orbit_EccentricAnomaly(krpc_connection_t connection, double * returnValue, krpc_SpaceCenter_Orbit_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Orbit_get_EccentricAnomaly", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_double(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Orbit_Period(krpc_connection_t connection, double * returnValue, krpc_SpaceCenter_Orbit_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Orbit_get_Period", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_double(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Orbit_Radius(krpc_connection_t connection, double * returnValue, krpc_SpaceCenter_Orbit_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Orbit_get_Radius", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_double(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Orbit_TimeToApoapsis(krpc_connection_t connection, double * returnValue, krpc_SpaceCenter_Orbit_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Orbit_get_TimeToApoapsis", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_double(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Orbit_Speed(krpc_connection_t connection, double * returnValue, krpc_SpaceCenter_Orbit_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Orbit_get_Speed", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_double(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Orbit_ReferencePlaneDirection(krpc_connection_t connection, krpc_tuple_double_double_double_t * returnValue, krpc_SpaceCenter_ReferenceFrame_t referenceFrame) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Orbit_static_ReferencePlaneDirection", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_object, &referenceFrame));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_tuple_double_double_double(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Orbit_ReferencePlaneNormal(krpc_connection_t connection, krpc_tuple_double_double_double_t * returnValue, krpc_SpaceCenter_ReferenceFrame_t referenceFrame) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Orbit_static_ReferencePlaneNormal", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_object, &referenceFrame));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_tuple_double_double_double(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Parachute_Arm(krpc_connection_t connection, krpc_SpaceCenter_Parachute_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Parachute_Arm", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Parachute_Deploy(krpc_connection_t connection, krpc_SpaceCenter_Parachute_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Parachute_Deploy", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Parachute_DeployMinPressure(krpc_connection_t connection, float * returnValue, krpc_SpaceCenter_Parachute_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Parachute_get_DeployMinPressure", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_float(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Parachute_DeployAltitude(krpc_connection_t connection, float * returnValue, krpc_SpaceCenter_Parachute_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Parachute_get_DeployAltitude", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_float(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Parachute_State(krpc_connection_t connection, krpc_SpaceCenter_ParachuteState_t * returnValue, krpc_SpaceCenter_Parachute_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Parachute_get_State", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_enum(&_stream, (int*)returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Parachute_Part(krpc_connection_t connection, krpc_SpaceCenter_Part_t * returnValue, krpc_SpaceCenter_Parachute_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Parachute_get_Part", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_object(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Parachute_set_DeployAltitude(krpc_connection_t connection, krpc_SpaceCenter_Parachute_t instance, float value) {
  krpc_call_t _call;
  krpc_argument_t _arguments[2];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Parachute_set_DeployAltitude", 2, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  KRPC_CHECK(krpc_add_argument(&_call, 1, &krpc_encode_callback_float, &value));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Parachute_set_DeployMinPressure(krpc_connection_t connection, krpc_SpaceCenter_Parachute_t instance, float value) {
  krpc_call_t _call;
  krpc_argument_t _arguments[2];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Parachute_set_DeployMinPressure", 2, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  KRPC_CHECK(krpc_add_argument(&_call, 1, &krpc_encode_callback_float, &value));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Parachute_Armed(krpc_connection_t connection, bool * returnValue, krpc_SpaceCenter_Parachute_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Parachute_get_Armed", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_bool(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Parachute_Deployed(krpc_connection_t connection, bool * returnValue, krpc_SpaceCenter_Parachute_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Parachute_get_Deployed", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_bool(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Part_AddForce(krpc_connection_t connection, krpc_SpaceCenter_Force_t * returnValue, krpc_SpaceCenter_Part_t instance, const krpc_tuple_double_double_double_t * force, const krpc_tuple_double_double_double_t * position, krpc_SpaceCenter_ReferenceFrame_t referenceFrame) {
  krpc_call_t _call;
  krpc_argument_t _arguments[4];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Part_AddForce", 4, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  KRPC_CHECK(krpc_add_argument(&_call, 1, &krpc_encode_callback_tuple_double_double_double, force));
  KRPC_CHECK(krpc_add_argument(&_call, 2, &krpc_encode_callback_tuple_double_double_double, position));
  KRPC_CHECK(krpc_add_argument(&_call, 3, &krpc_encode_callback_object, &referenceFrame));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_object(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Part_BoundingBox(krpc_connection_t connection, krpc_tuple_tuple_double_double_double_tuple_double_double_double_t * returnValue, krpc_SpaceCenter_Part_t instance, krpc_SpaceCenter_ReferenceFrame_t referenceFrame) {
  krpc_call_t _call;
  krpc_argument_t _arguments[2];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Part_BoundingBox", 2, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  KRPC_CHECK(krpc_add_argument(&_call, 1, &krpc_encode_callback_object, &referenceFrame));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_tuple_tuple_double_double_double_tuple_double_double_double(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Part_CenterOfMass(krpc_connection_t connection, krpc_tuple_double_double_double_t * returnValue, krpc_SpaceCenter_Part_t instance, krpc_SpaceCenter_ReferenceFrame_t referenceFrame) {
  krpc_call_t _call;
  krpc_argument_t _arguments[2];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Part_CenterOfMass", 2, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  KRPC_CHECK(krpc_add_argument(&_call, 1, &krpc_encode_callback_object, &referenceFrame));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_tuple_double_double_double(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Part_Direction(krpc_connection_t connection, krpc_tuple_double_double_double_t * returnValue, krpc_SpaceCenter_Part_t instance, krpc_SpaceCenter_ReferenceFrame_t referenceFrame) {
  krpc_call_t _call;
  krpc_argument_t _arguments[2];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Part_Direction", 2, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  KRPC_CHECK(krpc_add_argument(&_call, 1, &krpc_encode_callback_object, &referenceFrame));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_tuple_double_double_double(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Part_InstantaneousForce(krpc_connection_t connection, krpc_SpaceCenter_Part_t instance, const krpc_tuple_double_double_double_t * force, const krpc_tuple_double_double_double_t * position, krpc_SpaceCenter_ReferenceFrame_t referenceFrame) {
  krpc_call_t _call;
  krpc_argument_t _arguments[4];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Part_InstantaneousForce", 4, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  KRPC_CHECK(krpc_add_argument(&_call, 1, &krpc_encode_callback_tuple_double_double_double, force));
  KRPC_CHECK(krpc_add_argument(&_call, 2, &krpc_encode_callback_tuple_double_double_double, position));
  KRPC_CHECK(krpc_add_argument(&_call, 3, &krpc_encode_callback_object, &referenceFrame));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Part_Position(krpc_connection_t connection, krpc_tuple_double_double_double_t * returnValue, krpc_SpaceCenter_Part_t instance, krpc_SpaceCenter_ReferenceFrame_t referenceFrame) {
  krpc_call_t _call;
  krpc_argument_t _arguments[2];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Part_Position", 2, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  KRPC_CHECK(krpc_add_argument(&_call, 1, &krpc_encode_callback_object, &referenceFrame));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_tuple_double_double_double(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Part_Rotation(krpc_connection_t connection, krpc_tuple_double_double_double_double_t * returnValue, krpc_SpaceCenter_Part_t instance, krpc_SpaceCenter_ReferenceFrame_t referenceFrame) {
  krpc_call_t _call;
  krpc_argument_t _arguments[2];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Part_Rotation", 2, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  KRPC_CHECK(krpc_add_argument(&_call, 1, &krpc_encode_callback_object, &referenceFrame));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_tuple_double_double_double_double(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Part_Velocity(krpc_connection_t connection, krpc_tuple_double_double_double_t * returnValue, krpc_SpaceCenter_Part_t instance, krpc_SpaceCenter_ReferenceFrame_t referenceFrame) {
  krpc_call_t _call;
  krpc_argument_t _arguments[2];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Part_Velocity", 2, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  KRPC_CHECK(krpc_add_argument(&_call, 1, &krpc_encode_callback_object, &referenceFrame));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_tuple_double_double_double(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Part_ThermalConductionFlux(krpc_connection_t connection, float * returnValue, krpc_SpaceCenter_Part_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Part_get_ThermalConductionFlux", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_float(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Part_CenterOfMassReferenceFrame(krpc_connection_t connection, krpc_SpaceCenter_ReferenceFrame_t * returnValue, krpc_SpaceCenter_Part_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Part_get_CenterOfMassReferenceFrame", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_object(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Part_Crossfeed(krpc_connection_t connection, bool * returnValue, krpc_SpaceCenter_Part_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Part_get_Crossfeed", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_bool(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Part_Antenna(krpc_connection_t connection, krpc_SpaceCenter_Antenna_t * returnValue, krpc_SpaceCenter_Part_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Part_get_Antenna", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_object(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Part_InertiaTensor(krpc_connection_t connection, krpc_list_double_t * returnValue, krpc_SpaceCenter_Part_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Part_get_InertiaTensor", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_list_double(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Part_MomentOfInertia(krpc_connection_t connection, krpc_tuple_double_double_double_t * returnValue, krpc_SpaceCenter_Part_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Part_get_MomentOfInertia", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_tuple_double_double_double(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Part_RCS(krpc_connection_t connection, krpc_SpaceCenter_RCS_t * returnValue, krpc_SpaceCenter_Part_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Part_get_RCS", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_object(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Part_Highlighted(krpc_connection_t connection, bool * returnValue, krpc_SpaceCenter_Part_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Part_get_Highlighted", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_bool(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Part_Experiment(krpc_connection_t connection, krpc_SpaceCenter_Experiment_t * returnValue, krpc_SpaceCenter_Part_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Part_get_Experiment", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_object(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Part_ReferenceFrame(krpc_connection_t connection, krpc_SpaceCenter_ReferenceFrame_t * returnValue, krpc_SpaceCenter_Part_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Part_get_ReferenceFrame", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_object(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Part_ThermalMass(krpc_connection_t connection, float * returnValue, krpc_SpaceCenter_Part_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Part_get_ThermalMass", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_float(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Part_Massless(krpc_connection_t connection, bool * returnValue, krpc_SpaceCenter_Part_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Part_get_Massless", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_bool(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Part_Sensor(krpc_connection_t connection, krpc_SpaceCenter_Sensor_t * returnValue, krpc_SpaceCenter_Part_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Part_get_Sensor", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_object(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Part_Resources(krpc_connection_t connection, krpc_SpaceCenter_Resources_t * returnValue, krpc_SpaceCenter_Part_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Part_get_Resources", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_object(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Part_FuelLinesTo(krpc_connection_t connection, krpc_list_object_t * returnValue, krpc_SpaceCenter_Part_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Part_get_FuelLinesTo", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_list_object(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Part_Engine(krpc_connection_t connection, krpc_SpaceCenter_Engine_t * returnValue, krpc_SpaceCenter_Part_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Part_get_Engine", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_object(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Part_ThermalRadiationFlux(krpc_connection_t connection, float * returnValue, krpc_SpaceCenter_Part_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Part_get_ThermalRadiationFlux", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_float(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Part_Parent(krpc_connection_t connection, krpc_SpaceCenter_Part_t * returnValue, krpc_SpaceCenter_Part_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Part_get_Parent", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_object(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Part_Leg(krpc_connection_t connection, krpc_SpaceCenter_Leg_t * returnValue, krpc_SpaceCenter_Part_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Part_get_Leg", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_object(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Part_RadiallyAttached(krpc_connection_t connection, bool * returnValue, krpc_SpaceCenter_Part_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Part_get_RadiallyAttached", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_bool(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Part_Title(krpc_connection_t connection, char * * returnValue, krpc_SpaceCenter_Part_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Part_get_Title", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_string(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Part_FuelLinesFrom(krpc_connection_t connection, krpc_list_object_t * returnValue, krpc_SpaceCenter_Part_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Part_get_FuelLinesFrom", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_list_object(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Part_ThermalConvectionFlux(krpc_connection_t connection, float * returnValue, krpc_SpaceCenter_Part_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Part_get_ThermalConvectionFlux", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_float(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Part_ResourceConverter(krpc_connection_t connection, krpc_SpaceCenter_ResourceConverter_t * returnValue, krpc_SpaceCenter_Part_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Part_get_ResourceConverter", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_object(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Part_HighlightColor(krpc_connection_t connection, krpc_tuple_double_double_double_t * returnValue, krpc_SpaceCenter_Part_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Part_get_HighlightColor", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_tuple_double_double_double(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Part_SolarPanel(krpc_connection_t connection, krpc_SpaceCenter_SolarPanel_t * returnValue, krpc_SpaceCenter_Part_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Part_get_SolarPanel", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_object(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Part_DecoupleStage(krpc_connection_t connection, int32_t * returnValue, krpc_SpaceCenter_Part_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Part_get_DecoupleStage", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_int32(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Part_Wheel(krpc_connection_t connection, krpc_SpaceCenter_Wheel_t * returnValue, krpc_SpaceCenter_Part_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Part_get_Wheel", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_object(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Part_DynamicPressure(krpc_connection_t connection, float * returnValue, krpc_SpaceCenter_Part_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Part_get_DynamicPressure", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_float(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Part_MaxSkinTemperature(krpc_connection_t connection, double * returnValue, krpc_SpaceCenter_Part_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Part_get_MaxSkinTemperature", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_double(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Part_IsFuelLine(krpc_connection_t connection, bool * returnValue, krpc_SpaceCenter_Part_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Part_get_IsFuelLine", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_bool(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Part_ImpactTolerance(krpc_connection_t connection, double * returnValue, krpc_SpaceCenter_Part_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Part_get_ImpactTolerance", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_double(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Part_Intake(krpc_connection_t connection, krpc_SpaceCenter_Intake_t * returnValue, krpc_SpaceCenter_Part_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Part_get_Intake", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_object(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Part_ResourceHarvester(krpc_connection_t connection, krpc_SpaceCenter_ResourceHarvester_t * returnValue, krpc_SpaceCenter_Part_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Part_get_ResourceHarvester", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_object(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Part_Temperature(krpc_connection_t connection, double * returnValue, krpc_SpaceCenter_Part_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Part_get_Temperature", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_double(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Part_Name(krpc_connection_t connection, char * * returnValue, krpc_SpaceCenter_Part_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Part_get_Name", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_string(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Part_ThermalSkinToInternalFlux(krpc_connection_t connection, float * returnValue, krpc_SpaceCenter_Part_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Part_get_ThermalSkinToInternalFlux", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_float(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Part_Shielded(krpc_connection_t connection, bool * returnValue, krpc_SpaceCenter_Part_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Part_get_Shielded", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_bool(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Part_Decoupler(krpc_connection_t connection, krpc_SpaceCenter_Decoupler_t * returnValue, krpc_SpaceCenter_Part_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Part_get_Decoupler", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_object(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Part_Light(krpc_connection_t connection, krpc_SpaceCenter_Light_t * returnValue, krpc_SpaceCenter_Part_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Part_get_Light", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_object(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Part_Modules(krpc_connection_t connection, krpc_list_object_t * returnValue, krpc_SpaceCenter_Part_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Part_get_Modules", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_list_object(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Part_set_Tag(krpc_connection_t connection, krpc_SpaceCenter_Part_t instance, const char * value) {
  krpc_call_t _call;
  krpc_argument_t _arguments[2];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Part_set_Tag", 2, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  KRPC_CHECK(krpc_add_argument(&_call, 1, &krpc_encode_callback_string, &value));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Part_Radiator(krpc_connection_t connection, krpc_SpaceCenter_Radiator_t * returnValue, krpc_SpaceCenter_Part_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Part_get_Radiator", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_object(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Part_Tag(krpc_connection_t connection, char * * returnValue, krpc_SpaceCenter_Part_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Part_get_Tag", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_string(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Part_ReactionWheel(krpc_connection_t connection, krpc_SpaceCenter_ReactionWheel_t * returnValue, krpc_SpaceCenter_Part_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Part_get_ReactionWheel", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_object(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Part_Mass(krpc_connection_t connection, double * returnValue, krpc_SpaceCenter_Part_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Part_get_Mass", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_double(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Part_AxiallyAttached(krpc_connection_t connection, bool * returnValue, krpc_SpaceCenter_Part_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Part_get_AxiallyAttached", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_bool(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Part_ThermalSkinMass(krpc_connection_t connection, float * returnValue, krpc_SpaceCenter_Part_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Part_get_ThermalSkinMass", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_float(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Part_ThermalInternalFlux(krpc_connection_t connection, float * returnValue, krpc_SpaceCenter_Part_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Part_get_ThermalInternalFlux", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_float(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Part_SkinTemperature(krpc_connection_t connection, double * returnValue, krpc_SpaceCenter_Part_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Part_get_SkinTemperature", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_double(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Part_DockingPort(krpc_connection_t connection, krpc_SpaceCenter_DockingPort_t * returnValue, krpc_SpaceCenter_Part_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Part_get_DockingPort", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_object(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Part_CargoBay(krpc_connection_t connection, krpc_SpaceCenter_CargoBay_t * returnValue, krpc_SpaceCenter_Part_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Part_get_CargoBay", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_object(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Part_MaxTemperature(krpc_connection_t connection, double * returnValue, krpc_SpaceCenter_Part_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Part_get_MaxTemperature", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_double(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Part_set_Highlighted(krpc_connection_t connection, krpc_SpaceCenter_Part_t instance, bool value) {
  krpc_call_t _call;
  krpc_argument_t _arguments[2];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Part_set_Highlighted", 2, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  KRPC_CHECK(krpc_add_argument(&_call, 1, &krpc_encode_callback_bool, &value));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Part_set_HighlightColor(krpc_connection_t connection, krpc_SpaceCenter_Part_t instance, const krpc_tuple_double_double_double_t * value) {
  krpc_call_t _call;
  krpc_argument_t _arguments[2];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Part_set_HighlightColor", 2, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  KRPC_CHECK(krpc_add_argument(&_call, 1, &krpc_encode_callback_tuple_double_double_double, value));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Part_Fairing(krpc_connection_t connection, krpc_SpaceCenter_Fairing_t * returnValue, krpc_SpaceCenter_Part_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Part_get_Fairing", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_object(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Part_ControlSurface(krpc_connection_t connection, krpc_SpaceCenter_ControlSurface_t * returnValue, krpc_SpaceCenter_Part_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Part_get_ControlSurface", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_object(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Part_LaunchClamp(krpc_connection_t connection, krpc_SpaceCenter_LaunchClamp_t * returnValue, krpc_SpaceCenter_Part_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Part_get_LaunchClamp", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_object(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Part_Parachute(krpc_connection_t connection, krpc_SpaceCenter_Parachute_t * returnValue, krpc_SpaceCenter_Part_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Part_get_Parachute", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_object(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Part_DryMass(krpc_connection_t connection, double * returnValue, krpc_SpaceCenter_Part_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Part_get_DryMass", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_double(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Part_Cost(krpc_connection_t connection, double * returnValue, krpc_SpaceCenter_Part_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Part_get_Cost", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_double(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Part_Vessel(krpc_connection_t connection, krpc_SpaceCenter_Vessel_t * returnValue, krpc_SpaceCenter_Part_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Part_get_Vessel", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_object(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Part_Stage(krpc_connection_t connection, int32_t * returnValue, krpc_SpaceCenter_Part_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Part_get_Stage", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_int32(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Part_Children(krpc_connection_t connection, krpc_list_object_t * returnValue, krpc_SpaceCenter_Part_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Part_get_Children", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_list_object(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Part_ThermalResourceMass(krpc_connection_t connection, float * returnValue, krpc_SpaceCenter_Part_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Part_get_ThermalResourceMass", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_float(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Parts_InDecoupleStage(krpc_connection_t connection, krpc_list_object_t * returnValue, krpc_SpaceCenter_Parts_t instance, int32_t stage) {
  krpc_call_t _call;
  krpc_argument_t _arguments[2];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Parts_InDecoupleStage", 2, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  KRPC_CHECK(krpc_add_argument(&_call, 1, &krpc_encode_callback_int32, &stage));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_list_object(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Parts_InStage(krpc_connection_t connection, krpc_list_object_t * returnValue, krpc_SpaceCenter_Parts_t instance, int32_t stage) {
  krpc_call_t _call;
  krpc_argument_t _arguments[2];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Parts_InStage", 2, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  KRPC_CHECK(krpc_add_argument(&_call, 1, &krpc_encode_callback_int32, &stage));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_list_object(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Parts_ModulesWithName(krpc_connection_t connection, krpc_list_object_t * returnValue, krpc_SpaceCenter_Parts_t instance, const char * moduleName) {
  krpc_call_t _call;
  krpc_argument_t _arguments[2];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Parts_ModulesWithName", 2, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  KRPC_CHECK(krpc_add_argument(&_call, 1, &krpc_encode_callback_string, &moduleName));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_list_object(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Parts_WithModule(krpc_connection_t connection, krpc_list_object_t * returnValue, krpc_SpaceCenter_Parts_t instance, const char * moduleName) {
  krpc_call_t _call;
  krpc_argument_t _arguments[2];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Parts_WithModule", 2, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  KRPC_CHECK(krpc_add_argument(&_call, 1, &krpc_encode_callback_string, &moduleName));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_list_object(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Parts_WithName(krpc_connection_t connection, krpc_list_object_t * returnValue, krpc_SpaceCenter_Parts_t instance, const char * name) {
  krpc_call_t _call;
  krpc_argument_t _arguments[2];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Parts_WithName", 2, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  KRPC_CHECK(krpc_add_argument(&_call, 1, &krpc_encode_callback_string, &name));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_list_object(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Parts_WithTag(krpc_connection_t connection, krpc_list_object_t * returnValue, krpc_SpaceCenter_Parts_t instance, const char * tag) {
  krpc_call_t _call;
  krpc_argument_t _arguments[2];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Parts_WithTag", 2, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  KRPC_CHECK(krpc_add_argument(&_call, 1, &krpc_encode_callback_string, &tag));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_list_object(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Parts_WithTitle(krpc_connection_t connection, krpc_list_object_t * returnValue, krpc_SpaceCenter_Parts_t instance, const char * title) {
  krpc_call_t _call;
  krpc_argument_t _arguments[2];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Parts_WithTitle", 2, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  KRPC_CHECK(krpc_add_argument(&_call, 1, &krpc_encode_callback_string, &title));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_list_object(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Parts_ResourceConverters(krpc_connection_t connection, krpc_list_object_t * returnValue, krpc_SpaceCenter_Parts_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Parts_get_ResourceConverters", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_list_object(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Parts_Engines(krpc_connection_t connection, krpc_list_object_t * returnValue, krpc_SpaceCenter_Parts_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Parts_get_Engines", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_list_object(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Parts_RCS(krpc_connection_t connection, krpc_list_object_t * returnValue, krpc_SpaceCenter_Parts_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Parts_get_RCS", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_list_object(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Parts_Lights(krpc_connection_t connection, krpc_list_object_t * returnValue, krpc_SpaceCenter_Parts_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Parts_get_Lights", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_list_object(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Parts_ResourceHarvesters(krpc_connection_t connection, krpc_list_object_t * returnValue, krpc_SpaceCenter_Parts_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Parts_get_ResourceHarvesters", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_list_object(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Parts_Legs(krpc_connection_t connection, krpc_list_object_t * returnValue, krpc_SpaceCenter_Parts_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Parts_get_Legs", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_list_object(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Parts_LaunchClamps(krpc_connection_t connection, krpc_list_object_t * returnValue, krpc_SpaceCenter_Parts_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Parts_get_LaunchClamps", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_list_object(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Parts_set_Controlling(krpc_connection_t connection, krpc_SpaceCenter_Parts_t instance, krpc_SpaceCenter_Part_t value) {
  krpc_call_t _call;
  krpc_argument_t _arguments[2];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Parts_set_Controlling", 2, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  KRPC_CHECK(krpc_add_argument(&_call, 1, &krpc_encode_callback_object, &value));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Parts_Fairings(krpc_connection_t connection, krpc_list_object_t * returnValue, krpc_SpaceCenter_Parts_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Parts_get_Fairings", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_list_object(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Parts_CargoBays(krpc_connection_t connection, krpc_list_object_t * returnValue, krpc_SpaceCenter_Parts_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Parts_get_CargoBays", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_list_object(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Parts_Controlling(krpc_connection_t connection, krpc_SpaceCenter_Part_t * returnValue, krpc_SpaceCenter_Parts_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Parts_get_Controlling", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_object(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Parts_DockingPorts(krpc_connection_t connection, krpc_list_object_t * returnValue, krpc_SpaceCenter_Parts_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Parts_get_DockingPorts", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_list_object(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Parts_Intakes(krpc_connection_t connection, krpc_list_object_t * returnValue, krpc_SpaceCenter_Parts_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Parts_get_Intakes", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_list_object(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Parts_Sensors(krpc_connection_t connection, krpc_list_object_t * returnValue, krpc_SpaceCenter_Parts_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Parts_get_Sensors", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_list_object(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Parts_ControlSurfaces(krpc_connection_t connection, krpc_list_object_t * returnValue, krpc_SpaceCenter_Parts_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Parts_get_ControlSurfaces", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_list_object(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Parts_Antennas(krpc_connection_t connection, krpc_list_object_t * returnValue, krpc_SpaceCenter_Parts_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Parts_get_Antennas", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_list_object(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Parts_Parachutes(krpc_connection_t connection, krpc_list_object_t * returnValue, krpc_SpaceCenter_Parts_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Parts_get_Parachutes", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_list_object(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Parts_Wheels(krpc_connection_t connection, krpc_list_object_t * returnValue, krpc_SpaceCenter_Parts_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Parts_get_Wheels", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_list_object(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Parts_Root(krpc_connection_t connection, krpc_SpaceCenter_Part_t * returnValue, krpc_SpaceCenter_Parts_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Parts_get_Root", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_object(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Parts_All(krpc_connection_t connection, krpc_list_object_t * returnValue, krpc_SpaceCenter_Parts_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Parts_get_All", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_list_object(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Parts_ReactionWheels(krpc_connection_t connection, krpc_list_object_t * returnValue, krpc_SpaceCenter_Parts_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Parts_get_ReactionWheels", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_list_object(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Parts_Radiators(krpc_connection_t connection, krpc_list_object_t * returnValue, krpc_SpaceCenter_Parts_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Parts_get_Radiators", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_list_object(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Parts_SolarPanels(krpc_connection_t connection, krpc_list_object_t * returnValue, krpc_SpaceCenter_Parts_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Parts_get_SolarPanels", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_list_object(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Parts_Experiments(krpc_connection_t connection, krpc_list_object_t * returnValue, krpc_SpaceCenter_Parts_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Parts_get_Experiments", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_list_object(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Parts_Decouplers(krpc_connection_t connection, krpc_list_object_t * returnValue, krpc_SpaceCenter_Parts_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Parts_get_Decouplers", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_list_object(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Propellant_Ratio(krpc_connection_t connection, float * returnValue, krpc_SpaceCenter_Propellant_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Propellant_get_Ratio", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_float(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Propellant_Name(krpc_connection_t connection, char * * returnValue, krpc_SpaceCenter_Propellant_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Propellant_get_Name", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_string(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Propellant_IgnoreForThrustCurve(krpc_connection_t connection, bool * returnValue, krpc_SpaceCenter_Propellant_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Propellant_get_IgnoreForThrustCurve", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_bool(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Propellant_IgnoreForIsp(krpc_connection_t connection, bool * returnValue, krpc_SpaceCenter_Propellant_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Propellant_get_IgnoreForIsp", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_bool(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Propellant_CurrentAmount(krpc_connection_t connection, double * returnValue, krpc_SpaceCenter_Propellant_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Propellant_get_CurrentAmount", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_double(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Propellant_IsDeprived(krpc_connection_t connection, bool * returnValue, krpc_SpaceCenter_Propellant_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Propellant_get_IsDeprived", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_bool(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Propellant_DrawStackGauge(krpc_connection_t connection, bool * returnValue, krpc_SpaceCenter_Propellant_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Propellant_get_DrawStackGauge", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_bool(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Propellant_CurrentRequirement(krpc_connection_t connection, double * returnValue, krpc_SpaceCenter_Propellant_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Propellant_get_CurrentRequirement", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_double(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Propellant_TotalResourceAvailable(krpc_connection_t connection, double * returnValue, krpc_SpaceCenter_Propellant_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Propellant_get_TotalResourceAvailable", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_double(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Propellant_TotalResourceCapacity(krpc_connection_t connection, double * returnValue, krpc_SpaceCenter_Propellant_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Propellant_get_TotalResourceCapacity", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_double(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_RCS_MaxVacuumThrust(krpc_connection_t connection, float * returnValue, krpc_SpaceCenter_RCS_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "RCS_get_MaxVacuumThrust", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_float(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_RCS_RollEnabled(krpc_connection_t connection, bool * returnValue, krpc_SpaceCenter_RCS_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "RCS_get_RollEnabled", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_bool(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_RCS_set_Enabled(krpc_connection_t connection, krpc_SpaceCenter_RCS_t instance, bool value) {
  krpc_call_t _call;
  krpc_argument_t _arguments[2];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "RCS_set_Enabled", 2, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  KRPC_CHECK(krpc_add_argument(&_call, 1, &krpc_encode_callback_bool, &value));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_RCS_ForwardEnabled(krpc_connection_t connection, bool * returnValue, krpc_SpaceCenter_RCS_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "RCS_get_ForwardEnabled", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_bool(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_RCS_MaxThrust(krpc_connection_t connection, float * returnValue, krpc_SpaceCenter_RCS_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "RCS_get_MaxThrust", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_float(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_RCS_set_RightEnabled(krpc_connection_t connection, krpc_SpaceCenter_RCS_t instance, bool value) {
  krpc_call_t _call;
  krpc_argument_t _arguments[2];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "RCS_set_RightEnabled", 2, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  KRPC_CHECK(krpc_add_argument(&_call, 1, &krpc_encode_callback_bool, &value));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_RCS_Part(krpc_connection_t connection, krpc_SpaceCenter_Part_t * returnValue, krpc_SpaceCenter_RCS_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "RCS_get_Part", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_object(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_RCS_Thrusters(krpc_connection_t connection, krpc_list_object_t * returnValue, krpc_SpaceCenter_RCS_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "RCS_get_Thrusters", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_list_object(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_RCS_Active(krpc_connection_t connection, bool * returnValue, krpc_SpaceCenter_RCS_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "RCS_get_Active", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_bool(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_RCS_Propellants(krpc_connection_t connection, krpc_list_string_t * returnValue, krpc_SpaceCenter_RCS_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "RCS_get_Propellants", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_list_string(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_RCS_HasFuel(krpc_connection_t connection, bool * returnValue, krpc_SpaceCenter_RCS_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "RCS_get_HasFuel", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_bool(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_RCS_PropellantRatios(krpc_connection_t connection, krpc_dictionary_string_float_t * returnValue, krpc_SpaceCenter_RCS_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "RCS_get_PropellantRatios", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_dictionary_string_float(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_RCS_Enabled(krpc_connection_t connection, bool * returnValue, krpc_SpaceCenter_RCS_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "RCS_get_Enabled", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_bool(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_RCS_PitchEnabled(krpc_connection_t connection, bool * returnValue, krpc_SpaceCenter_RCS_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "RCS_get_PitchEnabled", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_bool(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_RCS_set_UpEnabled(krpc_connection_t connection, krpc_SpaceCenter_RCS_t instance, bool value) {
  krpc_call_t _call;
  krpc_argument_t _arguments[2];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "RCS_set_UpEnabled", 2, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  KRPC_CHECK(krpc_add_argument(&_call, 1, &krpc_encode_callback_bool, &value));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_RCS_set_YawEnabled(krpc_connection_t connection, krpc_SpaceCenter_RCS_t instance, bool value) {
  krpc_call_t _call;
  krpc_argument_t _arguments[2];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "RCS_set_YawEnabled", 2, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  KRPC_CHECK(krpc_add_argument(&_call, 1, &krpc_encode_callback_bool, &value));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_RCS_set_PitchEnabled(krpc_connection_t connection, krpc_SpaceCenter_RCS_t instance, bool value) {
  krpc_call_t _call;
  krpc_argument_t _arguments[2];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "RCS_set_PitchEnabled", 2, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  KRPC_CHECK(krpc_add_argument(&_call, 1, &krpc_encode_callback_bool, &value));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_RCS_KerbinSeaLevelSpecificImpulse(krpc_connection_t connection, float * returnValue, krpc_SpaceCenter_RCS_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "RCS_get_KerbinSeaLevelSpecificImpulse", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_float(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_RCS_RightEnabled(krpc_connection_t connection, bool * returnValue, krpc_SpaceCenter_RCS_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "RCS_get_RightEnabled", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_bool(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_RCS_AvailableTorque(krpc_connection_t connection, krpc_tuple_tuple_double_double_double_tuple_double_double_double_t * returnValue, krpc_SpaceCenter_RCS_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "RCS_get_AvailableTorque", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_tuple_tuple_double_double_double_tuple_double_double_double(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_RCS_SpecificImpulse(krpc_connection_t connection, float * returnValue, krpc_SpaceCenter_RCS_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "RCS_get_SpecificImpulse", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_float(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_RCS_set_ForwardEnabled(krpc_connection_t connection, krpc_SpaceCenter_RCS_t instance, bool value) {
  krpc_call_t _call;
  krpc_argument_t _arguments[2];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "RCS_set_ForwardEnabled", 2, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  KRPC_CHECK(krpc_add_argument(&_call, 1, &krpc_encode_callback_bool, &value));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_RCS_UpEnabled(krpc_connection_t connection, bool * returnValue, krpc_SpaceCenter_RCS_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "RCS_get_UpEnabled", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_bool(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_RCS_set_RollEnabled(krpc_connection_t connection, krpc_SpaceCenter_RCS_t instance, bool value) {
  krpc_call_t _call;
  krpc_argument_t _arguments[2];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "RCS_set_RollEnabled", 2, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  KRPC_CHECK(krpc_add_argument(&_call, 1, &krpc_encode_callback_bool, &value));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_RCS_VacuumSpecificImpulse(krpc_connection_t connection, float * returnValue, krpc_SpaceCenter_RCS_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "RCS_get_VacuumSpecificImpulse", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_float(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_RCS_YawEnabled(krpc_connection_t connection, bool * returnValue, krpc_SpaceCenter_RCS_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "RCS_get_YawEnabled", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_bool(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Radiator_set_Deployed(krpc_connection_t connection, krpc_SpaceCenter_Radiator_t instance, bool value) {
  krpc_call_t _call;
  krpc_argument_t _arguments[2];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Radiator_set_Deployed", 2, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  KRPC_CHECK(krpc_add_argument(&_call, 1, &krpc_encode_callback_bool, &value));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Radiator_State(krpc_connection_t connection, krpc_SpaceCenter_RadiatorState_t * returnValue, krpc_SpaceCenter_Radiator_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Radiator_get_State", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_enum(&_stream, (int*)returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Radiator_Part(krpc_connection_t connection, krpc_SpaceCenter_Part_t * returnValue, krpc_SpaceCenter_Radiator_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Radiator_get_Part", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_object(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Radiator_Deployed(krpc_connection_t connection, bool * returnValue, krpc_SpaceCenter_Radiator_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Radiator_get_Deployed", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_bool(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Radiator_Deployable(krpc_connection_t connection, bool * returnValue, krpc_SpaceCenter_Radiator_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Radiator_get_Deployable", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_bool(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_ReactionWheel_MaxTorque(krpc_connection_t connection, krpc_tuple_tuple_double_double_double_tuple_double_double_double_t * returnValue, krpc_SpaceCenter_ReactionWheel_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "ReactionWheel_get_MaxTorque", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_tuple_tuple_double_double_double_tuple_double_double_double(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_ReactionWheel_set_Active(krpc_connection_t connection, krpc_SpaceCenter_ReactionWheel_t instance, bool value) {
  krpc_call_t _call;
  krpc_argument_t _arguments[2];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "ReactionWheel_set_Active", 2, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  KRPC_CHECK(krpc_add_argument(&_call, 1, &krpc_encode_callback_bool, &value));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_ReactionWheel_Broken(krpc_connection_t connection, bool * returnValue, krpc_SpaceCenter_ReactionWheel_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "ReactionWheel_get_Broken", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_bool(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_ReactionWheel_Part(krpc_connection_t connection, krpc_SpaceCenter_Part_t * returnValue, krpc_SpaceCenter_ReactionWheel_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "ReactionWheel_get_Part", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_object(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_ReactionWheel_Active(krpc_connection_t connection, bool * returnValue, krpc_SpaceCenter_ReactionWheel_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "ReactionWheel_get_Active", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_bool(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_ReactionWheel_AvailableTorque(krpc_connection_t connection, krpc_tuple_tuple_double_double_double_tuple_double_double_double_t * returnValue, krpc_SpaceCenter_ReactionWheel_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "ReactionWheel_get_AvailableTorque", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_tuple_tuple_double_double_double_tuple_double_double_double(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_ReferenceFrame_CreateHybrid(krpc_connection_t connection, krpc_SpaceCenter_ReferenceFrame_t * returnValue, krpc_SpaceCenter_ReferenceFrame_t position, krpc_SpaceCenter_ReferenceFrame_t rotation, krpc_SpaceCenter_ReferenceFrame_t velocity, krpc_SpaceCenter_ReferenceFrame_t angularVelocity) {
  krpc_call_t _call;
  krpc_argument_t _arguments[4];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "ReferenceFrame_static_CreateHybrid", 4, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_object, &position));
  KRPC_CHECK(krpc_add_argument(&_call, 1, &krpc_encode_callback_object, &rotation));
  KRPC_CHECK(krpc_add_argument(&_call, 2, &krpc_encode_callback_object, &velocity));
  KRPC_CHECK(krpc_add_argument(&_call, 3, &krpc_encode_callback_object, &angularVelocity));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_object(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_ReferenceFrame_CreateRelative(krpc_connection_t connection, krpc_SpaceCenter_ReferenceFrame_t * returnValue, krpc_SpaceCenter_ReferenceFrame_t referenceFrame, const krpc_tuple_double_double_double_t * position, const krpc_tuple_double_double_double_double_t * rotation, const krpc_tuple_double_double_double_t * velocity, const krpc_tuple_double_double_double_t * angularVelocity) {
  krpc_call_t _call;
  krpc_argument_t _arguments[5];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "ReferenceFrame_static_CreateRelative", 5, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_object, &referenceFrame));
  KRPC_CHECK(krpc_add_argument(&_call, 1, &krpc_encode_callback_tuple_double_double_double, position));
  KRPC_CHECK(krpc_add_argument(&_call, 2, &krpc_encode_callback_tuple_double_double_double_double, rotation));
  KRPC_CHECK(krpc_add_argument(&_call, 3, &krpc_encode_callback_tuple_double_double_double, velocity));
  KRPC_CHECK(krpc_add_argument(&_call, 4, &krpc_encode_callback_tuple_double_double_double, angularVelocity));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_object(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Resource_Name(krpc_connection_t connection, char * * returnValue, krpc_SpaceCenter_Resource_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Resource_get_Name", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_string(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Resource_Density(krpc_connection_t connection, float * returnValue, krpc_SpaceCenter_Resource_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Resource_get_Density", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_float(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Resource_Max(krpc_connection_t connection, float * returnValue, krpc_SpaceCenter_Resource_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Resource_get_Max", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_float(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Resource_Enabled(krpc_connection_t connection, bool * returnValue, krpc_SpaceCenter_Resource_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Resource_get_Enabled", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_bool(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Resource_FlowMode(krpc_connection_t connection, krpc_SpaceCenter_ResourceFlowMode_t * returnValue, krpc_SpaceCenter_Resource_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Resource_get_FlowMode", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_enum(&_stream, (int*)returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Resource_Amount(krpc_connection_t connection, float * returnValue, krpc_SpaceCenter_Resource_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Resource_get_Amount", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_float(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Resource_Part(krpc_connection_t connection, krpc_SpaceCenter_Part_t * returnValue, krpc_SpaceCenter_Resource_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Resource_get_Part", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_object(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Resource_set_Enabled(krpc_connection_t connection, krpc_SpaceCenter_Resource_t instance, bool value) {
  krpc_call_t _call;
  krpc_argument_t _arguments[2];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Resource_set_Enabled", 2, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  KRPC_CHECK(krpc_add_argument(&_call, 1, &krpc_encode_callback_bool, &value));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_ResourceConverter_Active(krpc_connection_t connection, bool * returnValue, krpc_SpaceCenter_ResourceConverter_t instance, int32_t index) {
  krpc_call_t _call;
  krpc_argument_t _arguments[2];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "ResourceConverter_Active", 2, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  KRPC_CHECK(krpc_add_argument(&_call, 1, &krpc_encode_callback_int32, &index));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_bool(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_ResourceConverter_Inputs(krpc_connection_t connection, krpc_list_string_t * returnValue, krpc_SpaceCenter_ResourceConverter_t instance, int32_t index) {
  krpc_call_t _call;
  krpc_argument_t _arguments[2];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "ResourceConverter_Inputs", 2, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  KRPC_CHECK(krpc_add_argument(&_call, 1, &krpc_encode_callback_int32, &index));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_list_string(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_ResourceConverter_Name(krpc_connection_t connection, char * * returnValue, krpc_SpaceCenter_ResourceConverter_t instance, int32_t index) {
  krpc_call_t _call;
  krpc_argument_t _arguments[2];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "ResourceConverter_Name", 2, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  KRPC_CHECK(krpc_add_argument(&_call, 1, &krpc_encode_callback_int32, &index));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_string(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_ResourceConverter_Outputs(krpc_connection_t connection, krpc_list_string_t * returnValue, krpc_SpaceCenter_ResourceConverter_t instance, int32_t index) {
  krpc_call_t _call;
  krpc_argument_t _arguments[2];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "ResourceConverter_Outputs", 2, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  KRPC_CHECK(krpc_add_argument(&_call, 1, &krpc_encode_callback_int32, &index));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_list_string(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_ResourceConverter_Start(krpc_connection_t connection, krpc_SpaceCenter_ResourceConverter_t instance, int32_t index) {
  krpc_call_t _call;
  krpc_argument_t _arguments[2];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "ResourceConverter_Start", 2, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  KRPC_CHECK(krpc_add_argument(&_call, 1, &krpc_encode_callback_int32, &index));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_ResourceConverter_State(krpc_connection_t connection, krpc_SpaceCenter_ResourceConverterState_t * returnValue, krpc_SpaceCenter_ResourceConverter_t instance, int32_t index) {
  krpc_call_t _call;
  krpc_argument_t _arguments[2];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "ResourceConverter_State", 2, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  KRPC_CHECK(krpc_add_argument(&_call, 1, &krpc_encode_callback_int32, &index));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_enum(&_stream, (int*)returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_ResourceConverter_StatusInfo(krpc_connection_t connection, char * * returnValue, krpc_SpaceCenter_ResourceConverter_t instance, int32_t index) {
  krpc_call_t _call;
  krpc_argument_t _arguments[2];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "ResourceConverter_StatusInfo", 2, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  KRPC_CHECK(krpc_add_argument(&_call, 1, &krpc_encode_callback_int32, &index));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_string(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_ResourceConverter_Stop(krpc_connection_t connection, krpc_SpaceCenter_ResourceConverter_t instance, int32_t index) {
  krpc_call_t _call;
  krpc_argument_t _arguments[2];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "ResourceConverter_Stop", 2, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  KRPC_CHECK(krpc_add_argument(&_call, 1, &krpc_encode_callback_int32, &index));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_ResourceConverter_Count(krpc_connection_t connection, int32_t * returnValue, krpc_SpaceCenter_ResourceConverter_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "ResourceConverter_get_Count", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_int32(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_ResourceConverter_Part(krpc_connection_t connection, krpc_SpaceCenter_Part_t * returnValue, krpc_SpaceCenter_ResourceConverter_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "ResourceConverter_get_Part", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_object(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_ResourceHarvester_set_Deployed(krpc_connection_t connection, krpc_SpaceCenter_ResourceHarvester_t instance, bool value) {
  krpc_call_t _call;
  krpc_argument_t _arguments[2];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "ResourceHarvester_set_Deployed", 2, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  KRPC_CHECK(krpc_add_argument(&_call, 1, &krpc_encode_callback_bool, &value));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_ResourceHarvester_ThermalEfficiency(krpc_connection_t connection, float * returnValue, krpc_SpaceCenter_ResourceHarvester_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "ResourceHarvester_get_ThermalEfficiency", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_float(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_ResourceHarvester_OptimumCoreTemperature(krpc_connection_t connection, float * returnValue, krpc_SpaceCenter_ResourceHarvester_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "ResourceHarvester_get_OptimumCoreTemperature", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_float(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_ResourceHarvester_set_Active(krpc_connection_t connection, krpc_SpaceCenter_ResourceHarvester_t instance, bool value) {
  krpc_call_t _call;
  krpc_argument_t _arguments[2];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "ResourceHarvester_set_Active", 2, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  KRPC_CHECK(krpc_add_argument(&_call, 1, &krpc_encode_callback_bool, &value));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_ResourceHarvester_ExtractionRate(krpc_connection_t connection, float * returnValue, krpc_SpaceCenter_ResourceHarvester_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "ResourceHarvester_get_ExtractionRate", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_float(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_ResourceHarvester_State(krpc_connection_t connection, krpc_SpaceCenter_ResourceHarvesterState_t * returnValue, krpc_SpaceCenter_ResourceHarvester_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "ResourceHarvester_get_State", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_enum(&_stream, (int*)returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_ResourceHarvester_Part(krpc_connection_t connection, krpc_SpaceCenter_Part_t * returnValue, krpc_SpaceCenter_ResourceHarvester_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "ResourceHarvester_get_Part", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_object(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_ResourceHarvester_CoreTemperature(krpc_connection_t connection, float * returnValue, krpc_SpaceCenter_ResourceHarvester_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "ResourceHarvester_get_CoreTemperature", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_float(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_ResourceHarvester_Active(krpc_connection_t connection, bool * returnValue, krpc_SpaceCenter_ResourceHarvester_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "ResourceHarvester_get_Active", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_bool(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_ResourceHarvester_Deployed(krpc_connection_t connection, bool * returnValue, krpc_SpaceCenter_ResourceHarvester_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "ResourceHarvester_get_Deployed", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_bool(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_ResourceTransfer_Amount(krpc_connection_t connection, float * returnValue, krpc_SpaceCenter_ResourceTransfer_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "ResourceTransfer_get_Amount", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_float(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_ResourceTransfer_Complete(krpc_connection_t connection, bool * returnValue, krpc_SpaceCenter_ResourceTransfer_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "ResourceTransfer_get_Complete", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_bool(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_ResourceTransfer_Start(krpc_connection_t connection, krpc_SpaceCenter_ResourceTransfer_t * returnValue, krpc_SpaceCenter_Part_t fromPart, krpc_SpaceCenter_Part_t toPart, const char * resource, float maxAmount) {
  krpc_call_t _call;
  krpc_argument_t _arguments[4];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "ResourceTransfer_static_Start", 4, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_object, &fromPart));
  KRPC_CHECK(krpc_add_argument(&_call, 1, &krpc_encode_callback_object, &toPart));
  KRPC_CHECK(krpc_add_argument(&_call, 2, &krpc_encode_callback_string, &resource));
  KRPC_CHECK(krpc_add_argument(&_call, 3, &krpc_encode_callback_float, &maxAmount));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_object(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Resources_Amount(krpc_connection_t connection, float * returnValue, krpc_SpaceCenter_Resources_t instance, const char * name) {
  krpc_call_t _call;
  krpc_argument_t _arguments[2];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Resources_Amount", 2, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  KRPC_CHECK(krpc_add_argument(&_call, 1, &krpc_encode_callback_string, &name));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_float(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Resources_HasResource(krpc_connection_t connection, bool * returnValue, krpc_SpaceCenter_Resources_t instance, const char * name) {
  krpc_call_t _call;
  krpc_argument_t _arguments[2];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Resources_HasResource", 2, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  KRPC_CHECK(krpc_add_argument(&_call, 1, &krpc_encode_callback_string, &name));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_bool(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Resources_Max(krpc_connection_t connection, float * returnValue, krpc_SpaceCenter_Resources_t instance, const char * name) {
  krpc_call_t _call;
  krpc_argument_t _arguments[2];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Resources_Max", 2, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  KRPC_CHECK(krpc_add_argument(&_call, 1, &krpc_encode_callback_string, &name));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_float(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Resources_WithResource(krpc_connection_t connection, krpc_list_object_t * returnValue, krpc_SpaceCenter_Resources_t instance, const char * name) {
  krpc_call_t _call;
  krpc_argument_t _arguments[2];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Resources_WithResource", 2, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  KRPC_CHECK(krpc_add_argument(&_call, 1, &krpc_encode_callback_string, &name));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_list_object(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Resources_set_Enabled(krpc_connection_t connection, krpc_SpaceCenter_Resources_t instance, bool value) {
  krpc_call_t _call;
  krpc_argument_t _arguments[2];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Resources_set_Enabled", 2, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  KRPC_CHECK(krpc_add_argument(&_call, 1, &krpc_encode_callback_bool, &value));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Resources_All(krpc_connection_t connection, krpc_list_object_t * returnValue, krpc_SpaceCenter_Resources_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Resources_get_All", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_list_object(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Resources_Enabled(krpc_connection_t connection, bool * returnValue, krpc_SpaceCenter_Resources_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Resources_get_Enabled", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_bool(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Resources_Names(krpc_connection_t connection, krpc_list_string_t * returnValue, krpc_SpaceCenter_Resources_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Resources_get_Names", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_list_string(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Resources_Density(krpc_connection_t connection, float * returnValue, const char * name) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Resources_static_Density", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_string, &name));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_float(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Resources_FlowMode(krpc_connection_t connection, krpc_SpaceCenter_ResourceFlowMode_t * returnValue, const char * name) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Resources_static_FlowMode", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_string, &name));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_enum(&_stream, (int*)returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_ScienceData_TransmitValue(krpc_connection_t connection, float * returnValue, krpc_SpaceCenter_ScienceData_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "ScienceData_get_TransmitValue", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_float(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_ScienceData_ScienceValue(krpc_connection_t connection, float * returnValue, krpc_SpaceCenter_ScienceData_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "ScienceData_get_ScienceValue", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_float(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_ScienceData_DataAmount(krpc_connection_t connection, float * returnValue, krpc_SpaceCenter_ScienceData_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "ScienceData_get_DataAmount", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_float(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_ScienceSubject_Title(krpc_connection_t connection, char * * returnValue, krpc_SpaceCenter_ScienceSubject_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "ScienceSubject_get_Title", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_string(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_ScienceSubject_Science(krpc_connection_t connection, float * returnValue, krpc_SpaceCenter_ScienceSubject_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "ScienceSubject_get_Science", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_float(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_ScienceSubject_DataScale(krpc_connection_t connection, float * returnValue, krpc_SpaceCenter_ScienceSubject_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "ScienceSubject_get_DataScale", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_float(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_ScienceSubject_IsComplete(krpc_connection_t connection, bool * returnValue, krpc_SpaceCenter_ScienceSubject_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "ScienceSubject_get_IsComplete", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_bool(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_ScienceSubject_ScienceCap(krpc_connection_t connection, float * returnValue, krpc_SpaceCenter_ScienceSubject_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "ScienceSubject_get_ScienceCap", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_float(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_ScienceSubject_ScientificValue(krpc_connection_t connection, float * returnValue, krpc_SpaceCenter_ScienceSubject_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "ScienceSubject_get_ScientificValue", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_float(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_ScienceSubject_SubjectValue(krpc_connection_t connection, float * returnValue, krpc_SpaceCenter_ScienceSubject_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "ScienceSubject_get_SubjectValue", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_float(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Sensor_Active(krpc_connection_t connection, bool * returnValue, krpc_SpaceCenter_Sensor_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Sensor_get_Active", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_bool(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Sensor_Part(krpc_connection_t connection, krpc_SpaceCenter_Part_t * returnValue, krpc_SpaceCenter_Sensor_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Sensor_get_Part", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_object(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Sensor_Value(krpc_connection_t connection, char * * returnValue, krpc_SpaceCenter_Sensor_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Sensor_get_Value", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_string(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Sensor_set_Active(krpc_connection_t connection, krpc_SpaceCenter_Sensor_t instance, bool value) {
  krpc_call_t _call;
  krpc_argument_t _arguments[2];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Sensor_set_Active", 2, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  KRPC_CHECK(krpc_add_argument(&_call, 1, &krpc_encode_callback_bool, &value));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_SolarPanel_set_Deployed(krpc_connection_t connection, krpc_SpaceCenter_SolarPanel_t instance, bool value) {
  krpc_call_t _call;
  krpc_argument_t _arguments[2];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "SolarPanel_set_Deployed", 2, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  KRPC_CHECK(krpc_add_argument(&_call, 1, &krpc_encode_callback_bool, &value));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_SolarPanel_EnergyFlow(krpc_connection_t connection, float * returnValue, krpc_SpaceCenter_SolarPanel_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "SolarPanel_get_EnergyFlow", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_float(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_SolarPanel_Deployable(krpc_connection_t connection, bool * returnValue, krpc_SpaceCenter_SolarPanel_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "SolarPanel_get_Deployable", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_bool(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_SolarPanel_State(krpc_connection_t connection, krpc_SpaceCenter_SolarPanelState_t * returnValue, krpc_SpaceCenter_SolarPanel_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "SolarPanel_get_State", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_enum(&_stream, (int*)returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_SolarPanel_Part(krpc_connection_t connection, krpc_SpaceCenter_Part_t * returnValue, krpc_SpaceCenter_SolarPanel_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "SolarPanel_get_Part", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_object(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_SolarPanel_SunExposure(krpc_connection_t connection, float * returnValue, krpc_SpaceCenter_SolarPanel_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "SolarPanel_get_SunExposure", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_float(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_SolarPanel_Deployed(krpc_connection_t connection, bool * returnValue, krpc_SpaceCenter_SolarPanel_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "SolarPanel_get_Deployed", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_bool(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Thruster_GimbalPosition(krpc_connection_t connection, krpc_tuple_double_double_double_t * returnValue, krpc_SpaceCenter_Thruster_t instance, krpc_SpaceCenter_ReferenceFrame_t referenceFrame) {
  krpc_call_t _call;
  krpc_argument_t _arguments[2];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Thruster_GimbalPosition", 2, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  KRPC_CHECK(krpc_add_argument(&_call, 1, &krpc_encode_callback_object, &referenceFrame));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_tuple_double_double_double(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Thruster_InitialThrustDirection(krpc_connection_t connection, krpc_tuple_double_double_double_t * returnValue, krpc_SpaceCenter_Thruster_t instance, krpc_SpaceCenter_ReferenceFrame_t referenceFrame) {
  krpc_call_t _call;
  krpc_argument_t _arguments[2];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Thruster_InitialThrustDirection", 2, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  KRPC_CHECK(krpc_add_argument(&_call, 1, &krpc_encode_callback_object, &referenceFrame));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_tuple_double_double_double(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Thruster_InitialThrustPosition(krpc_connection_t connection, krpc_tuple_double_double_double_t * returnValue, krpc_SpaceCenter_Thruster_t instance, krpc_SpaceCenter_ReferenceFrame_t referenceFrame) {
  krpc_call_t _call;
  krpc_argument_t _arguments[2];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Thruster_InitialThrustPosition", 2, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  KRPC_CHECK(krpc_add_argument(&_call, 1, &krpc_encode_callback_object, &referenceFrame));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_tuple_double_double_double(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Thruster_ThrustDirection(krpc_connection_t connection, krpc_tuple_double_double_double_t * returnValue, krpc_SpaceCenter_Thruster_t instance, krpc_SpaceCenter_ReferenceFrame_t referenceFrame) {
  krpc_call_t _call;
  krpc_argument_t _arguments[2];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Thruster_ThrustDirection", 2, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  KRPC_CHECK(krpc_add_argument(&_call, 1, &krpc_encode_callback_object, &referenceFrame));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_tuple_double_double_double(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Thruster_ThrustPosition(krpc_connection_t connection, krpc_tuple_double_double_double_t * returnValue, krpc_SpaceCenter_Thruster_t instance, krpc_SpaceCenter_ReferenceFrame_t referenceFrame) {
  krpc_call_t _call;
  krpc_argument_t _arguments[2];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Thruster_ThrustPosition", 2, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  KRPC_CHECK(krpc_add_argument(&_call, 1, &krpc_encode_callback_object, &referenceFrame));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_tuple_double_double_double(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Thruster_ThrustReferenceFrame(krpc_connection_t connection, krpc_SpaceCenter_ReferenceFrame_t * returnValue, krpc_SpaceCenter_Thruster_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Thruster_get_ThrustReferenceFrame", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_object(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Thruster_Gimballed(krpc_connection_t connection, bool * returnValue, krpc_SpaceCenter_Thruster_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Thruster_get_Gimballed", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_bool(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Thruster_Part(krpc_connection_t connection, krpc_SpaceCenter_Part_t * returnValue, krpc_SpaceCenter_Thruster_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Thruster_get_Part", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_object(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Thruster_GimbalAngle(krpc_connection_t connection, krpc_tuple_double_double_double_t * returnValue, krpc_SpaceCenter_Thruster_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Thruster_get_GimbalAngle", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_tuple_double_double_double(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Vessel_AngularVelocity(krpc_connection_t connection, krpc_tuple_double_double_double_t * returnValue, krpc_SpaceCenter_Vessel_t instance, krpc_SpaceCenter_ReferenceFrame_t referenceFrame) {
  krpc_call_t _call;
  krpc_argument_t _arguments[2];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Vessel_AngularVelocity", 2, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  KRPC_CHECK(krpc_add_argument(&_call, 1, &krpc_encode_callback_object, &referenceFrame));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_tuple_double_double_double(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Vessel_BoundingBox(krpc_connection_t connection, krpc_tuple_tuple_double_double_double_tuple_double_double_double_t * returnValue, krpc_SpaceCenter_Vessel_t instance, krpc_SpaceCenter_ReferenceFrame_t referenceFrame) {
  krpc_call_t _call;
  krpc_argument_t _arguments[2];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Vessel_BoundingBox", 2, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  KRPC_CHECK(krpc_add_argument(&_call, 1, &krpc_encode_callback_object, &referenceFrame));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_tuple_tuple_double_double_double_tuple_double_double_double(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Vessel_Direction(krpc_connection_t connection, krpc_tuple_double_double_double_t * returnValue, krpc_SpaceCenter_Vessel_t instance, krpc_SpaceCenter_ReferenceFrame_t referenceFrame) {
  krpc_call_t _call;
  krpc_argument_t _arguments[2];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Vessel_Direction", 2, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  KRPC_CHECK(krpc_add_argument(&_call, 1, &krpc_encode_callback_object, &referenceFrame));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_tuple_double_double_double(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Vessel_Flight(krpc_connection_t connection, krpc_SpaceCenter_Flight_t * returnValue, krpc_SpaceCenter_Vessel_t instance, krpc_SpaceCenter_ReferenceFrame_t referenceFrame) {
  krpc_call_t _call;
  krpc_argument_t _arguments[2];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Vessel_Flight", 2, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  KRPC_CHECK(krpc_add_argument(&_call, 1, &krpc_encode_callback_object, &referenceFrame));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_object(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Vessel_Position(krpc_connection_t connection, krpc_tuple_double_double_double_t * returnValue, krpc_SpaceCenter_Vessel_t instance, krpc_SpaceCenter_ReferenceFrame_t referenceFrame) {
  krpc_call_t _call;
  krpc_argument_t _arguments[2];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Vessel_Position", 2, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  KRPC_CHECK(krpc_add_argument(&_call, 1, &krpc_encode_callback_object, &referenceFrame));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_tuple_double_double_double(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Vessel_Recover(krpc_connection_t connection, krpc_SpaceCenter_Vessel_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Vessel_Recover", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Vessel_ResourcesInDecoupleStage(krpc_connection_t connection, krpc_SpaceCenter_Resources_t * returnValue, krpc_SpaceCenter_Vessel_t instance, int32_t stage, bool cumulative) {
  krpc_call_t _call;
  krpc_argument_t _arguments[3];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Vessel_ResourcesInDecoupleStage", 3, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  KRPC_CHECK(krpc_add_argument(&_call, 1, &krpc_encode_callback_int32, &stage));
  KRPC_CHECK(krpc_add_argument(&_call, 2, &krpc_encode_callback_bool, &cumulative));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_object(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Vessel_Rotation(krpc_connection_t connection, krpc_tuple_double_double_double_double_t * returnValue, krpc_SpaceCenter_Vessel_t instance, krpc_SpaceCenter_ReferenceFrame_t referenceFrame) {
  krpc_call_t _call;
  krpc_argument_t _arguments[2];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Vessel_Rotation", 2, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  KRPC_CHECK(krpc_add_argument(&_call, 1, &krpc_encode_callback_object, &referenceFrame));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_tuple_double_double_double_double(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Vessel_Velocity(krpc_connection_t connection, krpc_tuple_double_double_double_t * returnValue, krpc_SpaceCenter_Vessel_t instance, krpc_SpaceCenter_ReferenceFrame_t referenceFrame) {
  krpc_call_t _call;
  krpc_argument_t _arguments[2];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Vessel_Velocity", 2, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  KRPC_CHECK(krpc_add_argument(&_call, 1, &krpc_encode_callback_object, &referenceFrame));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_tuple_double_double_double(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Vessel_Biome(krpc_connection_t connection, char * * returnValue, krpc_SpaceCenter_Vessel_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Vessel_get_Biome", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_string(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Vessel_MaxVacuumThrust(krpc_connection_t connection, float * returnValue, krpc_SpaceCenter_Vessel_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Vessel_get_MaxVacuumThrust", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_float(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Vessel_ReferenceFrame(krpc_connection_t connection, krpc_SpaceCenter_ReferenceFrame_t * returnValue, krpc_SpaceCenter_Vessel_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Vessel_get_ReferenceFrame", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_object(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Vessel_Crew(krpc_connection_t connection, krpc_list_object_t * returnValue, krpc_SpaceCenter_Vessel_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Vessel_get_Crew", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_list_object(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Vessel_AvailableOtherTorque(krpc_connection_t connection, krpc_tuple_tuple_double_double_double_tuple_double_double_double_t * returnValue, krpc_SpaceCenter_Vessel_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Vessel_get_AvailableOtherTorque", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_tuple_tuple_double_double_double_tuple_double_double_double(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Vessel_OrbitalReferenceFrame(krpc_connection_t connection, krpc_SpaceCenter_ReferenceFrame_t * returnValue, krpc_SpaceCenter_Vessel_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Vessel_get_OrbitalReferenceFrame", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_object(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Vessel_Type(krpc_connection_t connection, krpc_SpaceCenter_VesselType_t * returnValue, krpc_SpaceCenter_Vessel_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Vessel_get_Type", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_enum(&_stream, (int*)returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Vessel_Resources(krpc_connection_t connection, krpc_SpaceCenter_Resources_t * returnValue, krpc_SpaceCenter_Vessel_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Vessel_get_Resources", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_object(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Vessel_InertiaTensor(krpc_connection_t connection, krpc_list_double_t * returnValue, krpc_SpaceCenter_Vessel_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Vessel_get_InertiaTensor", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_list_double(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Vessel_MaxThrust(krpc_connection_t connection, float * returnValue, krpc_SpaceCenter_Vessel_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Vessel_get_MaxThrust", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_float(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Vessel_MomentOfInertia(krpc_connection_t connection, krpc_tuple_double_double_double_t * returnValue, krpc_SpaceCenter_Vessel_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Vessel_get_MomentOfInertia", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_tuple_double_double_double(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Vessel_set_Type(krpc_connection_t connection, krpc_SpaceCenter_Vessel_t instance, krpc_SpaceCenter_VesselType_t value) {
  krpc_call_t _call;
  krpc_argument_t _arguments[2];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Vessel_set_Type", 2, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  KRPC_CHECK(krpc_add_argument(&_call, 1, &krpc_encode_callback_enum, &value));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Vessel_AvailableRCSTorque(krpc_connection_t connection, krpc_tuple_tuple_double_double_double_tuple_double_double_double_t * returnValue, krpc_SpaceCenter_Vessel_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Vessel_get_AvailableRCSTorque", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_tuple_tuple_double_double_double_tuple_double_double_double(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Vessel_Thrust(krpc_connection_t connection, float * returnValue, krpc_SpaceCenter_Vessel_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Vessel_get_Thrust", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_float(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Vessel_AvailableControlSurfaceTorque(krpc_connection_t connection, krpc_tuple_tuple_double_double_double_tuple_double_double_double_t * returnValue, krpc_SpaceCenter_Vessel_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Vessel_get_AvailableControlSurfaceTorque", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_tuple_tuple_double_double_double_tuple_double_double_double(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Vessel_set_Name(krpc_connection_t connection, krpc_SpaceCenter_Vessel_t instance, const char * value) {
  krpc_call_t _call;
  krpc_argument_t _arguments[2];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Vessel_set_Name", 2, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  KRPC_CHECK(krpc_add_argument(&_call, 1, &krpc_encode_callback_string, &value));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Vessel_AvailableThrust(krpc_connection_t connection, float * returnValue, krpc_SpaceCenter_Vessel_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Vessel_get_AvailableThrust", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_float(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Vessel_Name(krpc_connection_t connection, char * * returnValue, krpc_SpaceCenter_Vessel_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Vessel_get_Name", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_string(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Vessel_Orbit(krpc_connection_t connection, krpc_SpaceCenter_Orbit_t * returnValue, krpc_SpaceCenter_Vessel_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Vessel_get_Orbit", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_object(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Vessel_CrewCount(krpc_connection_t connection, int32_t * returnValue, krpc_SpaceCenter_Vessel_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Vessel_get_CrewCount", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_int32(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Vessel_CrewCapacity(krpc_connection_t connection, int32_t * returnValue, krpc_SpaceCenter_Vessel_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Vessel_get_CrewCapacity", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_int32(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Vessel_Mass(krpc_connection_t connection, float * returnValue, krpc_SpaceCenter_Vessel_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Vessel_get_Mass", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_float(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Vessel_KerbinSeaLevelSpecificImpulse(krpc_connection_t connection, float * returnValue, krpc_SpaceCenter_Vessel_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Vessel_get_KerbinSeaLevelSpecificImpulse", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_float(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Vessel_Situation(krpc_connection_t connection, krpc_SpaceCenter_VesselSituation_t * returnValue, krpc_SpaceCenter_Vessel_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Vessel_get_Situation", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_enum(&_stream, (int*)returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Vessel_SurfaceVelocityReferenceFrame(krpc_connection_t connection, krpc_SpaceCenter_ReferenceFrame_t * returnValue, krpc_SpaceCenter_Vessel_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Vessel_get_SurfaceVelocityReferenceFrame", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_object(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Vessel_AvailableTorque(krpc_connection_t connection, krpc_tuple_tuple_double_double_double_tuple_double_double_double_t * returnValue, krpc_SpaceCenter_Vessel_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Vessel_get_AvailableTorque", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_tuple_tuple_double_double_double_tuple_double_double_double(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Vessel_Recoverable(krpc_connection_t connection, bool * returnValue, krpc_SpaceCenter_Vessel_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Vessel_get_Recoverable", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_bool(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Vessel_Control(krpc_connection_t connection, krpc_SpaceCenter_Control_t * returnValue, krpc_SpaceCenter_Vessel_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Vessel_get_Control", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_object(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Vessel_AvailableEngineTorque(krpc_connection_t connection, krpc_tuple_tuple_double_double_double_tuple_double_double_double_t * returnValue, krpc_SpaceCenter_Vessel_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Vessel_get_AvailableEngineTorque", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_tuple_tuple_double_double_double_tuple_double_double_double(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Vessel_SpecificImpulse(krpc_connection_t connection, float * returnValue, krpc_SpaceCenter_Vessel_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Vessel_get_SpecificImpulse", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_float(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Vessel_Comms(krpc_connection_t connection, krpc_SpaceCenter_Comms_t * returnValue, krpc_SpaceCenter_Vessel_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Vessel_get_Comms", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_object(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Vessel_DryMass(krpc_connection_t connection, float * returnValue, krpc_SpaceCenter_Vessel_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Vessel_get_DryMass", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_float(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Vessel_AvailableReactionWheelTorque(krpc_connection_t connection, krpc_tuple_tuple_double_double_double_tuple_double_double_double_t * returnValue, krpc_SpaceCenter_Vessel_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Vessel_get_AvailableReactionWheelTorque", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_tuple_tuple_double_double_double_tuple_double_double_double(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Vessel_VacuumSpecificImpulse(krpc_connection_t connection, float * returnValue, krpc_SpaceCenter_Vessel_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Vessel_get_VacuumSpecificImpulse", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_float(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Vessel_MET(krpc_connection_t connection, double * returnValue, krpc_SpaceCenter_Vessel_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Vessel_get_MET", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_double(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Vessel_Parts(krpc_connection_t connection, krpc_SpaceCenter_Parts_t * returnValue, krpc_SpaceCenter_Vessel_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Vessel_get_Parts", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_object(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Vessel_AutoPilot(krpc_connection_t connection, krpc_SpaceCenter_AutoPilot_t * returnValue, krpc_SpaceCenter_Vessel_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Vessel_get_AutoPilot", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_object(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Vessel_SurfaceReferenceFrame(krpc_connection_t connection, krpc_SpaceCenter_ReferenceFrame_t * returnValue, krpc_SpaceCenter_Vessel_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Vessel_get_SurfaceReferenceFrame", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_object(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Waypoint_Remove(krpc_connection_t connection, krpc_SpaceCenter_Waypoint_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Waypoint_Remove", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Waypoint_NearSurface(krpc_connection_t connection, bool * returnValue, krpc_SpaceCenter_Waypoint_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Waypoint_get_NearSurface", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_bool(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Waypoint_Index(krpc_connection_t connection, int32_t * returnValue, krpc_SpaceCenter_Waypoint_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Waypoint_get_Index", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_int32(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Waypoint_Grounded(krpc_connection_t connection, bool * returnValue, krpc_SpaceCenter_Waypoint_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Waypoint_get_Grounded", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_bool(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Waypoint_Latitude(krpc_connection_t connection, double * returnValue, krpc_SpaceCenter_Waypoint_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Waypoint_get_Latitude", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_double(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Waypoint_set_SurfaceAltitude(krpc_connection_t connection, krpc_SpaceCenter_Waypoint_t instance, double value) {
  krpc_call_t _call;
  krpc_argument_t _arguments[2];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Waypoint_set_SurfaceAltitude", 2, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  KRPC_CHECK(krpc_add_argument(&_call, 1, &krpc_encode_callback_double, &value));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Waypoint_Body(krpc_connection_t connection, krpc_SpaceCenter_CelestialBody_t * returnValue, krpc_SpaceCenter_Waypoint_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Waypoint_get_Body", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_object(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Waypoint_HasContract(krpc_connection_t connection, bool * returnValue, krpc_SpaceCenter_Waypoint_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Waypoint_get_HasContract", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_bool(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Waypoint_Clustered(krpc_connection_t connection, bool * returnValue, krpc_SpaceCenter_Waypoint_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Waypoint_get_Clustered", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_bool(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Waypoint_Icon(krpc_connection_t connection, char * * returnValue, krpc_SpaceCenter_Waypoint_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Waypoint_get_Icon", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_string(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Waypoint_set_Name(krpc_connection_t connection, krpc_SpaceCenter_Waypoint_t instance, const char * value) {
  krpc_call_t _call;
  krpc_argument_t _arguments[2];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Waypoint_set_Name", 2, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  KRPC_CHECK(krpc_add_argument(&_call, 1, &krpc_encode_callback_string, &value));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Waypoint_Name(krpc_connection_t connection, char * * returnValue, krpc_SpaceCenter_Waypoint_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Waypoint_get_Name", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_string(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Waypoint_set_MeanAltitude(krpc_connection_t connection, krpc_SpaceCenter_Waypoint_t instance, double value) {
  krpc_call_t _call;
  krpc_argument_t _arguments[2];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Waypoint_set_MeanAltitude", 2, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  KRPC_CHECK(krpc_add_argument(&_call, 1, &krpc_encode_callback_double, &value));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Waypoint_MeanAltitude(krpc_connection_t connection, double * returnValue, krpc_SpaceCenter_Waypoint_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Waypoint_get_MeanAltitude", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_double(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Waypoint_Contract(krpc_connection_t connection, krpc_SpaceCenter_Contract_t * returnValue, krpc_SpaceCenter_Waypoint_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Waypoint_get_Contract", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_object(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Waypoint_BedrockAltitude(krpc_connection_t connection, double * returnValue, krpc_SpaceCenter_Waypoint_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Waypoint_get_BedrockAltitude", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_double(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Waypoint_Longitude(krpc_connection_t connection, double * returnValue, krpc_SpaceCenter_Waypoint_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Waypoint_get_Longitude", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_double(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Waypoint_set_Color(krpc_connection_t connection, krpc_SpaceCenter_Waypoint_t instance, int32_t value) {
  krpc_call_t _call;
  krpc_argument_t _arguments[2];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Waypoint_set_Color", 2, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  KRPC_CHECK(krpc_add_argument(&_call, 1, &krpc_encode_callback_int32, &value));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Waypoint_SurfaceAltitude(krpc_connection_t connection, double * returnValue, krpc_SpaceCenter_Waypoint_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Waypoint_get_SurfaceAltitude", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_double(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Waypoint_set_Body(krpc_connection_t connection, krpc_SpaceCenter_Waypoint_t instance, krpc_SpaceCenter_CelestialBody_t value) {
  krpc_call_t _call;
  krpc_argument_t _arguments[2];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Waypoint_set_Body", 2, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  KRPC_CHECK(krpc_add_argument(&_call, 1, &krpc_encode_callback_object, &value));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Waypoint_Color(krpc_connection_t connection, int32_t * returnValue, krpc_SpaceCenter_Waypoint_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Waypoint_get_Color", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_int32(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Waypoint_set_BedrockAltitude(krpc_connection_t connection, krpc_SpaceCenter_Waypoint_t instance, double value) {
  krpc_call_t _call;
  krpc_argument_t _arguments[2];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Waypoint_set_BedrockAltitude", 2, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  KRPC_CHECK(krpc_add_argument(&_call, 1, &krpc_encode_callback_double, &value));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Waypoint_set_Icon(krpc_connection_t connection, krpc_SpaceCenter_Waypoint_t instance, const char * value) {
  krpc_call_t _call;
  krpc_argument_t _arguments[2];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Waypoint_set_Icon", 2, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  KRPC_CHECK(krpc_add_argument(&_call, 1, &krpc_encode_callback_string, &value));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Waypoint_set_Latitude(krpc_connection_t connection, krpc_SpaceCenter_Waypoint_t instance, double value) {
  krpc_call_t _call;
  krpc_argument_t _arguments[2];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Waypoint_set_Latitude", 2, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  KRPC_CHECK(krpc_add_argument(&_call, 1, &krpc_encode_callback_double, &value));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Waypoint_set_Longitude(krpc_connection_t connection, krpc_SpaceCenter_Waypoint_t instance, double value) {
  krpc_call_t _call;
  krpc_argument_t _arguments[2];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Waypoint_set_Longitude", 2, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  KRPC_CHECK(krpc_add_argument(&_call, 1, &krpc_encode_callback_double, &value));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_WaypointManager_AddWaypoint(krpc_connection_t connection, krpc_SpaceCenter_Waypoint_t * returnValue, krpc_SpaceCenter_WaypointManager_t instance, double latitude, double longitude, krpc_SpaceCenter_CelestialBody_t body, const char * name) {
  krpc_call_t _call;
  krpc_argument_t _arguments[5];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "WaypointManager_AddWaypoint", 5, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  KRPC_CHECK(krpc_add_argument(&_call, 1, &krpc_encode_callback_double, &latitude));
  KRPC_CHECK(krpc_add_argument(&_call, 2, &krpc_encode_callback_double, &longitude));
  KRPC_CHECK(krpc_add_argument(&_call, 3, &krpc_encode_callback_object, &body));
  KRPC_CHECK(krpc_add_argument(&_call, 4, &krpc_encode_callback_string, &name));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_object(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_WaypointManager_AddWaypointAtAltitude(krpc_connection_t connection, krpc_SpaceCenter_Waypoint_t * returnValue, krpc_SpaceCenter_WaypointManager_t instance, double latitude, double longitude, double altitude, krpc_SpaceCenter_CelestialBody_t body, const char * name) {
  krpc_call_t _call;
  krpc_argument_t _arguments[6];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "WaypointManager_AddWaypointAtAltitude", 6, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  KRPC_CHECK(krpc_add_argument(&_call, 1, &krpc_encode_callback_double, &latitude));
  KRPC_CHECK(krpc_add_argument(&_call, 2, &krpc_encode_callback_double, &longitude));
  KRPC_CHECK(krpc_add_argument(&_call, 3, &krpc_encode_callback_double, &altitude));
  KRPC_CHECK(krpc_add_argument(&_call, 4, &krpc_encode_callback_object, &body));
  KRPC_CHECK(krpc_add_argument(&_call, 5, &krpc_encode_callback_string, &name));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_object(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_WaypointManager_Colors(krpc_connection_t connection, krpc_dictionary_string_int32_t * returnValue, krpc_SpaceCenter_WaypointManager_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "WaypointManager_get_Colors", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_dictionary_string_int32(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_WaypointManager_Waypoints(krpc_connection_t connection, krpc_list_object_t * returnValue, krpc_SpaceCenter_WaypointManager_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "WaypointManager_get_Waypoints", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_list_object(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_WaypointManager_Icons(krpc_connection_t connection, krpc_list_string_t * returnValue, krpc_SpaceCenter_WaypointManager_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "WaypointManager_get_Icons", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_list_string(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Wheel_TractionControl(krpc_connection_t connection, float * returnValue, krpc_SpaceCenter_Wheel_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Wheel_get_TractionControl", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_float(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Wheel_set_Brakes(krpc_connection_t connection, krpc_SpaceCenter_Wheel_t instance, float value) {
  krpc_call_t _call;
  krpc_argument_t _arguments[2];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Wheel_set_Brakes", 2, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  KRPC_CHECK(krpc_add_argument(&_call, 1, &krpc_encode_callback_float, &value));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Wheel_Stress(krpc_connection_t connection, float * returnValue, krpc_SpaceCenter_Wheel_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Wheel_get_Stress", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_float(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Wheel_Grounded(krpc_connection_t connection, bool * returnValue, krpc_SpaceCenter_Wheel_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Wheel_get_Grounded", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_bool(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Wheel_HasBrakes(krpc_connection_t connection, bool * returnValue, krpc_SpaceCenter_Wheel_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Wheel_get_HasBrakes", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_bool(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Wheel_MotorOutput(krpc_connection_t connection, float * returnValue, krpc_SpaceCenter_Wheel_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Wheel_get_MotorOutput", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_float(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Wheel_Repairable(krpc_connection_t connection, bool * returnValue, krpc_SpaceCenter_Wheel_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Wheel_get_Repairable", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_bool(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Wheel_set_TractionControlEnabled(krpc_connection_t connection, krpc_SpaceCenter_Wheel_t instance, bool value) {
  krpc_call_t _call;
  krpc_argument_t _arguments[2];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Wheel_set_TractionControlEnabled", 2, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  KRPC_CHECK(krpc_add_argument(&_call, 1, &krpc_encode_callback_bool, &value));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Wheel_State(krpc_connection_t connection, krpc_SpaceCenter_WheelState_t * returnValue, krpc_SpaceCenter_Wheel_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Wheel_get_State", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_enum(&_stream, (int*)returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Wheel_SuspensionSpringStrength(krpc_connection_t connection, float * returnValue, krpc_SpaceCenter_Wheel_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Wheel_get_SuspensionSpringStrength", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_float(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Wheel_MotorState(krpc_connection_t connection, krpc_SpaceCenter_MotorState_t * returnValue, krpc_SpaceCenter_Wheel_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Wheel_get_MotorState", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_enum(&_stream, (int*)returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Wheel_MotorEnabled(krpc_connection_t connection, bool * returnValue, krpc_SpaceCenter_Wheel_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Wheel_get_MotorEnabled", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_bool(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Wheel_Deployable(krpc_connection_t connection, bool * returnValue, krpc_SpaceCenter_Wheel_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Wheel_get_Deployable", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_bool(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Wheel_set_MotorEnabled(krpc_connection_t connection, krpc_SpaceCenter_Wheel_t instance, bool value) {
  krpc_call_t _call;
  krpc_argument_t _arguments[2];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Wheel_set_MotorEnabled", 2, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  KRPC_CHECK(krpc_add_argument(&_call, 1, &krpc_encode_callback_bool, &value));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Wheel_ManualFrictionControl(krpc_connection_t connection, float * returnValue, krpc_SpaceCenter_Wheel_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Wheel_get_ManualFrictionControl", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_float(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Wheel_SuspensionDamperStrength(krpc_connection_t connection, float * returnValue, krpc_SpaceCenter_Wheel_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Wheel_get_SuspensionDamperStrength", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_float(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Wheel_DriveLimiter(krpc_connection_t connection, float * returnValue, krpc_SpaceCenter_Wheel_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Wheel_get_DriveLimiter", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_float(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Wheel_HasSuspension(krpc_connection_t connection, bool * returnValue, krpc_SpaceCenter_Wheel_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Wheel_get_HasSuspension", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_bool(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Wheel_Powered(krpc_connection_t connection, bool * returnValue, krpc_SpaceCenter_Wheel_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Wheel_get_Powered", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_bool(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Wheel_Broken(krpc_connection_t connection, bool * returnValue, krpc_SpaceCenter_Wheel_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Wheel_get_Broken", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_bool(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Wheel_Part(krpc_connection_t connection, krpc_SpaceCenter_Part_t * returnValue, krpc_SpaceCenter_Wheel_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Wheel_get_Part", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_object(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Wheel_StressPercentage(krpc_connection_t connection, float * returnValue, krpc_SpaceCenter_Wheel_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Wheel_get_StressPercentage", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_float(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Wheel_set_TractionControl(krpc_connection_t connection, krpc_SpaceCenter_Wheel_t instance, float value) {
  krpc_call_t _call;
  krpc_argument_t _arguments[2];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Wheel_set_TractionControl", 2, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  KRPC_CHECK(krpc_add_argument(&_call, 1, &krpc_encode_callback_float, &value));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Wheel_set_SteeringEnabled(krpc_connection_t connection, krpc_SpaceCenter_Wheel_t instance, bool value) {
  krpc_call_t _call;
  krpc_argument_t _arguments[2];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Wheel_set_SteeringEnabled", 2, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  KRPC_CHECK(krpc_add_argument(&_call, 1, &krpc_encode_callback_bool, &value));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Wheel_TractionControlEnabled(krpc_connection_t connection, bool * returnValue, krpc_SpaceCenter_Wheel_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Wheel_get_TractionControlEnabled", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_bool(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Wheel_Deployed(krpc_connection_t connection, bool * returnValue, krpc_SpaceCenter_Wheel_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Wheel_get_Deployed", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_bool(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Wheel_set_Deployed(krpc_connection_t connection, krpc_SpaceCenter_Wheel_t instance, bool value) {
  krpc_call_t _call;
  krpc_argument_t _arguments[2];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Wheel_set_Deployed", 2, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  KRPC_CHECK(krpc_add_argument(&_call, 1, &krpc_encode_callback_bool, &value));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Wheel_Steerable(krpc_connection_t connection, bool * returnValue, krpc_SpaceCenter_Wheel_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Wheel_get_Steerable", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_bool(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Wheel_set_ManualFrictionControl(krpc_connection_t connection, krpc_SpaceCenter_Wheel_t instance, float value) {
  krpc_call_t _call;
  krpc_argument_t _arguments[2];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Wheel_set_ManualFrictionControl", 2, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  KRPC_CHECK(krpc_add_argument(&_call, 1, &krpc_encode_callback_float, &value));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Wheel_SteeringEnabled(krpc_connection_t connection, bool * returnValue, krpc_SpaceCenter_Wheel_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Wheel_get_SteeringEnabled", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_bool(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Wheel_set_DriveLimiter(krpc_connection_t connection, krpc_SpaceCenter_Wheel_t instance, float value) {
  krpc_call_t _call;
  krpc_argument_t _arguments[2];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Wheel_set_DriveLimiter", 2, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  KRPC_CHECK(krpc_add_argument(&_call, 1, &krpc_encode_callback_float, &value));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Wheel_AutoFrictionControl(krpc_connection_t connection, bool * returnValue, krpc_SpaceCenter_Wheel_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Wheel_get_AutoFrictionControl", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_bool(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Wheel_SteeringInverted(krpc_connection_t connection, bool * returnValue, krpc_SpaceCenter_Wheel_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Wheel_get_SteeringInverted", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_bool(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Wheel_StressTolerance(krpc_connection_t connection, float * returnValue, krpc_SpaceCenter_Wheel_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Wheel_get_StressTolerance", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_float(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Wheel_set_MotorInverted(krpc_connection_t connection, krpc_SpaceCenter_Wheel_t instance, bool value) {
  krpc_call_t _call;
  krpc_argument_t _arguments[2];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Wheel_set_MotorInverted", 2, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  KRPC_CHECK(krpc_add_argument(&_call, 1, &krpc_encode_callback_bool, &value));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Wheel_Brakes(krpc_connection_t connection, float * returnValue, krpc_SpaceCenter_Wheel_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Wheel_get_Brakes", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_float(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Wheel_set_SteeringInverted(krpc_connection_t connection, krpc_SpaceCenter_Wheel_t instance, bool value) {
  krpc_call_t _call;
  krpc_argument_t _arguments[2];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Wheel_set_SteeringInverted", 2, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  KRPC_CHECK(krpc_add_argument(&_call, 1, &krpc_encode_callback_bool, &value));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Wheel_Deflection(krpc_connection_t connection, float * returnValue, krpc_SpaceCenter_Wheel_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Wheel_get_Deflection", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_float(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Wheel_Radius(krpc_connection_t connection, float * returnValue, krpc_SpaceCenter_Wheel_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Wheel_get_Radius", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_float(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Wheel_Slip(krpc_connection_t connection, float * returnValue, krpc_SpaceCenter_Wheel_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Wheel_get_Slip", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_float(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Wheel_MotorInverted(krpc_connection_t connection, bool * returnValue, krpc_SpaceCenter_Wheel_t instance) {
  krpc_call_t _call;
  krpc_argument_t _arguments[1];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Wheel_get_MotorInverted", 1, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  if (returnValue) {
    pb_istream_t _stream;
    KRPC_CHECK(krpc_get_return_value(&_result, &_stream));
    KRPC_CHECK(krpc_decode_bool(&_stream, returnValue));
  }
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

inline krpc_error_t krpc_SpaceCenter_Wheel_set_AutoFrictionControl(krpc_connection_t connection, krpc_SpaceCenter_Wheel_t instance, bool value) {
  krpc_call_t _call;
  krpc_argument_t _arguments[2];
  KRPC_CHECK(krpc_call(&_call, "SpaceCenter", "Wheel_set_AutoFrictionControl", 2, _arguments));
  KRPC_CHECK(krpc_add_argument(&_call, 0, &krpc_encode_callback_uint64, &instance));
  KRPC_CHECK(krpc_add_argument(&_call, 1, &krpc_encode_callback_bool, &value));
  krpc_result_t _result = KRPC_RESULT_INIT_DEFAULT;
  KRPC_CHECK(krpc_init_result(&_result));
  KRPC_CHECK(krpc_invoke(connection, &_result.message, &_call.message));
  KRPC_CHECK(krpc_free_result(&_result));
  return KRPC_OK;
}

#ifdef __cplusplus
}  // extern "C"
#endif
